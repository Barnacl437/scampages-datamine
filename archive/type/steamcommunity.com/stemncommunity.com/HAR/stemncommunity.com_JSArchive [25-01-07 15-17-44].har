{
  "log": {
    "version": "1.2",
    "creator": {
      "name": "Firefox",
      "version": "133.0.3"
    },
    "browser": {
      "name": "Firefox",
      "version": "133.0.3"
    },
    "pages": [
      {
        "id": "page_2",
        "pageTimings": {
          "onContentLoad": -1,
          "onLoad": -1
        },
        "startedDateTime": "2025-01-07T15:17:36.909+07:00",
        "title": "https://stemncommunity.com/kiliosn/rteern/terny"
      }
    ],
    "entries": [
      {
        "startedDateTime": "2025-01-07T15:17:36.909+07:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "https://stemncommunity.com/211a2f537407565f0c5c564a.js",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "Host",
              "value": "stemncommunity.com"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (X11; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "DNT",
              "value": "1"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Cookie",
              "value": "session=eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4R0NNIn0.fnonTBcl2PzFFHAcLcNJ92IJmKZXOuRS.Aoo_NGAPuyDDQHzb.-k7mh_RUIgv3ifGX2kwgAIUBfVRoHm7Dlyhh5VjDmFYYuWfONL99zA646_ji_6_4CPZx70cVY9HNMLVFYRXMIfwG7DBE6bL1NJjNQfMtXk6xRFCT1SP6roMJXJmpI-56nPMx-iU7IN6VAzd7AcmoeE6IbgE-1onWsr-pL6S0tqF3OaVxL5OSODdFfOWevl8sK_1kgpuBazMZKLn2QFae3RTMWfKOVdYmUZbmVswtGCfjqqbPpbq6cYFr_Q.XLiRIr-1HhIHFhuwNgh5Sg; token=eyJhbGciOiJIUzI1NiJ9.eyJvd25lciI6MjkwLCJzZWNyZXQiOiJlY2EyOTY1NmI4MzJlMmU1OGRmN2YzZDYxOTRhNWI3ZCIsInNlcnZpY2UiOiJTdGVhbSJ9.pWoLEbDIA4lhr1i3MISmgxw0xCCz-Ta83_y9vc3viLA; timezoneOffset=25200,0"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "no-cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            }
          ],
          "cookies": [
            {
              "name": "session",
              "value": "eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4R0NNIn0.fnonTBcl2PzFFHAcLcNJ92IJmKZXOuRS.Aoo_NGAPuyDDQHzb.-k7mh_RUIgv3ifGX2kwgAIUBfVRoHm7Dlyhh5VjDmFYYuWfONL99zA646_ji_6_4CPZx70cVY9HNMLVFYRXMIfwG7DBE6bL1NJjNQfMtXk6xRFCT1SP6roMJXJmpI-56nPMx-iU7IN6VAzd7AcmoeE6IbgE-1onWsr-pL6S0tqF3OaVxL5OSODdFfOWevl8sK_1kgpuBazMZKLn2QFae3RTMWfKOVdYmUZbmVswtGCfjqqbPpbq6cYFr_Q.XLiRIr-1HhIHFhuwNgh5Sg"
            },
            {
              "name": "token",
              "value": "eyJhbGciOiJIUzI1NiJ9.eyJvd25lciI6MjkwLCJzZWNyZXQiOiJlY2EyOTY1NmI4MzJlMmU1OGRmN2YzZDYxOTRhNWI3ZCIsInNlcnZpY2UiOiJTdGVhbSJ9.pWoLEbDIA4lhr1i3MISmgxw0xCCz-Ta83_y9vc3viLA"
            },
            {
              "name": "timezoneOffset",
              "value": "25200,0"
            }
          ],
          "queryString": [],
          "headersSize": 0
        },
        "response": {
          "status": 200,
          "statusText": "",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "alt-svc",
              "value": "h3=\":443\"; ma=2592000"
            },
            {
              "name": "content-disposition",
              "value": "inline"
            },
            {
              "name": "content-encoding",
              "value": "gzip"
            },
            {
              "name": "content-type",
              "value": "application/javascript"
            },
            {
              "name": "cross-origin-opener-policy",
              "value": "same-origin"
            },
            {
              "name": "cross-origin-resource-policy",
              "value": "same-origin"
            },
            {
              "name": "date",
              "value": "Tue, 07 Jan 2025 07:21:46 GMT"
            },
            {
              "name": "last-modified",
              "value": "Wed, 25 Dec 2024 06:24:21 GMT"
            },
            {
              "name": "origin-agent-cluster",
              "value": "?1"
            },
            {
              "name": "referrer-policy",
              "value": "no-referrer"
            },
            {
              "name": "server",
              "value": "Caddy"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=15552000; includeSubDomains"
            },
            {
              "name": "vary",
              "value": "Accept-Encoding"
            },
            {
              "name": "x-content-type-options",
              "value": "nosniff"
            },
            {
              "name": "x-dns-prefetch-control",
              "value": "off"
            },
            {
              "name": "x-download-options",
              "value": "noopen"
            },
            {
              "name": "x-frame-options",
              "value": "SAMEORIGIN"
            },
            {
              "name": "x-permitted-cross-domain-policies",
              "value": "none"
            },
            {
              "name": "x-xss-protection",
              "value": "0"
            },
            {
              "name": "X-Firefox-Spdy",
              "value": "h2"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "application/javascript",
            "size": 0,
            "text": ""
          },
          "redirectURL": "",
          "headersSize": 0,
          "bodySize": 168385
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "ssl": 0,
          "connect": 0,
          "send": 0,
          "wait": 0,
          "receive": 0
        },
        "time": 0,
        "_securityState": "secure",
        "pageref": "page_2"
      },
      {
        "startedDateTime": "2025-01-07T15:17:36.980+07:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "https://store.cloudflare.steamstatic.com/public/shared/javascript/jquery-1.8.3.min.js?v=.TZ2NKhB-nliU&_cdn=cloudflare",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "Host",
              "value": "store.cloudflare.steamstatic.com"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (X11; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "DNT",
              "value": "1"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "no-cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "cross-site"
            }
          ],
          "cookies": [],
          "queryString": [
            {
              "name": "v",
              "value": ".TZ2NKhB-nliU"
            },
            {
              "name": "_cdn",
              "value": "cloudflare"
            }
          ],
          "headersSize": 0
        },
        "response": {
          "status": 200,
          "statusText": "",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "date",
              "value": "Tue, 07 Jan 2025 07:21:47 GMT"
            },
            {
              "name": "content-type",
              "value": "text/javascript;charset=UTF-8"
            },
            {
              "name": "content-length",
              "value": "33382"
            },
            {
              "name": "cache-control",
              "value": "public,max-age=15552000"
            },
            {
              "name": "expires",
              "value": "Mon, 21 Apr 2025 15:04:55 GMT"
            },
            {
              "name": "etag",
              "value": "\".TZ2NKhB-nliU\""
            },
            {
              "name": "last-modified",
              "value": "Wed, 28 Jun 2023 04:07:11 GMT"
            },
            {
              "name": "content-encoding",
              "value": "gzip"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=10368000"
            },
            {
              "name": "x-cache",
              "value": "HIT"
            },
            {
              "name": "cf-cache-status",
              "value": "HIT"
            },
            {
              "name": "age",
              "value": "5207803"
            },
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "vary",
              "value": "Accept-Encoding"
            },
            {
              "name": "server",
              "value": "cloudflare"
            },
            {
              "name": "cf-ray",
              "value": "8fe231694c74dd48-HKG"
            },
            {
              "name": "X-Firefox-Spdy",
              "value": "h2"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "text/javascript; charset=UTF-8",
            "size": 0,
            "text": ""
          },
          "redirectURL": "",
          "headersSize": 0,
          "bodySize": 397181
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "ssl": 0,
          "connect": 0,
          "send": 0,
          "wait": 0,
          "receive": 0
        },
        "time": 0,
        "_securityState": "secure",
        "pageref": "page_2"
      },
      {
        "startedDateTime": "2025-01-07T15:17:36.981+07:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "https://store.cloudflare.steamstatic.com/public/shared/javascript/tooltip.js?v=.zYHOpI1L3Rt0&_cdn=cloudflare",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "Host",
              "value": "store.cloudflare.steamstatic.com"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (X11; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "DNT",
              "value": "1"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "no-cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "cross-site"
            }
          ],
          "cookies": [],
          "queryString": [
            {
              "name": "v",
              "value": ".zYHOpI1L3Rt0"
            },
            {
              "name": "_cdn",
              "value": "cloudflare"
            }
          ],
          "headersSize": 0
        },
        "response": {
          "status": 200,
          "statusText": "",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "date",
              "value": "Tue, 07 Jan 2025 07:21:47 GMT"
            },
            {
              "name": "content-type",
              "value": "text/javascript;charset=UTF-8"
            },
            {
              "name": "content-length",
              "value": "4229"
            },
            {
              "name": "cache-control",
              "value": "public,max-age=15552000"
            },
            {
              "name": "expires",
              "value": "Mon, 21 Apr 2025 18:44:52 GMT"
            },
            {
              "name": "etag",
              "value": "\".zYHOpI1L3Rt0\""
            },
            {
              "name": "last-modified",
              "value": "Wed, 28 Jun 2023 04:07:10 GMT"
            },
            {
              "name": "content-encoding",
              "value": "gzip"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=10368000"
            },
            {
              "name": "x-cache",
              "value": "MISS"
            },
            {
              "name": "cf-cache-status",
              "value": "HIT"
            },
            {
              "name": "age",
              "value": "5034110"
            },
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "vary",
              "value": "Accept-Encoding"
            },
            {
              "name": "server",
              "value": "cloudflare"
            },
            {
              "name": "cf-ray",
              "value": "8fe231694c75dd48-HKG"
            },
            {
              "name": "X-Firefox-Spdy",
              "value": "h2"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "text/javascript; charset=UTF-8",
            "size": 0,
            "text": ""
          },
          "redirectURL": "",
          "headersSize": 0,
          "bodySize": 34783
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "ssl": 0,
          "connect": 0,
          "send": 0,
          "wait": 0,
          "receive": 0
        },
        "time": 0,
        "_securityState": "secure",
        "pageref": "page_2"
      },
      {
        "startedDateTime": "2025-01-07T15:17:36.982+07:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "https://store.cloudflare.steamstatic.com/public/shared/javascript/shared_global.js?v=tbaNc6xLj9BJ&l=russian&_cdn=cloudflare",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "Host",
              "value": "store.cloudflare.steamstatic.com"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (X11; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "DNT",
              "value": "1"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "no-cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "cross-site"
            },
            {
              "name": "If-Modified-Since",
              "value": "Mon, 20 Apr 1970 06:43:19 GMT"
            },
            {
              "name": "If-None-Match",
              "value": "\"_7cV63789cvh\""
            },
            {
              "name": "Priority",
              "value": "u=2"
            },
            {
              "name": "TE",
              "value": "trailers"
            }
          ],
          "cookies": [],
          "queryString": [
            {
              "name": "v",
              "value": "tbaNc6xLj9BJ"
            },
            {
              "name": "l",
              "value": "russian"
            },
            {
              "name": "_cdn",
              "value": "cloudflare"
            }
          ],
          "headersSize": 529
        },
        "response": {
          "status": 200,
          "statusText": "",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "date",
              "value": "Tue, 07 Jan 2025 08:17:37 GMT"
            },
            {
              "name": "content-type",
              "value": "text/javascript;charset=UTF-8"
            },
            {
              "name": "content-length",
              "value": "43238"
            },
            {
              "name": "cache-control",
              "value": "public,max-age=0,must-revalidate"
            },
            {
              "name": "expires",
              "value": "Sun, 09 Sep 2001 01:46:40 GMT"
            },
            {
              "name": "etag",
              "value": "\"_7cV63789cvh\""
            },
            {
              "name": "x-integrity",
              "value": "\"sha384-iidEEIZnR8+G8A+sNGYOu8jY0PB6Pwc72InTvWKTAs24tjw8O+9ym6uwa3iRvLNQ\""
            },
            {
              "name": "last-modified",
              "value": "Mon, 20 Apr 1970 06:43:19 GMT"
            },
            {
              "name": "content-encoding",
              "value": "gzip"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=10368000"
            },
            {
              "name": "x-cache",
              "value": "MISS"
            },
            {
              "name": "cf-cache-status",
              "value": "MISS"
            },
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "vary",
              "value": "Accept-Encoding"
            },
            {
              "name": "server",
              "value": "cloudflare"
            },
            {
              "name": "cf-ray",
              "value": "8fe2832e4dea095d-HKG"
            },
            {
              "name": "X-Firefox-Spdy",
              "value": "h2"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "text/javascript; charset=UTF-8",
            "size": 154268,
            "text": "\nSteam = {\n\tsm_bInitialized: false,\n\tsm_bUserInClient: false,\n\tsm_bUserInGameOverlay: false,\n\tsm_bUserInTenfootBrowser: false,\n\tsm_bUserInMobileChat: false,\n\tsm_bUserInMobileApp: false,\n\n\tBIsUserInSteamClient: function()\n\t{\n\t\tif ( !Steam.sm_bInitialized )\n\t\t\tSteam.Init();\n\n\t\treturn Steam.sm_bUserInClient;\n\t},\n\n\tBIsUserInGameOverlay: function()\n\t{\n\t\tif ( !Steam.sm_bInitialized )\n\t\t\tSteam.Init();\n\n\t\treturn Steam.sm_bUserInGameOverlay\n\t},\n\n\tBIsUserInSteamTenfootBrowser: function()\n\t{\n\t\tif ( !Steam.sm_bInitialized )\n\t\t\tSteam.Init();\n\n\t\treturn Steam.sm_bUserInTenfootBrowser;\n\t},\n\n\tBIsUserInClientOrOverlay: function()\n\t{\n\t\tif ( !Steam.sm_bInitialized )\n\t\t\tSteam.Init();\n\n\t\treturn Steam.sm_bUserInClient || Steam.sm_bUserInGameOverlay;\n\t},\n\n\tBIsUserInSteamMobileChat: function()\n\t{\n\t\tif ( !Steam.sm_bInitialized )\n\t\t\tSteam.Init();\n\n\t\treturn Steam.sm_bUserInMobileChat;\n\t},\n\n\tBIsUserInSteamMobileApp: function()\n\t{\n\t\tif ( !Steam.sm_bInitialized )\n\t\t\tSteam.Init();\n\n\t\treturn Steam.sm_bUserInMobileApp;\n\t},\n\n\tGetClientPackageVersion: function()\n\t{\n\t\tif ( !Steam.BIsUserInClientOrOverlay() )\n\t\t\treturn 0;\n\n\t\tif ( typeof navigator != 'undefined' && navigator.userAgent )\n\t\t{\n\t\t\tvar matches = navigator.userAgent.match( /Valve Steam [^\\/]*\\/([0-9]*)/ );\n\t\t\tif ( matches && matches.length == 2 )\n\t\t\t\treturn matches[1];\n\t\t}\n\n\t\treturn 0;\n\t},\n\n\tInit: function()\n\t{\n\t\tvar fnCheckAgent = function( strUAMatch, strURLParam )\n\t\t{\n\t\t\tif ( window.location.href.match( '[?&]' + strURLParam + '=' ) )\n\t\t\t\treturn true;\n\n\t\t\tif ( typeof navigator != 'undefined' && navigator.userAgent && navigator.userAgent.indexOf( strUAMatch ) != -1 )\n\t\t\t\treturn true;\n\n\t\t\treturn false;\n\t\t};\n\n\t\tSteam.sm_bUserInTenfootBrowser = fnCheckAgent( 'Valve Steam Tenfoot', 'force_tenfoot_client_view' );\n\t\tSteam.sm_bUserInGameOverlay = fnCheckAgent( 'Valve Steam GameOverlay', 'force_overlay_view' );\n\t\tSteam.sm_bUserInClient = Steam.sm_bUserInTenfootBrowser || fnCheckAgent( 'Valve Steam Client', 'force_client_view' );\n\t\tSteam.sm_bUserInMobileChat = fnCheckAgent( 'Valve Steam Mobile Chat', 'force_mobile_chat_view' );\n\t\tSteam.sm_bUserInMobileApp = fnCheckAgent( 'Valve Steam App', 'force_mobile_app_view' );\n\n\t\tSteam.sm_bInitialized = true;\n\t},\n\n\tLinkInNewWindow: function( $A )\n\t{\n\t\tif ( Steam.BIsUserInSteamClient() && !Steam.BIsUserInSteamTenfootBrowser() )\n\t\t\t$A.attr( 'href', 'steam://openurl_external/' + $A.attr('href') );\n\t\telse\n\t\t\t$A.attr( 'target', '_blank' );\n\t}\n};\n\nfunction OpenFriendChat( steamid, accountid )\n{\n\tif ( Steam.BIsUserInClientOrOverlay() )\n\t{\n\t\twindow.location = 'steam://friends/message/' + steamid;\n\t}\n\telse if ( Steam.BIsUserInSteamMobileChat() )\n\t{\n\t\twindow.location = 'steamchatmobile://friend/' + steamid;\n\t}\n\telse if ( Steam.BIsUserInSteamMobileApp() )\n\t{\n\t\t\t\twindow.location = 'https://steamcommunity.com/chat/friend/' + steamid;\n\t}\n\telse if ( typeof ClientConnectionAPI !== 'undefined' )\n\t{\n\t\tClientConnectionAPI.OpenFriendChatDialog( steamid ).then( function( result ) {\n\t\t\tif ( !result.success )\n\t\t\t{\n\t\t\t\tPromptContinueToWebChat( result, function() {\n\t\t\t\t\tOpenFriendChatInWebChat( steamid, accountid );\n\t\t\t\t}, 'steam://friends/message/' + steamid );\n\t\t\t}\n\t\t});\n\t}\n\telse\n\t{\n\t\tOpenFriendChatInWebChat( steamid, accountid );\n\t}\n}\n\nfunction OpenFriendChatInWebChat( steamid, accountid )\n{\n\tLaunchWebChat( { friend: accountid }, {command: 'ShowFriendChatDialog', steamid: steamid} );\n}\n\nfunction OpenGroupChat( steamid )\n{\n\tif ( Steam.BIsUserInSteamMobileChat() )\n\t{\n\t\twindow.location = 'steamchatmobile://group/' + steamid;\n\t}\n\telse if ( Steam.BIsUserInSteamMobileApp() )\n\t{\n\t\t\t\twindow.location = 'https://steamcommunity.com/chat/group/' + steamid;\n\t}\n\telse if ( !Steam.BIsUserInClientOrOverlay() && typeof ClientConnectionAPI !== 'undefined' )\n\t{\n\t\tClientConnectionAPI.OpenFriendChatDialog( steamid ).then( function( result ) {\n\t\t\tif ( !result.success )\n\t\t\t{\n\t\t\t\tPromptContinueToWebChat( result, function() {\n\t\t\t\t\tLaunchWebChat( null, {command: 'ShowFriendChatDialog', steamid: steamid} );\n\t\t\t\t}, 'steam://friends/joinchat/' + steamid );\n\t\t\t}\n\t\t});\n\t}\n\telse\n\t{\n\t\twindow.location = 'steam://friends/joinchat/' + steamid;\n\t}\n}\n\nfunction PromptContinueToWebChat( result, fnLaunchWebchat, steamURL )\n{\n\tShowConfirmDialog( 'У вас есть Steam?', 'Не удалось найти запущенный клиент Steam на вашем компьютере. Открыть веб-версию чата?',\n\t\t'Открыть веб-чат' , null, 'Установить Steam' ).done( function( choice ) {\n\t\t\tif ( choice == 'OK' )\n\t\t\t\tfnLaunchWebchat();\n\t\t\telse\n\t\t\t\twindow.location = 'https://store.steampowered.com/about/'\n\t});\n}\n\n\n// proto functions used to accept an id or an element.\n// This can be used to migrate them to returning jquery instead of proto-wrapped element\nfunction $JFromIDOrElement( elem )\n{\n\tif ( elem instanceof jQuery )\n\t\treturn elem;\n\telse if ( typeof elem == 'string' )\n\t\treturn $J('#' + elem.replace( /\\./, '\\\\.' ) );\n\telse\n\t\treturn $J( elem );\n}\n\n/**\tShow a popup dialog like confirm(), with two buttons.  Clicking ok resolves with done(), cancel or closing the window resolves with fail()\n *\n * @param strTitle\t\t\tTitle bar text\n * @param strDescription\tMessage text\n * @param strOKButton\t\tText to show on OK button (default \"OK\")\n * @param strCancelButton\tText to show on Cancel button (default \"Cancel\")\n * @param strSecondaryActionButton\tAdd a secondary ok button (three buttons total).  Resolves with done() like OK but passes 'SECONDARY' as argument to handler\n * @returns CModal\n */\nfunction ShowConfirmDialog( strTitle, strDescription, strOKButton, strCancelButton, strSecondaryActionButton, rgModalParams )\n{\n\tif ( !strOKButton )\n\t\tstrOKButton = 'OK';\n\tif ( !strCancelButton )\n\t\tstrCancelButton = 'Отмена';\n\n\tvar deferred = new jQuery.Deferred();\n\tvar fnOK = function() { deferred.resolve( 'OK' ); };\n\tvar fnSecondary = function() { deferred.resolve( 'SECONDARY' ); };\n\tvar fnCancel = function( bWasCancelButton ) { deferred.reject( bWasCancelButton ); };\n\n\tvar rgButtons = [];\n\n\tvar $OKButton = _BuildDialogButton( strOKButton, true );\n\t$OKButton.click( fnOK );\n\trgButtons.push( $OKButton );\n\n\tif ( strSecondaryActionButton )\n\t{\n\t\tvar $SecondaryActionButton = _BuildDialogButton( strSecondaryActionButton, false, {strClassName: 'btn_blue_steamui btn_medium' } );\n\t\t$SecondaryActionButton.click( fnSecondary );\n\t\trgButtons.push( $SecondaryActionButton );\n\t}\n\n\tvar $CancelButton = _BuildDialogButton( strCancelButton );\n\t$CancelButton.click( function() { fnCancel( true ); } );\n\trgButtons.push( $CancelButton );\n\n\tvar Modal = _BuildDialog( strTitle, strDescription, rgButtons, fnCancel, rgModalParams );\n\tModal.Show();\n\n\t_BindOnEnterKeyPressForDialog( Modal, deferred, fnOK );\n\n\tdeferred.always( function() { Modal.Dismiss(); } );\n\t// attach the deferred's events to the modal\n\tdeferred.promise( Modal );\n\n\treturn Modal;\n}\n\n/**\tShow a dialog with a single button, like alert().  Button click or closing the modal resolve deferred with done().\n *\n * @param strTitle\t\t\tTitle bar text\n * @param strDescription\tMessage text\n * @param strOKButton\t\tText on the OK button (\"OK\" by default)\n * @returns CModal\n */\nfunction ShowAlertDialog( strTitle, strDescription, strOKButton, rgModalParams )\n{\n\tif ( !strOKButton )\n\t\tstrOKButton = 'OK';\n\n\tvar deferred = new jQuery.Deferred();\n\tvar fnOK = function( bWasCancelButton ) { deferred.resolve( bWasCancelButton ); };\n\n\tvar $OKButton = _BuildDialogButton( strOKButton );\n\t$OKButton.click( function() { fnOK( true ); } );\n\n\tvar Modal = _BuildDialog( strTitle, strDescription, [ $OKButton ], fnOK, rgModalParams );\n\tdeferred.always( function() { Modal.Dismiss(); } );\n\tModal.Show();\n\n\t_BindOnEnterKeyPressForDialog( Modal, deferred, fnOK );\n\n\t// attach the deferred's events to the modal\n\tdeferred.promise( Modal );\n\n\treturn Modal;\n\n}\n\n/**\tShow a popup dialog.  Has no buttons.  Closing the dialog resolves deferred with done().\n *\n * @param strTitle\t\t\tTitle bar text\n * @param strDescription\tMessage text\n * @param rgModalParams\t\tSee CModal\n * @returns CModal\n */\nfunction ShowDialog( strTitle, strDescription, rgModalParams )\n{\n\tvar deferred = new jQuery.Deferred();\n\tvar fnOK = function() { deferred.resolve(); };\n\n\tvar Modal = _BuildDialog( strTitle, strDescription, [], fnOK, rgModalParams );\n\tdeferred.always( function() { Modal.Dismiss(); } );\n\tModal.Show();\n\n\t// attach the deferred's events to the modal\n\tdeferred.promise( Modal );\n\n\treturn Modal;\n}\n\n/**\n * Show a dialog, but take the arguments as an object a la React.\n * @returns CModal\n */\nfunction ShowPromptDialogWithProps( rgParams )\n{\n\tlet { strOKButton, strCancelButton, strTitle, strDescription, defaultValue, inputType, inputMaxSize, bNoPromiseDismiss } = rgParams;\n\tif ( !strOKButton )\n\t\tstrOKButton = 'OK';\n\tif ( !strCancelButton )\n\t\tstrCancelButton = 'Отмена';\n\tif ( !inputType )\n\t\tinputType = 'text';\n\n\tvar $Body = $J('<form/>');\n\tvar $Input = $J('<input/>', {type: inputType, 'class': '' } ).val( defaultValue );\n\tif ( inputMaxSize )\n\t{\n\t\t$Input.attr( 'maxlength', inputMaxSize );\n\t}\n\t$Body.append( $J('<div/>', {'class': 'newmodal_prompt_description' } ).append( strDescription ) );\n\t$Body.append( $J('<div/>', {'class': 'newmodal_prompt_input gray_bevel for_text_input fullwidth' } ).append( $Input ) );\n\n\tvar deferred = new jQuery.Deferred();\n\tvar fnOK = function() { deferred.resolve( $Input.val() ); };\n\tvar fnCancel = function() { deferred.reject(); };\n\n\t$Body.submit( function( event ) { event.preventDefault(); fnOK(); } );\n\n\tvar elButtonLabel = $J( '<span/>' ).text( strOKButton );\n\tvar $OKButton = $J('<button/>', {type: 'submit', 'class': 'btn_green_white_innerfade btn_medium' } ).append( elButtonLabel );\n\t$OKButton.click( fnOK );\n\tvar $CancelButton = _BuildDialogButton( strCancelButton );\n\t$CancelButton.click( fnCancel );\n\n\tvar Modal = _BuildDialog( strTitle, $Body, [ $OKButton, $CancelButton ], fnCancel );\n\tif( !bNoPromiseDismiss )\n\t\tdeferred.always( function() { Modal.Dismiss(); } );\n\n\tModal.Show();\n\n\t$Input.focus();\n\n\t// attach the deferred's events to the modal\n\tdeferred.promise( Modal );\n\n\treturn Modal;\n}\n\n/**\n * A wrapper around ShowDialogPrompt to be compatible with existing code. Prefer ShowPromptDialogWithProps instead.\n * @returns CModal\n */\nfunction ShowPromptDialog( strTitle, strDescription, strOKButton, strCancelButton, rgModalParams, defaultValue )\n{\n\tlet rgParams = {};\n\tif ( rgModalParams )\n\t\tObject.assign( rgParams, rgModalParams );\n\trgParams.strTitle = strTitle;\n\trgParams.strDescription = strDescription;\n\trgParams.strOKButton = strOKButton;\n\trgParams.strCancelButton = strCancelButton;\n\trgParams.defaultValue = defaultValue;\n\treturn ShowPromptDialogWithProps( rgParams );\n}\n\n/**\n * @returns CModal\n */\nfunction ShowPromptWithTextAreaDialog( strTitle, strInitialText, strOKButton, strCancelButton, textAreaMaxLength, strDescription )\n{\n\tif ( !strOKButton )\n\t\tstrOKButton = 'OK';\n\tif ( !strCancelButton )\n\t\tstrCancelButton = 'Отмена';\n\n\tvar $Body = $J('<form/>');\n\tvar $TextArea = $J('<textarea/>', { 'class': 'newmodal_prompt_textarea' } );\n\t$TextArea.text( strInitialText );\n\tif ( textAreaMaxLength )\n\t{\n\t\t$TextArea.attr( 'maxlength', textAreaMaxLength );\n\t\t$TextArea.bind( \"keyup change\",\n\t\t\tfunction()\n\t\t\t{\n\t\t\t\tvar str = $J(this).val();\n\t\t\t\tvar mx = parseInt($J(this).attr('maxlength'));\n\t\t\t\tif (str.length > mx)\n\t\t\t\t{\n\t\t\t\t\t$J(this).val(str.substr(0, mx));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\tif ( strDescription )\n\t{\n\t\t$Body.append( $J('<div/>', {'class': 'newmodal_prompt_with_textarea newmodal_prompt_description' } ).text( strDescription ) );\n\t}\n\n\t$Body.append( $J('<div/>', {'class': 'newmodal_prompt_with_textarea gray_bevel fullwidth' } ).append( $TextArea ) );\n\n\tvar deferred = new jQuery.Deferred();\n\tvar fnOK = function() { deferred.resolve( $TextArea.val() ); };\n\tvar fnCancel = function() { deferred.reject(); };\n\n\t$Body.submit( function( event ) { event.preventDefault(); fnOK(); } );\n\n\tvar elButtonLabel = $J( '<span/>' ).text( strOKButton );\n\tvar $OKButton = $J('<button/>', {type: 'submit', 'class': 'btn_green_white_innerfade btn_medium' } ).append( elButtonLabel );\n\t$OKButton.click( fnOK );\n\tvar $CancelButton = _BuildDialogButton( strCancelButton );\n\t$CancelButton.click( fnCancel );\n\n\tvar Modal = _BuildDialog( strTitle, $Body, [ $OKButton, $CancelButton ], fnCancel );\n\tdeferred.always( function() { Modal.Dismiss(); } );\n\tModal.Show();\n\n\t$TextArea.focus();\n\n\t// attach the deferred's events to the modal\n\tdeferred.promise( Modal );\n\n\treturn Modal;\n}\n\n/**\n * @returns CModal\n */\nfunction ShowEditablePrompt( strTitle, obj, onOk, onCancel)\n{\n\tstrEditButton = 'Редактировать';\n\tstrOKButton = 'OK';\n\tstrCancelButton = 'Отмена';\n\n\tvar $Body = $J('<form/>');\n\tvar $TextArea = $J('<textarea/>', {'class': 'newmodal_prompt_textarea', 'id': 'json_window'});\n\t$TextArea[0].readOnly = true;\n\t$TextArea.text( JSON.stringify(obj, null, 2) );\n\t$Body.append( $J('<div/>', {'class': 'newmodal_prompt_with_textarea gray_bevel fullwidth ' } ).append( $TextArea ) );\n\n\t$Body.submit( function( event ) { event.preventDefault(); fnOK(); } );\n\n\tvar elButtonLabel = $J( '<span/>' ).text( strOKButton );\n\tvar deferredAction = new jQuery.Deferred();\n\n\tvar editButtonLabel = $J( '<span/>' ).text( strEditButton );\n\tvar $EditButton = $J('<button/>', {type: 'button', 'class': 'btn_darkred_white_innerfade btn_medium' } ).append( editButtonLabel );\n\t$EditButton.click( function() {\n\t\t$EditButton[0].disable();\n\t\t$OKButton[0].enable();\n\t\t$TextArea[0].readOnly = false;\n\t\t$TextArea.focus();\n\t})\n\n\tvar $OKButton = $J('<button/>', {type: 'submit', 'class': 'btn_green_white_innerfade btn_medium' } ).append( elButtonLabel );\n\t$OKButton.click( function() { deferredAction.resolve( $TextArea.val() ); } );\n\t$OKButton[0].disabled = true;\n\n\tfnCancel = function() { deferredAction.reject(); };\n\tvar $CancelButton = _BuildDialogButton( strCancelButton );\n\t$CancelButton.click( fnCancel );\n\n\tvar Modal = _BuildDialog( strTitle, $Body, [ $EditButton, $OKButton, $CancelButton ], fnCancel );\n\tdeferredAction.always( function() { Modal.Dismiss(); } );\n\n\tif (onOk)\n\t\tdeferredAction.done(onOk);\n\tif (onCancel)\n\t\tdeferredAction.fail(onCancel);\n\n\tModal.Show();\n\n\t$TextArea.focus();\n\n\t// attach the deferred's events to the modal\n\tdeferredAction.promise( Modal );\n\n\treturn Modal;\n}\n\n/**\n * @returns CModal\n */\nfunction ShowBlockingWaitDialog( strTitle, strDescription )\n{\n\tvar deferred = new jQuery.Deferred();\n\tvar fnOK = function() { deferred.resolve(); };\n\n\tvar container = $J('<div/>', {'class': 'waiting_dialog_container'} );\n\tvar throbber = $J('<div/>', {'class': 'waiting_dialog_throbber'} );\n\tcontainer.append( throbber );\n\tcontainer.append( strDescription );\n\tif ( !strDescription )\n\t{\n\t\tcontainer.addClass( 'waiting_dialog_centered' );\n\t}\n\n\tvar Modal = _BuildDialog( strTitle, container, [], fnOK, { bExplicitDismissalOnly: true } );\n\tdeferred.always( function() { Modal.Dismiss(); } );\n\tModal.Show();\n\n\t// attach the deferred's events to the modal\n\tdeferred.promise( Modal );\n\n\treturn Modal;\n}\n\nfunction _BindOnEnterKeyPressForDialog( Modal, deferred, fnOnEnter )\n{\n\tvar fnOnKeyUp = function( event ) {\n\t\tif ( Modal.BIsActiveModal() && !event.isDefaultPrevented() && event.which == 13 && ( !event.target || event.target.nodeName != 'TEXTAREA' ) )\n\t\t\tfnOnEnter();\n\t};\n\t$J(document).on( 'keyup.SharedConfirmDialog', fnOnKeyUp );\n\tdeferred.always( function() { $J(document).off( 'keyup.SharedConfirmDialog' ); } );\n}\n\n/**\n * @returns CModal\n * @private\n */\nfunction _BuildDialog( strTitle, strDescription, rgButtons, fnOnCancel, rgModalParams )\n{\n\tvar $Dialog = $J('<div/>', {'class': 'newmodal'} );\n\tvar $CloseButton = $J('<div/>', {'class': 'newmodal_close', 'data-panel': '{\"focusable\":true,\"clickOnActivate\":true}' } );\n\tvar $Header = ( $J('<div/>', {'class': 'newmodal_header' }) );\n\tvar $TopBar = ( $J('<div/>', {'class': 'modal_top_bar' }) );\n\tif ( strTitle )\n\t\t$Header.append( $CloseButton ).append( $J('<div/>', {'class': 'title_text' } ).text( strTitle ) );\n    if ( rgModalParams && rgModalParams.strSubTitle ) {\n        var $SubTitle = (rgModalParams.strSubTitle);\n        $Header.append( $J('<div/>', {'class': 'subtitle_text' } ).text( $SubTitle ) )\n    }\n\t$Header = $J('<div/>', {'class': 'newmodal_header_border'}).append( $Header );\n\t$Dialog.append( $TopBar ).append( $Header );\n\tvar $Content = $J('<div/>', {'class': 'newmodal_content' } );\n\t$Content.append( $J('<div/>').append( strDescription ) );\n\n\tif ( rgButtons.length > 0 )\n\t{\n\t\tvar $Buttons = $J('<div/>', {'class': 'newmodal_buttons', 'data-panel': '{\"flow-children\":\"row\"}' } );\n\t\t$Content.append( $Buttons );\n\t\tfor( var i = 0; i < rgButtons.length; i++ )\n\t\t{\n\t\t\tvar $Button = rgButtons[i];\n\t\t\tif ( i == 0 )\n\t\t\t\t$Button.attr( 'data-panel', '{\"autoFocus\":true,\"focusable\":true,\"clickOnActivate\":true}' );\n\t\t\telse\n\t\t\t\t$Button.attr( 'data-panel', '{\"focusable\":true,\"clickOnActivate\":true}' );\n\t\t\t$Buttons.append( $Button );\n\t\t}\n\t}\n\n\t$Dialog.append( $J('<div/>', {'class': 'newmodal_content_border' } ).append( $Content ) );\n\n\tif ( rgModalParams && rgModalParams.bExplicitDismissalOnly )\n\t\t$CloseButton.hide();\n\n\tvar Modal = new CModal( $Dialog, rgModalParams );\n\tif ( fnOnCancel )\n\t{\n\t\tModal.OnDismiss( fnOnCancel );\n\t\t$CloseButton.click( function() { Modal.Dismiss(); } );\n\t}\n\n\t// on responsive pages, the 'newmodal' element covers the whole viewable area (so that we can control scrolling\n\t// if the modal is very tall).  If the modal doesn't cover the whole area, we dismiss on clicks to this background\n\t//\tarea\n\tif ( Modal.m_fnBackgroundClick )\n\t{\n\t\t$Dialog.click( function(e) { if ( e.target == this ) Modal.m_fnBackgroundClick(); } );\n\t}\n\n\tModal.SetRemoveContentOnDismissal( true );\n\n\treturn Modal;\n}\n\nfunction _BuildDialogButton( strText, bActive, rgOptions )\n{\n\tif ( !rgOptions )\n\t\trgOptions = {};\n\n\tvar strClassName = bActive ? 'btn_green_steamui btn_medium' : 'btn_grey_steamui btn_medium';\n\tif ( rgOptions.strClassName )\n\t\tstrClassName = rgOptions.strClassName;\n\n\tvar elButtonLabel = $J( '<span/>' ).html( strText );\n\tvar elButton = $J('<div/>', {'class': strClassName } ).append( elButtonLabel );\n\treturn elButton;\n}\n\n/**\tImplemented for Gamepad: show content in a fullscreen, borderless, modal which gets navigation support.\n *  Used on the app details page to show screenshots in full screen.\n *  Closing the dialog resolves deferred with done().\n *\n * @returns CModal\n */\nfunction GPShowFullScreenModal( content )\n{\n\tvar deferred = new jQuery.Deferred();\n\tvar fnOK = function() { deferred.resolve(); };\n\n\tvar Modal = _BuilGPFullScreenModal( content, fnOK );\n\tdeferred.always( function() { Modal.Dismiss(); } );\n\tModal.Show();\n\n\t// attach the deferred's events to the modal\n\tdeferred.promise( Modal );\n\n\treturn Modal;\n}\n\nfunction _BuilGPFullScreenModal( content, fnOnCancel )\n{\n\t\tvar $Dialog = $J('<div/>').append( $J('<div/>', {'style': 'display:flex'} ).append( content ) );\n\tvar Modal = new CModal( $Dialog );\n\n\tModal.SetRemoveContentOnDismissal( true );\n\tif ( fnOnCancel )\n\t{\n\t\tModal.OnDismiss( fnOnCancel );\n\t}\n\n\treturn Modal;\n}\n\n/* modal params:\n\tbExplicitDismissalOnly - by default, clicking outside of the modal dismisses it.  Set this to true to override that behavior\n\tbIgnoreResizeEvents - don't resize the modal when the window resizes\n */\n\nfunction CModal( $Content, rgParams )\n{\n\trgParams = rgParams || {};\n\n\tthis.m_$Content = $Content;\n\tthis.m_bVisible = false;\n\n\tthis.m_bIgnoreResizeEvents = rgParams.bIgnoreResizeEvents;\n\tthis.m_fnSizing = null;\n\tthis.m_fnBackgroundClick = null;\n\tthis.m_fnOnResize = null;\n\tthis.m_bDismissOnBackgroundClick = !rgParams.bExplicitDismissalOnly;\n\tthis.m_nMaxWidth = rgParams.nMaxWidth || 0;\n\tthis.m_nMaxHeight = rgParams.nMaxHeight || 0;\n\n\tthis.m_fnOnDismiss = null;\n\tthis.m_fnGPOnCloseModal = null;\n\tthis.m_bRemoveContentOnDismissal = false;\n\n\tthis.m_nInitialOffsetTop = $J(window).scrollTop();\n\tthis.m_nInitialOffsetLeft = $J(window).scrollLeft();\n\tthis.m_$Content.css( 'position', 'fixed' );\n\tthis.m_$Content.css( 'z-index', 1000 );\n\n\t/* default gamepad behavior is B button closes the dialog */\n\tif ( !this.m_$Content.attr('panel' ) )\n\t\tthis.m_$Content.attr( 'data-panel', '{\"onCancelButton\":\"CModal.DismissActiveModal()\"}' );\n\n\tthis.m_$StandardContent = null;\n\tthis.m_$SizedContent = null;\n\tthis.OnContentChanged();\t//this will look for StandardContent and SizedContent in the modal body\n\n\n\tvar _modal = this;\n\tthis.m_fnBackgroundClick = function() { if ( _modal.BIsActiveModal() && _modal.m_bDismissOnBackgroundClick ) { _modal.Dismiss(); } };\n\tthis.m_fnOnEscapeKeyPress = function( event ) { if ( _modal.BIsActiveModal() && event.which == 27 ) _modal.m_fnBackgroundClick(); };\n\tthis.m_fnSizing = function() { _modal.AdjustSizing(); };\n\n\t/* make sure the content is parented correctly */\n\t$J(document.body).append( this.m_$Content );\n}\n\nCModal.prototype.OnDismiss = function( fn )\n{\n\tthis.m_fnOnDismiss = fn;\n};\n\nCModal.prototype.OnResize = function( fn )\n{\n\tthis.m_fnOnResize = fn;\n};\n\n/**\n * @returns jQuery\n */\nCModal.prototype.GetContent = function ()\n{\n\treturn this.m_$Content;\n};\n\nCModal.prototype.GetBoundOnResizeEvent = function()\n{\n\t// in case someone outside needs to tell the modal to resize on certain events (eg images or iframes loading in the modal)\n\treturn this.m_fnSizing;\n};\n\nCModal.prototype.OnContentChanged = function()\n{\n\t// make sure we're holding the right elements\n\tthis.m_$StandardContent = this.m_$Content.find( '.newmodal_content' );\n\tif ( !this.m_$StandardContent.length )\n\t\tthis.m_$StandardContent = this.m_$Content;\n\tthis.m_$SizedContent = this.m_$Content.find( '.newmodal_sized_content' );\n};\n\nCModal.prototype.SetRemoveContentOnDismissal = function ( bRemoveContent )\n{\n\tthis.m_bRemoveContentOnDismissal = bRemoveContent;\n};\n\nCModal.prototype.SetDismissOnBackgroundClick = function ( bDismissOnBackgroundClick )\n{\n\tthis.m_bDismissOnBackgroundClick = bDismissOnBackgroundClick;\n};\n\nCModal.prototype.SetMaxWidth = function ( nMaxWidth )\n{\n\tthis.m_nMaxWidth = nMaxWidth;\n\tif ( this.m_bVisible )\n\t\tthis.AdjustSizing();\n};\n\nCModal.prototype.SetMaxHeight = function ( nMaxHeight )\n{\n\tthis.m_nMaxHeight = nMaxHeight;\n\tif ( this.m_bVisible )\n\t\tthis.AdjustSizing();\n};\n\nCModal.prototype.AdjustSizing = function( duration )\n{\n\tif ( !this.m_$Content )\n\t\treturn;\n\n\tvar bResponsiveScreen = window.UseTouchFriendlyMode && UseTouchFriendlyMode();\n\tvar bUseTabletScreenMode = window.UseTabletScreenMode && window.UseTabletScreenMode();\n\n\tvar nViewportWidth = document.compatMode === 'BackCompat' ? document.body.clientWidth : $J(window).width();\n\tvar nViewportHeight = document.compatMode === 'BackCompat' ? document.body.clientHeight : $J(window).height();\n\n\tvar nMaxWidth = Math.max( nViewportWidth - ( bResponsiveScreen? 24 : 80 ), bResponsiveScreen ? 200 : 500 );\n\tvar nMaxHeight = Math.floor( nViewportHeight - 120 );\n\n\tif ( this.m_nMaxWidth && nMaxWidth > this.m_nMaxWidth )\n\t{\n\t\tnMaxWidth = this.m_nMaxWidth;\n\t}\n\n\tif ( this.m_nMaxHeight && nMaxHeight > this.m_nMaxHeight )\n\t{\n\t\tnMaxHeight = this.m_nMaxHeight;\n\t}\n\n\t// if the modal has a 'newmodal_sized_content' div, it wants to be the max height, so set it now\n\t//\tbefore we compute height\t( \"- 18\" is a fudge for a possible horizontal scrollbar )\n\tthis.m_$SizedContent.css( 'min-height', ( nMaxHeight - 18 ) + 'px' );\n\tif ( this.m_fnOnResize )\n\t{\n\t\tthis.m_fnOnResize( nMaxWidth - 40, nMaxHeight );\n\t}\n\n\tif ( !duration )\n\t{\n\t\t// set sizes right away so we can calculate a good left and top\n\t\tthis.m_$Content.css( 'max-width',  nMaxWidth + 'px' );\n\t\tif ( !bResponsiveScreen )\n\t\t{\n\t\t\tthis.m_$StandardContent.css( 'max-height',  nMaxHeight + 'px' );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.m_$StandardContent.css( 'max-height', '' );\n\t\t}\n\t}\n\n\tvar nContentWidth = this.m_$Content.width();\n\tvar nContentHeight = this.m_$Content.height();\n\tvar nLeft = Math.max( Math.floor( ( nViewportWidth - nContentWidth ) / 2 ), 12 );\n\tvar nTop = Math.max( Math.floor( ( nViewportHeight - nContentHeight ) / 2 ), 12 );\n\n\t// only use absolute position on mobile screens\n\tif ( bResponsiveScreen && !bUseTabletScreenMode )\n\t{\n\t\tnLeft += this.m_nInitialOffsetLeft;\n\t\tnTop += this.m_nInitialOffsetTop;\n\t\tthis.m_$Content.css( 'position', 'absolute' );\n\t}\n\telse\n\t{\n\t\tthis.m_$Content.css( 'position', 'fixed' );\n\t}\n\n\tif ( duration )\n\t{\n\t\tthis.m_$Content.animate( { 'max-width': nMaxWidth, left: nLeft, top: nTop }, duration );\n\t\tthis.m_$StandardContent.animate( {'max-height': nMaxHeight }, duration );\n\t}\n\telse\n\t{\n\t\tthis.m_$Content.css( 'left', nLeft );\n\t\tthis.m_$Content.css( 'top', nTop );\n\t}\n};\n\nCModal.prototype.Show = function()\n{\n\tif ( this.m_bVisible )\n\t\treturn;\n\n\tCModal.ShowModalBackground();\n\n\tif ( !this.m_bIgnoreResizeEvents )\n\t{\n\t\t$J(window).on( 'resize', null, this.m_fnSizing );\n\t}\n\tCModal.s_$Background.on( 'click.CModal', this.m_fnBackgroundClick );\n\t$J(document).on( 'keyup.CModal', this.m_fnOnEscapeKeyPress );\n\n\tthis.AdjustSizing();\n\n\t// if we're in gamepad, notify gamepad navigation of the modal\n\tif ( typeof GPOnShowingModalWindow === \"function\" )\n\t\tthis.m_fnGPOnCloseModal = GPOnShowingModalWindow( this.m_$Content.get( 0 ) );\n\n\tthis.m_$Content.show();\n\n\t// resize as any child image elements load in.\n\tthis.m_$Content.find('img').load( this.m_fnSizing );\n\n\tthis.m_bVisible = true;\n\tCModal.PushActiveModal( this );\n\n\tvar _this = this;\n\tif ( typeof GPNavFocusChild !== 'undefined' )\n\t\twindow.setTimeout( function() { GPNavFocusChild( _this.m_$Content ) }, 1 );\t};\n\nCModal.prototype.Dismiss = function()\n{\n\tif ( !this.m_bVisible )\n\t\treturn;\n\n\tthis.m_bVisible = false;\n\n\t// tell gamepad navigation we're closing this modal\n\tif ( this.m_fnGPOnCloseModal )\n\t{\n\t\tthis.m_fnGPOnCloseModal();\n\t\tthis.m_fnGPOnCloseModal = null;\n\t}\n\n\tthis.m_$Content.hide();\n\n\tif ( !this.m_bIgnoreResizeEvents )\n\t{\n\t\t$J(window).off( 'resize', null, this.m_fnSizing );\n\t}\n\n\tif ( this.m_fnOnDismiss )\n\t\tthis.m_fnOnDismiss();\n\n\tif ( this.m_bRemoveContentOnDismissal )\n\t{\n\t\tthis.m_$Content.remove();\n\t\tthis.m_$Content = null;\n\t}\n\n\tCModal.PopActiveModal( this );\n\tif ( !CModal.s_rgModalStack.length )\n\t{\n\t\tCModal.s_$Background.off( 'click.CModal', this.m_fnBackgroundClick );\n\t\t$J(document).off( 'keyup.CModal', this.m_fnOnEscapeKeyPress );\n\t\tCModal.HideModalBackground();\n\t}\n};\n\nCModal.prototype.BIsActiveModal = function()\n{\n\treturn CModal.s_rgModalStack.length && CModal.s_rgModalStack[ CModal.s_rgModalStack.length - 1 ] == this;\n};\n\n/* static */\nCModal.ShowModalBackground = function()\n{\n\tif ( !CModal.s_$Background )\n\t{\n\t\tCModal.s_$Background = $J('<div/>', {'class': 'newmodal_background'});\n\t\tCModal.s_$Background.css( 'opacity', 0 );\n\t\t$J(document.body).append( CModal.s_$Background );\n\t}\n\tCModal.s_$Background.stop();\t// stop running animations\n\tCModal.s_$Background.fadeTo( 200, 0.8 );\n};\n\nCModal.HideModalBackground = function()\n{\n\tif ( CModal.s_$Background )\n\t{\n\t\tCModal.s_$Background.stop();\t// stop running animations\n\t\tCModal.s_$Background.fadeOut( 200, 0 );\n\t}\n};\n\nCModal.s_rgModalStack = [];\nCModal.GetActiveModal = function()\n{\n\tif ( CModal.s_rgModalStack.length )\n\t\treturn CModal.s_rgModalStack[CModal.s_rgModalStack.length-1];\n\telse\n\t\treturn null;\n};\nCModal.DismissActiveModal = function()\n{\n\tif ( CModal.s_rgModalStack.length )\n\t\tCModal.s_rgModalStack[CModal.s_rgModalStack.length-1].Dismiss();\n};\n\nCModal.PushActiveModal = function( Modal )\n{\n\tfor ( var i = 0; i < CModal.s_rgModalStack.length; i++ )\n\t{\n\t\t// push below background\n\t\tCModal.s_rgModalStack[i].m_$Content.css( 'z-index', 899 );\n\t}\n\tCModal.s_rgModalStack.push( Modal );\n};\n\nCModal.PopActiveModal = function( Modal )\n{\n\tfor ( var i = 0; i < CModal.s_rgModalStack.length; i++ )\n\t{\n\t\tif ( CModal.s_rgModalStack[i] == Modal )\n\t\t{\n\t\t\tCModal.s_rgModalStack.splice( i, 1 );\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( CModal.s_rgModalStack.length )\n\t\tCModal.s_rgModalStack[ CModal.s_rgModalStack.length - 1 ].m_$Content.css( 'z-index', 1000 );\n};\n\n// this will set the right headers for a cross-domain request to community\nfunction GetDefaultCommunityAJAXParams( path, method )\n{\n\tvar rgParams = { url: 'https://steamcommunity.com/' + path };\n\tif ( method )\n\t\trgParams.type = method;\n\n\t// if this js file was hosted off the store, add CORS request headers\n\tif ( window.location.href.indexOf( 'https://steamcommunity.com/' ) != 0 )\n\t{\n\t\trgParams.crossDomain = true;\n\t\trgParams.xhrFields = { withCredentials: true };\n\t}\n\treturn rgParams;\n}\n\nfunction CrossDomainPost( url, params )\n{\n\t\treturn $J.ajax( {\n\t\ttype: 'post',\n\t\turl: url,\n\t\tdata: params,\n\t\tcrossDomain: true,\n\t\txhrFields: { withCredentials: true }\n\t} );\n}\n\n// spped of the miniprofile fading in and out\nvar MINIPROFILE_ANIM_SPEED = 150;\n// how long the mouse must remain over an element before we'll make an AJAX call\nvar MINIPROFILE_DELAY_BEFORE_AJAX = 100;\n// the delay before we'll show the hover, must be longer than DELAY_BEFORE_AJAX\nvar MINIPROFILE_DELAY_BEFORE_SHOW = 250;\n\nfunction CDelayedAJAXData( strURL, msDelayBeforeAJAX )\n{\n\tthis.m_$Data = null;\n\tthis.m_bAJAXFailed = false;\n\tthis.m_timerDelayedAJAX = null;\n\tthis.m_bAJAXRequestMade = false;\n\tthis.m_msDelayBeforeAJAX = msDelayBeforeAJAX;\n\tthis.m_strURL = strURL;\n\n\tthis.m_fnOnAJAXComplete = null;\n}\n\nCDelayedAJAXData.prototype.GetAJAXParams = function()\n{\n\treturn GetDefaultCommunityAJAXParams( this.m_strURL, 'GET' );\n};\n\nCDelayedAJAXData.prototype.QueueAjaxRequestIfNecessary = function()\n{\n\tif ( !this.m_$Data && !this.m_bAJAXRequestMade )\n\t{\n\t\tvar _this = this;\n\t\tthis.m_timerDelayedAJAX = window.setTimeout( function() {\n\t\t\t_this.m_timerDelayedAJAX = null;\n\t\t\t_this.m_bAJAXRequestMade = true;\n\t\t\tvar rgAJAXParams = _this.GetAJAXParams();\n\t\t\t$J.ajax( rgAJAXParams )\n\t\t\t\t.done( function(data) {\n\t\t\t\t\t_this.m_$Data = $J(data);\n\t\t\t\t\tif ( _this.m_fnOnAJAXComplete )\n\t\t\t\t\t\t_this.m_fnOnAJAXComplete();\n\t\t\t\t}).fail( function() {\n\t\t\t\t\t_this.m_bAJAXFailed = true;\n\t\t\t\t});\n\t\t}, this.m_msDelayBeforeAJAX );\n\t}\n};\n\nCDelayedAJAXData.prototype.CancelAJAX = function()\n{\n\tif ( this.m_timerDelayedAJAX )\n\t\twindow.clearTimeout( this.m_timerDelayedAJAX );\n\n\tthis.m_fnOnAJAXComplete = null;\n};\n\nCDelayedAJAXData.prototype.RunWhenAJAXReady = function( fnOnReady )\n{\n\tif ( this.m_$Data )\n\t\tfnOnReady();\n\telse if ( !this.m_bAJAXFailed )\n\t{\n\t\tthis.m_fnOnAJAXComplete = fnOnReady;\n\t\tthis.QueueAjaxRequestIfNecessary();\n\t}\n\t// if ajax failed we will not call fnOnReady\n};\n\nCDelayedAJAXData.prototype.Show = function( $HoverContent )\n{\n\t$HoverContent.children().detach();\n\t$HoverContent.append( this.m_$Data );\n};\n\n// time the cookie preferences popup waits before appearing\nvar\tCOOKIE_PREFERENCES_POPUP_DELAY = 4000;\n\nfunction InitCookiePreferencesPopup()\n{\n\t\n\tvar $popupDialog = $J( '#cookiePrefPopup' );\n\tif ( $popupDialog.length == 0 )\n\t{\n\t\t$AllowURL = encodeURI( 'https://store.steampowered.com/' + 'account/ajaxsetcookiepreferences');\n\n\t\tvar $CPopupContent = $J( \"<style>\\n.replyButton {\\n\\twidth: 100%;\\n    text-align: center;\\n    margin-bottom: 4px;\\n}\\n\\n.buttonGroup {\\n\\tflex: 18%;\\n\\tmargin-left: 20px;\\n\\tmargin-right: 0px;\\n}\\n.cookieMessage {\\n\\tflex: 85%;\\n\\tmargin: auto;\\n}\\n.popupTextTitle {\\n\\tpadding-bottom: 10px;\\n    font-size: 13px;\\n    line-height: 17px;\\n    color: #c6d4df;\\n}\\n.popupTextTitle a {\\n    text-decoration: underline;\\n}\\n.cookiepreferences_popup {\\n\\tdisplay: none;\\n\\tposition: fixed;\\n\\tbottom: 0;\\n\\twidth: 100%;\\n\\tz-index: 2000;\\n\\tpadding-top: 10px;\\n}\\n.cookiepreferences_popup_content {\\n\\tdisplay: flex;\\n    box-sizing: border-box;\\n\\twidth: 90%;\\n\\tmargin: auto;\\n\\tmargin-bottom: 20px;\\n\\tpadding: 16px 16px 10px 16px;\\n    max-width: 980px;\\n\\tbackground: linear-gradient(90.85deg, #333840 0.58%, #25282E 74.92%);\\n\\tbox-shadow: 0px 0px 10px #000000;\\n    border-left: 2px solid #00CCFF;\\n}\\n@media all and (max-width: 910px) {\\n    body.responsive_page .cookiepreferences_popup_content {\\n        flex-direction: column;\\n    }\\n    body.responsive_page .cookiepreferences_popup_content .cookieMessage {\\n        margin-bottom: 20px;\\n    }\\n    body.responsive_page .cookiepreferences_popup_content .buttonGroup {\\n        flex-direction: row;\\n        margin-left: 0px;\\n    }\\n    body.responsive_page .cookiepreferences_popup_content .buttonGroup .replyButton {\\n        width: unset;\\n    }\\n}\\n<\\/style>\\n\\n<div id=\\\"cookiePrefPopup\\\" class=\\\"cookiepreferences_popup\\\">\\n\\t<div class=\\\"cookiepreferences_popup_content\\\">\\n\\t\\t<div class=\\\"cookieMessage\\\">\\n\\t\\t\\t<div class=\\\"popupTextTitle\\\">\\u0412\\u044b \\u043d\\u0435 \\u0432\\u043e\\u0437\\u0440\\u0430\\u0436\\u0430\\u0435\\u0442\\u0435, \\u0435\\u0441\\u043b\\u0438 \\u043c\\u044b \\u0431\\u0443\\u0434\\u0435\\u043c \\u0438\\u0441\\u043f\\u043e\\u043b\\u044c\\u0437\\u043e\\u0432\\u0430\\u0442\\u044c \\u0434\\u043e\\u043f\\u043e\\u043b\\u043d\\u0438\\u0442\\u0435\\u043b\\u044c\\u043d\\u044b\\u0435 \\u0444\\u0430\\u0439\\u043b\\u044b cookie, \\u0447\\u0442\\u043e\\u0431\\u044b \\u043f\\u043e\\u043a\\u0430\\u0437\\u044b\\u0432\\u0430\\u0442\\u044c \\u043f\\u043e\\u0434\\u043e\\u0431\\u0440\\u0430\\u043d\\u043d\\u044b\\u0439 \\u0434\\u043b\\u044f \\u0432\\u0430\\u0441 \\u043a\\u043e\\u043d\\u0442\\u0435\\u043d\\u0442 \\u0438 \\u0430\\u043d\\u0430\\u043b\\u0438\\u0437\\u0438\\u0440\\u043e\\u0432\\u0430\\u0442\\u044c \\u0442\\u0440\\u0430\\u0444\\u0438\\u043a \\u0441\\u0430\\u0439\\u0442\\u0430?<\\/div>\\n\\t\\t\\t<div class=\\\"popupTextTitle\\\">\\u041c\\u044b \\u043d\\u0435 \\u0438\\u0441\\u043f\\u043e\\u043b\\u044c\\u0437\\u0443\\u0435\\u043c \\u043c\\u043d\\u043e\\u0436\\u0435\\u0441\\u0442\\u0432\\u043e \\u0444\\u0430\\u0439\\u043b\\u043e\\u0432 cookie; \\u0432\\u044b \\u043c\\u043e\\u0436\\u0435\\u0442\\u0435 \\u0432 \\u043b\\u044e\\u0431\\u043e\\u0435 \\u0432\\u0440\\u0435\\u043c\\u044f \\u043f\\u0440\\u043e\\u0441\\u043c\\u043e\\u0442\\u0440\\u0435\\u0442\\u044c \\u0438 \\u0438\\u0437\\u043c\\u0435\\u043d\\u0438\\u0442\\u044c \\u0441\\u0432\\u043e\\u0439 \\u0432\\u044b\\u0431\\u043e\\u0440 \\u0432 <a href=\\\"https:\\/\\/store.steampowered.com\\/account\\/cookiepreferences\\\">\\u043d\\u0430\\u0441\\u0442\\u0440\\u043e\\u0439\\u043a\\u0430\\u0445 \\u0444\\u0430\\u0439\\u043b\\u043e\\u0432 cookie<\\/a>. \\u041d\\u0430\\u0436\\u0430\\u0432 \\u00ab\\u041f\\u0440\\u0438\\u043d\\u044f\\u0442\\u044c \\u0432\\u0441\\u0435\\u00bb, \\u0432\\u044b \\u0441\\u043e\\u0433\\u043b\\u0430\\u0448\\u0430\\u0435\\u0442\\u0435\\u0441\\u044c \\u0441 \\u0438\\u0441\\u043f\\u043e\\u043b\\u044c\\u0437\\u043e\\u0432\\u0430\\u043d\\u0438\\u0435\\u043c \\u0444\\u0430\\u0439\\u043b\\u043e\\u0432 cookie \\u043d\\u0430 \\u0441\\u0430\\u0439\\u0442\\u0430\\u0445 Steam. \\u041f\\u043e\\u0434\\u0440\\u043e\\u0431\\u043d\\u043e\\u0441\\u0442\\u0438 \\u043c\\u043e\\u0436\\u043d\\u043e \\u0443\\u0437\\u043d\\u0430\\u0442\\u044c \\u0432 \\u043d\\u0430\\u0448\\u0435\\u0439 <a href=\\\"https:\\/\\/store.steampowered.com\\/privacy_agreement\\\">\\u043f\\u043e\\u043b\\u0438\\u0442\\u0438\\u043a\\u0435 \\u043a\\u043e\\u043d\\u0444\\u0438\\u0434\\u0435\\u043d\\u0446\\u0438\\u0430\\u043b\\u044c\\u043d\\u043e\\u0441\\u0442\\u0438<\\/a>.<\\/div>\\n\\t\\t<\\/div>\\n\\t\\t<div class=\\\"buttonGroup\\\">\\n\\t\\t\\t<div id=\\\"acceptAllButton\\\" class=\\\"btn_blue_steamui btn_medium replyButton\\\"><span>\\u041f\\u0440\\u0438\\u043d\\u044f\\u0442\\u044c \\u0432\\u0441\\u0435<\\/span><\\/div>\\n\\t\\t\\t<div id=\\\"rejectAllButton\\\" class=\\\"btn_grey_steamui btn_medium replyButton\\\"><span>\\u041e\\u0442\\u043a\\u043b\\u043e\\u043d\\u0438\\u0442\\u044c \\u0432\\u0441\\u0435<\\/span><\\/div>\\n\\t\\t<\\/div>\\n\\t<\\/div>\\n<\\/div>\\n\" );\n\n\t\tvar $onAcceptButton = $CPopupContent.find( '#acceptAllButton' );\n\t\tvar $onRejectButton = $CPopupContent.find( '#rejectAllButton' );\n\n\t\tif ( $onAcceptButton.length == 0 || $onRejectButton.length == 0 )\n\t\t{\n\t\t\t// template appears broken\n\t\t\tconsole.error(\"unable to display preferences popup\");\n\t\t\treturn;\n\t\t}\n\n\t\tvar fnPostPreference = function ( bAllowChoice )\n\t\t{\n\t\t\t$J.ajax( { type: \"POST\",\n\t\t\t\t\t\turl: $AllowURL,\n\t\t\t\t\t\tdata: { bAllow: bAllowChoice, sessionid: g_sessionID },\n\t\t\t\t\t\tcrossDomain: true,\n\t\t\t\t\t\txhrFields: { withCredentials: true }\n\t\t\t} ).done( function ( data )\n\t\t\t{\n\t\t\t\tif ( data && data.transfer_urls && data.transfer_params )\n\t\t\t\t{\n\t\t\t\t\tfor ( var i = 0; i < data.transfer_urls.length; i++ )\n\t\t\t\t\t{\n\t\t\t\t\t\t$J.ajax( { type: \"POST\",\n\t\t\t\t\t\t\t\t\turl: data.transfer_urls[i],\n\t\t\t\t\t\t\t\t\tdata: { transfer_params: data.transfer_params },\n\t\t\t\t\t\t\t\t\tcrossDomain: true,\n\t\t\t\t\t\t\t\t\txhrFields: { withCredentials: true }\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t$J( '#cookiePrefPopup' ).hide();\n\n\t\t}\n\n\t\t$onAcceptButton.on('click', '', function() {\n\t\t\tfnPostPreference( 1 );\n\t\t} );\n\n\t\t$onRejectButton.on('click', '', function ()\n\t\t{\n\t\t\tfnPostPreference( 0 );\n\t\t} );\n\n\t\t$J('body').append( $CPopupContent );\n\n\t\ttimerCookiePopup = window.setTimeout( function() {\n\t\t\t$J(\"#cookiePrefPopup\").show();\n\t\t}, COOKIE_PREFERENCES_POPUP_DELAY );\n\t}\n}\n\n// The /miniprofile/ is cacheable. We need to specify the origin URL of the request to avoid CORS see cl 5773210\nfunction InitMiniprofileHovers( origin )\n{\n\tvar $Hover = $J('<div/>', {'class': 'miniprofile_hover'} );\n\tvar $HoverContent = $J('<div/>', {'class': 'miniprofile_hover_inner shadow_content'} );\n\n\t$Hover.append( $J('<div class=\"shadow_ul\"></div><div class=\"shadow_top\"></div><div class=\"shadow_ur\"></div><div class=\"shadow_left\"></div><div class=\"shadow_right\"></div><div class=\"shadow_bl\"></div><div class=\"shadow_bottom\"></div><div class=\"shadow_br\"></div>'), $HoverContent );\n\n\t$Hover.hide();\n\t$J(document.body).append( $Hover );\n\n\tvar fnDataFactory = function( key ) {\n    // key is either a number (accountid) or a string of \"accountid_appid\"\n\t\tvar rgKey = typeof key === \"string\" ? key.split( /_/ ) : [ key ];\n\t\tvar strURL = 'miniprofile/' + rgKey[0];\n\n\t\tif ( rgKey[1] )\n        {\n\t\t\tstrURL += '?appid=' + rgKey[1];\n\n\t\t\tif( origin )\n\t\t\t{\n\t\t\t\tstrURL += '&origin=' + origin;\n\t\t\t}\n        }\n\t\telse if( origin )\n\t\t{\n\t\t\tstrURL += '?origin=' + origin;\n\t\t}\n\n\t\treturn new CDelayedAJAXData( strURL, MINIPROFILE_DELAY_BEFORE_AJAX );\n\t};\n\n\tvar fnReadKey = function ( $Target ) {\n\t\tvar appid = $Target.parents('[data-miniprofile-appid]').first().data('miniprofile-appid');\n\t\tif( appid  )\n\t\t{\n\t\t\treturn $Target.data('miniprofile') + '_' + appid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn $Target.data('miniprofile')\n\t\t}\n\t};\n\n\tvar rgCallbacks = BindAJAXHovers( $Hover, $HoverContent, {\n\t\tfnDataFactory: fnDataFactory,\n\t\tfnPositionHover: PositionMiniprofileHover,\n\t\tfnReadKey: fnReadKey,\n\t\tstrDataName: 'miniprofile',\n\t\tstrURLMatch: 'miniprofile'\n\t}  );\n}\n\nfunction _RegisterAJAXHoverHideFunction( fnHide )\n{\n\tif ( typeof g_rgfnHideAJAXHover == 'undefined' )\n\t{\n\t\tg_rgfnHideAJAXHover = [];\n\t\t$J(window).blur( HideAJAXHovers );\n\t}\n\n\tg_rgfnHideAJAXHover.push( fnHide );\n}\n\nfunction HideAJAXHovers()\n{\n\tif ( typeof g_rgfnHideAJAXHover != 'undefined' )\n\t{\n\t\tfor ( var i = 0; i < g_rgfnHideAJAXHover.length; i++ )\n\t\t\tg_rgfnHideAJAXHover[i]();\n\t}\n}\n\nfunction BindAJAXHovers( $Hover, $HoverContent, oParams )\n{\n\tvar fnDataFactory = oParams.fnDataFactory;\n\tvar fnPositionHover = oParams.fnPositionHover || PositionMiniprofileHover;\n\tvar strDataName = oParams.strDataName;\n\tvar strURLMatch = oParams.strURLMatch;\n\tvar fnReadKey = function( $Element ) { return $Element.data( strDataName ); };\n\tif ( oParams.fnReadKey )\n\t\tfnReadKey = oParams.fnReadKey;\n\tvar strSelector = oParams.strSelector || '[data-' + strDataName + ']';\n\tvar nDelayBeforeShow = oParams.nDelayBeforeShow || MINIPROFILE_DELAY_BEFORE_SHOW;\n\n\t// indexed by accountid\n\tvar rgHoverData = {};\n\tvar HoverTarget = null;\n\tvar timerHover = null;\n\n\tvar fnOnHover = function( $Target, key ) {\n\n\t\tvar bHoverVisible = ( $Hover.css('display') != 'none' );\n\n\t\tvar HoverData = rgHoverData[key];\n\t\tif ( !HoverData )\n\t\t{\n\t\t\tHoverData = rgHoverData[key] = fnDataFactory( key );\n\t\t}\n\n\t\tif ( HoverTarget == HoverData && bHoverVisible )\n\t\t{\n\t\t\t//really only want to do this while fading out\n\t\t\t$Hover.stop();\n\t\t\tfnPositionHover( $Hover, $Target );\n\t\t\t$Hover.show();\t// PositionMiniprofile toggles visibility\n\t\t\t$Hover.fadeTo( MINIPROFILE_ANIM_SPEED, 1.0 );\n\t\t}\n\t\telse if ( !timerHover || HoverData != HoverTarget )\n\t\t{\n\t\t\t// this is the new target\n\t\t\tif ( HoverTarget && HoverTarget != HoverData )\n\t\t\t\tHoverTarget.CancelAJAX();\n\t\t\tHoverTarget = HoverData;\n\n\t\t\tif ( timerHover )\n\t\t\t{\n\t\t\t\twindow.clearTimeout( timerHover );\n\t\t\t\ttimerHover = null;\n\t\t\t}\n\n\t\t\tHoverData.QueueAjaxRequestIfNecessary();\n\n\t\t\ttimerHover = window.setTimeout( function() {\n\t\t\t\twindow.clearTimeout( timerHover );\n\t\t\t\ttimerHover = null;\n\n\t\t\t\tHoverData.RunWhenAJAXReady( function() {\n\t\t\t\t\tHoverData.Show( $HoverContent );\n\t\t\t\t\t$Hover.stop();\n\t\t\t\t\t$Hover.css( 'opacity', '' ); //clean up jquery animation\n\t\t\t\t\tfnPositionHover( $Hover, $Target );\n\t\t\t\t\t$Hover.fadeIn( MINIPROFILE_ANIM_SPEED );\n\t\t\t\t\tvar videoElem = $Hover.find( 'video' );\n\t\t\t\t\tif ( videoElem.length != 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar playPromise = videoElem[0].play();\n\t\t\t\t\t\tif ( playPromise )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tplayPromise.catch( function( e ) {\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}, nDelayBeforeShow );\n\t\t}\n\t};\n\n\tvar fnCancelHover = function( key )\n\t{\n\t\tvar bHoverVisible = ( $Hover.css('display') != 'none' );\n\n\t\tif ( key )\n\t\t{\n\t\t\tvar HoverData = rgHoverData[key];\n\t\t\tif ( HoverData )\n\t\t\t{\n\t\t\t\tHoverData.CancelAJAX();\n\t\t\t}\n\t\t}\n\n\t\tif ( timerHover )\n\t\t{\n\t\t\twindow.clearTimeout( timerHover );\n\t\t\ttimerHover = null;\n\t\t}\n\n\t\tif ( bHoverVisible )\n\t\t{\n\t\t\t$Hover.stop();\n\t\t\t$Hover.fadeOut( MINIPROFILE_ANIM_SPEED );\n\t\t}\n\t};\n\n\tvar strEventNamespace = 'AjaxHover' + strDataName;\n\t$J(document ).on( 'mouseenter.' + strEventNamespace + ' touchend.' + strEventNamespace, strSelector, function(e) {\n\t\tvar $Target = $J(this);\n\t\tfnOnHover( $Target, fnReadKey( $Target) );\n\n\t\t// Prevent click if we're sticky\n\t\tif ( typeof $Target.data('stickyhover') !== 'undefined' )\n\t\t{\n\t\t\te.preventDefault();\n\t\t}\n\t} );\n\t$J(document ).on( 'click.' + strEventNamespace + ' mouseleave.' + strEventNamespace, strSelector, function(e) {\n\t\tvar $Target = $J(this);\n\n\t\t// Cancel if we're not sticky\n\t\tif ( typeof $Target.data('stickyhover') == 'undefined' )\n\t\t{\n\t\t\tfnCancelHover();\n\t\t}\n\t} );\n\t// Cancel when clicking/touching elsewhere regardless if sticky\n\t$J(document ).on( 'click', null, fnCancelHover );\n\n\t// register this hover so HideAJAXHovers() can hide it when invoked\n\t_RegisterAJAXHoverHideFunction( fnCancelHover );\n\n\treturn {\n\t\tfnCancelHover: fnCancelHover\n\t};\n}\n\nfunction PositionMiniprofileHover( $Hover, $Target, oParams )\n{\n\tif ( !oParams )\n\t\toParams = {};\n\tvar bPreferRightSide = oParams.bPreferRightSide || false;\n\tvar nPxArrowOverlap = ( oParams.nPxArrowOverlap != undefined ) ? oParams.nPxArrowOverlap : 2;\n\n\t$Hover.css( 'visibility', 'hidden' );\n\t$Hover.show();\n\n\tvar offset = $Target.offset();\n\t$Hover.css( 'left', offset.left + 'px' );\n\t$Hover.css( 'top', offset.top + 'px');\n\n\tvar $HoverBox = $Hover.children( '.shadow_content' );\n\tif ( !$HoverBox.length )\n\t\t$HoverBox = $J( $Hover.children()[0] );\n\n\tvar $HoverArrowLeft = $Hover.children( '.hover_arrow.left' );\n\tvar $HoverArrowRight = $Hover.children( '.hover_arrow.right' );\n\n\tvar nWindowScrollTop = $J(window).scrollTop();\n\tvar nWindowScrollLeft = $J(window).scrollLeft();\n\tvar nViewportWidth = $J(window).width();\n\tvar nViewportHeight = $J(window).height();\n\n\t\tvar $HoverArrow = $HoverArrowRight;\n\tvar nBoxRightViewport = ( offset.left - nWindowScrollLeft ) + $Target.outerWidth() + $HoverBox.width() + 14;\n\tvar nSpaceRight = nViewportWidth - nBoxRightViewport;\n\tvar nSpaceLeft = offset.left - $Hover.width();\n\tif ( ( ( nSpaceLeft > 0 || nSpaceLeft > nSpaceRight ) && !bPreferRightSide ) || ( bPreferRightSide && nSpaceRight < 14 && nSpaceLeft > nSpaceRight ) )\n\t{\n\t\t\t\t$Hover.css( 'left', ( offset.left - $Hover.width() + nPxArrowOverlap + 3 ) + 'px' );\n\t\t$HoverArrowLeft.hide();\n\t\t$HoverArrowRight.show();\n\t}\n\telse\n\t{\n\t\t\t\t$Hover.css( 'left', ( offset.left + $Target.outerWidth() - nPxArrowOverlap ) + 'px' );\n\t\t$HoverArrow = $HoverArrowLeft;\n\t\t$HoverArrowLeft.show();\n\t\t$HoverArrowRight.hide();\n\t}\n\n\tvar nTopAdjustment = 0;\n\n\t\t\tif ( $Target.height() < 48 )\n\t\tnTopAdjustment = Math.floor( $Target.height() / 2 ) - 24;\n\tvar nDesiredHoverTop = offset.top - 15 + nTopAdjustment;\n\t$Hover.css( 'top', nDesiredHoverTop + 'px' );\n\n\t// see if the hover is cut off by the bottom of the window, and bump it up if neccessary\n\tvar nTargetTopViewport = ( offset.top - nWindowScrollTop ) + nTopAdjustment;\n\tif ( nTargetTopViewport + $HoverBox.height() + 35 > nViewportHeight )\n\t{\n\t\tvar nViewportAdjustment = ( $HoverBox.height() + 35 ) - ( nViewportHeight - nTargetTopViewport );\n\n\t\t// if the hover has the \"in-game\" block at the bottom, we need to have more space at the bottom of the hover\n\t\t//\tso that the arrow will appear in the blue part of the hover.  This means the game info may be off-screen below.\n\t\tvar bHaveInGameInfo = $HoverBox.find('.miniprofile_ingame').length > 0;\n\t\tvar nHoverBoxBottomMinimum = ( bHaveInGameInfo ? 78 : 24 );\t// the minimum amount of space we need below the arrow\n\t\tnViewportAdjustment = Math.min( $HoverBox.height() - nHoverBoxBottomMinimum, nViewportAdjustment );\n\n\t\tvar nViewportAdjustedHoverTop = offset.top - nViewportAdjustment;\n\t\t$Hover.css( 'top', nViewportAdjustedHoverTop + 'px' );\n\n\t\t// arrow is normally offset 30pixels.  we move it down the same distance we moved the hover up, so it is \"fixed\" to where it was initially\n\t\t$HoverArrow.css( 'top', ( 30 + nDesiredHoverTop - nViewportAdjustedHoverTop ) + 'px' );\n\t}\n\telse\n\t{\n\t\t$HoverArrow.css( 'top', '' );\n\t}\n\n\t$Hover.hide();\n\t$Hover.css( 'visibility', '' );\n}\n\n\n/* Emoticon hovers */\n\nfunction CEmoticonDelayedAJAXData( strEmoticonName, msDelayBeforeAJAX )\n{\n\tCDelayedAJAXData.apply( this, [ 'economy/emoticonhover/' + strEmoticonName + '/jsonp.js', msDelayBeforeAJAX ]);\n\tthis.m_strEmoticonName = strEmoticonName;\n}\n\n// subclass CDelayedAJAXData so we can request via JSONP\nCEmoticonDelayedAJAXData.prototype = new CDelayedAJAXData;\nCEmoticonDelayedAJAXData.prototype.constructor = CEmoticonDelayedAJAXData;\n\nCEmoticonDelayedAJAXData.prototype.GetAJAXParams = function()\n{\n\treturn {\n\t\turl: 'https://community.cloudflare.steamstatic.com/' + this.m_strURL,\n\t\tdataType: 'jsonp',\n\t\tjsonpCallback: 'OnLoadEmoticon_' + this.m_strEmoticonName,\t//consistent name for cachability\n\t\tcache: true,\n\t\tdata: {l: 'russian' }\n\t}\n};\n\nfunction InitEmoticonHovers()\n{\n\tvar $Hover = $J('<div/>', {'class': 'emoticon_hover'} );\n\tvar $HoverContent = $J('<div/>', {'class': 'emoticon_hover_content'} );\n\t$Hover.append( $HoverContent, $J('<div/>', {'class': 'hover_arrow left emoticon_hover_arrow' } ), $J('<div/>', {'class': 'hover_arrow right emoticon_hover_arrow' } ) );\n\t$Hover.hide();\n\n\tvar fnOneTimeEmoticonSetup = function() {\n\t\t$J(document.body).append( $Hover );\n\t};\n\n\tvar fnReadKey = function ( $Element ) {\n\t\tif ( $Element.data('emoticon') )\n\t\t{\n\t\t\treturn $Element.data('emoticon');\n\t\t}\n\t\telse if ( $Element.attr( 'src' ) )\n\t\t{\n\t\t\tvar rgMatches = $Element.attr( 'src' ).match( 'emoticon/(.*)$' );\n\t\t\tif ( rgMatches && rgMatches[1] )\n\t\t\t{\n\t\t\t\tvar strEmoticon = rgMatches[1];\n\t\t\t\tif ( strEmoticon.length > 1 )\n\t\t\t\t{\n\t\t\t\t\tif ( strEmoticon[0] == ':' )\n\t\t\t\t\t\tstrEmoticon = strEmoticon.substr( 1 );\n\t\t\t\t\tif ( strEmoticon[ strEmoticon.length - 1 ] == ':' )\n\t\t\t\t\t\tstrEmoticon = strEmoticon.substr( 0, strEmoticon.length - 1 );\n\t\t\t\t}\n\t\t\t\treturn strEmoticon;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tvar fnDataFactory = function( key )\t{\n\t\tif ( fnOneTimeEmoticonSetup )\n\t\t{\n\t\t\tfnOneTimeEmoticonSetup();\n\t\t\tfnOneTimeEmoticonSetup = null;\n\t\t}\n\n\t\treturn new CEmoticonDelayedAJAXData( key, 50 );\n\t};\n\n\tvar rgCallbacks = BindAJAXHovers( $Hover, $HoverContent, {\n\t\tfnDataFactory: fnDataFactory,\n\t\tfnPositionHover: function( $Hover, $Target ) {\n\t\t\tPositionMiniprofileHover( $Hover, $Target, {\n\t\t\t\tbPreferRightSide: true,\n\t\t\t\tnPxArrowOverlap: 0\n\t\t\t} );\n\t\t\t//slide it down a little for emoticon option popup\n\t\t\tif ( $Target.hasClass('emoticon_option') )\n\t\t\t\t$Hover.css( 'top', parseInt( $Hover.css('top') ) + 5 );\n\t\t},\n\t\tfnReadKey: fnReadKey,\n\t\tstrSelector: 'img.emoticon',\n\t\tstrURLMatch: 'emoticonhover',\n\t\tnDelayBeforeShow: 50\n\t} );\n\n\twindow.DismissEmoticonHover = rgCallbacks.fnCancelHover;\n}\n\nfunction V_EscapeRegExp( str )\n{\n\treturn str.replace( /[.*+?^${}()|[\\]\\\\]/g, '\\\\$&' );\n}\n\nfunction V_EscapeHTML( str )\n{\n\treturn String(str).replace( /&/g, '&amp;' ).replace( /[\"]/g, '&quot;' ).replace( /[']/g, '&#39;' ).replace( /</g, '&lt;').replace( />/g, '&gt;');\n}\n\nfunction v_trim( str )\n{\n\tif ( str.trim )\n\t\treturn str.trim();\n\telse\n\t{\n\t\treturn str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n\t}\n}\n\nfunction V_ParseJSON( str )\n{\n\tif ( typeof JSON == 'object' && JSON.parse )\n\t\treturn JSON.parse( str );\t// built-in / json2.js\n\telse\n\t\tstr.evalJSON();\t\t\t\t// prototype\n}\n\nfunction V_ToJSON( object )\n{\n\tif ( typeof JSON == 'object' && JSON.stringify )\n\t\treturn JSON.stringify( object );\t// built-in / json2.js\n\telse\n\t\tObject.toJSON( object );\t\t\t\t// prototype\n}\n\nfunction V_IsJSON( str )\n{\n\ttry\n\t{\n\t\tif( typeof JSON == 'object' && JSON.parse )\n\t\t{\n\t\t\tvar o = JSON.parse(str);\n\t\t\tif ( o !== null )\n\t\t\t\treturn true;\n\n\t\t} else {\n\t\t\treturn str.isJSON();\n\t\t}\n\t}\n\tcatch (e) { }\n\treturn false;\n}\n\n\nfunction V_GetCookie( strCookieName )\n{\n\tvar rgMatches = document.cookie.match( '(^|; )' + strCookieName + '=([^;]*)' );\n\tif ( rgMatches && rgMatches[2] )\n\t\treturn rgMatches[2];\n\telse\n\t\treturn null;\n}\n\n\nfunction V_GetDecodedCookie( strCookieName )\n{\n\tvar value = V_GetCookie( strCookieName );\n\treturn value && decodeURIComponent( value );\n}\n\nfunction V_SetCookie( strCookieName, strValue, expiryInDays, path )\n{\n\tif ( !path )\n\t\tpath = '/';\n\n\tvar strDate = '';\n\n\tif( typeof expiryInDays != 'undefined' && expiryInDays )\n\t{\n\t\tvar dateExpires = new Date();\n\t\tdateExpires.setTime( dateExpires.getTime() + 1000 * 60 * 60 * 24 * expiryInDays );\n\t\tstrDate = '; expires=' + dateExpires.toGMTString();\n\t}\n\n\tdocument.cookie = strCookieName + '=' + strValue + strDate + ';path=' + path;\n}\n\nfunction _GetStorageFromCookie()\n{\n\tvar oStorage = {};\n\n\tvar strStorageJSON = V_GetCookie( 'storage' );\n\tif ( strStorageJSON )\n\t{\n\t\ttry {\n\t\t\toStorage = V_ParseJSON(decodeURIComponent(strStorageJSON));\n\t\t}\n\t\tcatch (e) {\n\t\t\toStorage = {};\n\t\t}\n\t}\n\n\treturn oStorage;\n}\n\nfunction BInsideIFrame()\n{\n\ttry\n\t{\n\t\treturn window.self !== window.top;\n\t}\n\tcatch( e )\n\t{\n\t\treturn true;\n\t}\n}\n\nfunction SetValueLocalStorage( strPreferenceName, value )\n{\n\tif ( !BInsideIFrame() && window.localStorage )\n\t{\n\t\twindow.localStorage[strPreferenceName] = value;\n\t}\n\telse\n\t{\n\t\tvar oStorage = _GetStorageFromCookie();\n\n\t\toStorage[strPreferenceName] = value;\n\n\t\tV_SetCookie( 'storage', encodeURIComponent( V_ToJSON( oStorage ) ), 365 )\n\t}\n}\n\nfunction UnsetValueLocalStorage( strPreferenceName )\n{\n\tif ( !BInsideIFrame() && window.localStorage )\n\t{\n\t\tdelete window.localStorage[strPreferenceName];\n\t}\n\telse\n\t{\n\t\tvar oStorage = _GetStorageFromCookie();\n\n\t\tdelete oStorage[strPreferenceName];\n\n\t\tV_SetCookie( 'storage', encodeURIComponent( V_ToJSON( oStorage ) ), 365 )\n\t}\n}\n\nfunction GetValueLocalStorage( strPreferenceName, defaultValue )\n{\n\tif ( !BInsideIFrame() && window.localStorage )\n\t{\n\t\treturn window.localStorage[strPreferenceName] || defaultValue;\n\t}\n\telse\n\t{\n\t\tvar oStorage = _GetStorageFromCookie();\n\n\t\treturn oStorage[strPreferenceName] || defaultValue;\n\t}\n}\n\nfunction DynamicLink_PlayYouTubeVideoInline( elem, videoid )\n{\n\tvar el = $J(elem);\n\tvar youtubeurl = location.protocol + '//www.youtube.com/embed/' + videoid + '?showinfo=0&autohide=1&fs=1&hd=1&modestbranding=1&rel=0&showsearch=0&wmode=direct&autoplay=1';\n\tvar wrapper = $J( '<div/>', { 'class': 'dynamiclink_youtubeviewvideo' } );\n\tvar embed_wrapper = $J( '<div/>', { 'class' : 'dynamiclink_youtubeviewvideoembedded', 'frameborder' : '0' } );\n\tvar iframeContent = $J( '<iframe/>', { 'frameborder' : '0', src: youtubeurl, 'allowfullscreen': '' } );\n\tif ( el.length )\n\t{\n\t\tembed_wrapper.append( iframeContent );\n\t\twrapper.append( embed_wrapper );\n\t\tel.after( wrapper );\n\t\tel.remove();\n\t}\n}\n\nfunction DynamicLink_PlayVimeoVideoInline( elem, videoid )\n{\n\tvar el = $J(elem);\n\tvar videourl = 'https://player.vimeo.com/video/' + videoid + '?badge=0&autopause=0&autoplay=1&player_id=0';\n\tvar wrapper = $J( '<div/>', { 'class': 'dynamiclink_youtubeviewvideo' } );\n\tvar embed_wrapper = $J( '<div/>', { 'class' : 'dynamiclink_youtubeviewvideoembedded', 'frameborder' : '0' } );\n\tvar iframeContent = $J( '<iframe/>', { 'frameborder' : '0', src: videourl, webkitallowfullscreen : '', mozallowfullscreen : '', allowfullscreen : '' } );\n\tif ( el.length )\n\t{\n\t\tembed_wrapper.append( iframeContent );\n\t\twrapper.append( embed_wrapper );\n\t\tel.after( wrapper );\n\t\tel.remove();\n\t}\n}\n\nfunction DynamicLink_ShowSketchfabModelInline( elem, details )\n{\n\tvar url = \"https://sketchfab.com/models/\" + details.modelid + \"/embed?autostart=1\";\n\tvar el = $J(elem);\n\tvar wrapper = $J( '<div/>', { 'class' : 'dynamiclink_sketchfabmodelembedded', 'frameborder' : '0' } );\n\tvar iframeContent = $J( '<iframe/>', { 'frameborder' : '0', \"mozallowfullscreen\" : true, \"webkitallowfullscreen\" : true, src: url } );\n\tif ( el.length )\n\t{\n\t\twrapper.append( iframeContent );\n\t\tel.after( wrapper );\n\t\tel.remove();\n\t}\n}\n\nfunction ReplaceDynamicLink( id, strHTML )\n{\n\tvar el = $J('#'+id);\n\tif ( el.length && strHTML.length > 0 )\n\t{\n\t\tvar newEl = $J( strHTML );\n\t\tel.after( newEl );\n\t\tel.remove();\n\n\t\tif ( typeof window['HandleNewDynamicLink'] === \"function\" )\n\t\t{\n\t\t\tHandleNewDynamicLink( newEl );\n\t\t}\n\t}\n}\n\nfunction ShowBannedDynamicLink( el )\n{\n\tel = $J( el );\n\tif ( el.length > 0 )\n\t{\n\t\tvar bannedContentURL = el.data( 'bannedurl' );\n\t\tvar link = $J( \"<a>\", { href: bannedContentURL, text: bannedContentURL } );\n\t\tel.html( link );\n\t\tel.attr( 'onclick', '' );\n\t}\n}\n\n\n\nfunction CScrollOffsetWatcher( el, fnCallback )\n{\n\tthis.m_$Element = $J(el);\n\tthis.nOffsetTop = this.m_$Element.offset().top;\n\tthis.nBufferHeight = 500;\n\n\tthis.nOffsetTopTrigger = this.nOffsetTop - this.nBufferHeight;\n\n\tthis.fnOnHit = fnCallback;\n\n\tCScrollOffsetWatcher.RegisterWatcher( this );\n}\n\nCScrollOffsetWatcher.prototype.SetBufferHeight = function( nHeight )\n{\n\tthis.nBufferHeight = nHeight;\n\tthis.Recalc();\n};\n\nCScrollOffsetWatcher.prototype.Recalc = function()\n{\n\tthis.nOffsetTop = this.m_$Element.offset().top;\n\tthis.nOffsetTopTrigger = this.nOffsetTop - this.nBufferHeight;\n};\n\nCScrollOffsetWatcher.sm_rgWatchers = [];\nCScrollOffsetWatcher.m_nTimeoutInitialLoad = 0;\nCScrollOffsetWatcher.RegisterWatcher = function( Watcher )\n{\n\tvar bHadWatchers = CScrollOffsetWatcher.sm_rgWatchers.length > 0;\n\n\t// keep the list sorted by offset trigger\n\tvar iInsertionPoint;\n\tfor( iInsertionPoint = CScrollOffsetWatcher.sm_rgWatchers.length; iInsertionPoint > 0 ; iInsertionPoint-- )\n\t{\n\t\tif ( Watcher.nOffsetTopTrigger > CScrollOffsetWatcher.sm_rgWatchers[iInsertionPoint - 1].nOffsetTopTrigger )\n\t\t\tbreak;\n\t}\n\tCScrollOffsetWatcher.sm_rgWatchers.splice( iInsertionPoint, 0, Watcher );\n\n\tif ( !bHadWatchers )\n\t{\n\t\t$J(window).on( 'scroll.ScrollOffsetWatcher', CScrollOffsetWatcher.OnScroll );\n\n\t\tvar nRecalcTimer = 0;\n\t\t$J(window).on( 'resize.ScrollOffsetWatcher', function() {\n\t\t\tif ( nRecalcTimer )\n\t\t\t\twindow.clearTimeout( nRecalcTimer );\n\t\t\tnRecalcTimer = window.setTimeout( CScrollOffsetWatcher.ForceRecalc, 500 );\n\t\t} );\n\t}\n\n\t// use a 1ms timeout to roll these together as much as possible on page load\n\tif ( !CScrollOffsetWatcher.m_nTimeoutInitialLoad )\n\t\tCScrollOffsetWatcher.m_nTimeoutInitialLoad = window.setTimeout( function() { CScrollOffsetWatcher.OnScroll(); CScrollOffsetWatcher.m_nTimeoutInitialLoad = 0; }, 1 );\n};\n\nCScrollOffsetWatcher.ForceRecalc = function()\n{\n\tfor ( var i = 0; i < CScrollOffsetWatcher.sm_rgWatchers.length; i++ )\n\t{\n\t\tCScrollOffsetWatcher.sm_rgWatchers[i].Recalc();\n\t}\n\n\tCScrollOffsetWatcher.OnScroll();\n};\n\nCScrollOffsetWatcher.OnScroll = function()\n{\n\tvar supportPageOffset = window.pageYOffset !== undefined;\n\tvar isCSS1Compat = ((document.compatMode || \"\") === \"CSS1Compat\");\n\n\tvar nScrollY = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;\n\tvar nOffsetBottom = nScrollY + window.innerHeight;\n\n\tfor( let i = CScrollOffsetWatcher.sm_rgWatchers.length - 1; i >= 0; i-- )\n\t{\n\t\tvar Watcher = CScrollOffsetWatcher.sm_rgWatchers[i];\n\t\tif ( nOffsetBottom > Watcher.nOffsetTopTrigger )\n\t\t{\n\t\t\t// make sure the page hasn't changed and we really need to show content\n\t\t\tWatcher.Recalc();\n\t\t\tif ( nOffsetBottom > Watcher.nOffsetTopTrigger )\n\t\t\t{\n\t\t\t\tWatcher.fnOnHit();\n\t\t\t\tCScrollOffsetWatcher.sm_rgWatchers.splice( i, 1 );\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( CScrollOffsetWatcher.sm_rgWatchers.length === 0 )\n\t{\n\t\t$J(window).off( 'scroll.ScrollOffsetWatcher' );\n\t\t$J(window).off( 'resize.ScrollOffsetWatcher' );\n\t}\n};\n\nfunction LoadImageGroupOnScroll( elTarget, strGroup )\n{\n\tvar $Element = $J( '#' + elTarget );\n\tif ( $Element.length )\n\t\tnew CScrollOffsetWatcher( $Element, function() { LoadDelayedImages(strGroup); } );\n}\n\nfunction LoadDelayedImages( group )\n{\n\tif ( typeof g_rgDelayedLoadImages != 'undefined' && g_rgDelayedLoadImages[group] )\n\t{\n\t\tvar rgURLs = g_rgDelayedLoadImages[group];\n\t\tfor ( var i=0; i < rgURLs.length; i++ )\n\t\t{\n\t\t\t$J('#delayedimage_' + group + '_' + i).attr( 'src', rgURLs[i] );\n\t\t}\n\n\t\tg_rgDelayedLoadImages[group] = false;\n\t}\n}\n\nWebStorage = {\n\tGetLocal: function ( key, bSessionOnly )\n\t{\n\t\tvar type = ( bSessionOnly ) ? 'session' : 'local';\n\n\t\tif ( !window[type + 'Storage'] )\n\t\t\treturn WebStorage.GetCookie( key );\n\n\t\tvar storage = window[type + 'Storage'];\n\t\tvar value;\n\t\ttry {\n\t\t\tvalue = storage.getItem(key);\n\t\t} catch(err) {\n\t\t\t// storage.getItem can throw SecurityError based on user's browser setting.\n\t\t\tvalue = null;\n\t\t}\n\n\t\ttry {\n\t\t\tvalue = V_ParseJSON( value );\n\t\t} catch(err){\n\t\t\treturn null;\n\t\t}\n\n\t\tif( value == null )\n\t\t{\n\t\t\t// Check if we have the value stored in a cookie instead. If so, move that to LS and remove the cookie\n\t\t\tvalue = V_GetCookie( key );\n\t\t\tif( value != null )\n\t\t\t{\n\t\t\t\tWebStorage.SetLocal( key, value, bSessionOnly );\n\t\t\t\tWebStorage.ClearCookie( key );\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t},\n\tGetLocalSession: function( key )\n\t{\n\t\treturn WebStorage.GetLocal( key, true );\n\t},\n\tSetLocal: function ( key, value, bSessionOnly )\n\t{\n\t\tvar type = ( bSessionOnly ) ? 'session' : 'local';\n\n\t\tif ( !window[type + 'Storage'] )\n\t\t\treturn WebStorage.SetCookie( key, value, ( bSessionOnly ) ? null : 365 );\n\n\t\tvalue = V_ToJSON( value );\n\n\t\tvar storage = window[type + 'Storage'];\n\t\tstorage.setItem( key, value );\n\t},\n\tSetLocalSession: function( key, value )\n\t{\n\t\tWebStorage.SetLocal( key, value, true );\n\t},\n\tGetCookie: function( key )\n\t{\n\t\tvar keyValue = V_GetCookie( key );\n\t\tif ( keyValue )\n\t\t\tkeyValue = decodeURIComponent( keyValue );\n\n\t\treturn V_IsJSON( keyValue ) ? V_ParseJSON( keyValue ) : keyValue;\n\t},\n\tSetCookie: function( key, value, duration )\n\t{\n\t\tvalue = encodeURIComponent( V_ToJSON( value ) );\n\t\tV_SetCookie( key, value, duration );\n\t},\n\tClearCookie: function( key )\n\t{\n\t\tWebStorage.SetCookie(key, null, -1 );\n\t},\n\tRemoveLocal : function ( key, bSessionOnly )\n\t{\n\t\tvar type = ( bSessionOnly ) ? 'session' : 'local';\n\n\t\tif ( !window[type + 'Storage'] )\n\t\t\treturn WebStorage.ClearCookie( key );\n\n\t\tvar storage = window[type + 'Storage'];\n\n\t\tstorage.removeItem( key );\n\t}\n};\n\n// takes an integer\nfunction v_numberformat( n, decimals, strDecimalSymbol, strThousandsSeperator )\n{\n\tif ( typeof strDecimalSymbol == 'undefined' && typeof strThousandsSeperator == 'undefined' && typeof Number != 'undefined' && typeof Number.toLocaleString != 'undefined' )\n\t{\n\t\tvar options = {};\n\t\tif ( typeof decimals != 'undefined' && decimals !== 0 )\n\t\t{\n\t\t\toptions.minimumFractionDigits = decimals;\n\t\t\toptions.maximumFractionDigits = decimals;\n\t\t}\n\n\t\tvar num = new Number(n);\n\t\ttry\n\t\t{\n\t\t\treturn num.toLocaleString( false, options );\n\t\t}\n\t\tcatch( e )\n\t\t{\n\t\t\treturn num.toString();\n\t\t}\n\t}\n\n\tvar str = '' + ( n ? n : 0 );\n\tvar len = str.indexOf( '.' );\n\tif ( len == -1 )\n\t\tlen = str.length;\n\tvar out = '';\n\tfor ( var i = 0; i < len; i++ )\n\t{\n\t\tvar c = str.charAt(i);\n\t\tout += c;\n\t\tif ( i < len - 1 && (len - i - 1) % 3 == 0 && c != '-' )\n\t\t\tout += ( typeof strThousandsSeperator == 'undefined' ? ',' : strThousandsSeperator );\n\t}\n\tif ( ( len < str.length || decimals ) && typeof decimals != 'undefined' && decimals !== 0 )\n\t{\n\t\tlen++;\n\t\tout += ( typeof strDecimalSymbol == 'undefined' ? ',' : strDecimalSymbol );\n\t\tfor ( var i = 0; i < ( decimals ? decimals : str.length - len ); i++ )\n\t\t{\n\t\t\tif ( len + i < str.length )\n\t\t\t\tout += str.charAt( len + i );\n\t\t\telse\n\t\t\t\tout += '0';\n\t\t}\n\t}\n\n\treturn out;\n}\n\n\nfunction v_shuffle( rgArray )\n{\n\tfor ( var i = 0; i < rgArray.length; i++ )\n\t{\n\t\tvar iSwap = Math.floor( Math.random() * ( rgArray.length - i ) + i );\n\t\tif ( iSwap != i )\n\t\t{\n\t\t\tvar temp = rgArray[iSwap];\n\t\t\trgArray[iSwap] = rgArray[i];\n\t\t\trgArray[i] = temp;\n\t\t}\n\t}\n\n\treturn rgArray;\n}\n\n\nfunction UpdateFormattedNumber( element, delta )\n{\n\tvar $Element = $J(element);\n\t$Element.text( v_numberformat( parseInt( $Element.text().replace( /,/, '' ) ) + delta ) );\n}\n\nfunction RateAnnouncement( rateURL, gid, bVoteUp, clanID )\n{\n\tif ( bVoteUp && $J('#VoteUpBtn_' + gid).hasClass( \"btn_active\" ) )\n\t{\n\t\treturn;\n\t}\n\tif ( !bVoteUp && $J('#VoteDownBtn_' + gid).hasClass( \"btn_active\" ) )\n\t{\n\t\treturn;\n\t}\n\n\trateURL = rateURL + gid;\n\t$J.post( rateURL, {\n\t\t\t'voteup' : bVoteUp,\n\t\t\t'clanid' : clanID,\n\t\t\t'sessionid' : g_sessionID\n\t\t}\n\t).done( function( json ) {\n\n\t\tvar votesUpCount = $J('#VotesUpCount_' + gid);\n\t\tif ( votesUpCount )\n\t\t{\n\t\t\tvar increment = 0;\n\t\t\tif ( bVoteUp )\n\t\t\t{\n\t\t\t\tincrement = 1;\n\t\t\t}\n\t\t\telse if ( $J('#VoteUpBtn_' + gid).hasClass( 'btn_active' ) )\n\t\t\t{\n\t\t\t\tincrement = -1;\n\t\t\t}\n\t\t\tUpdateFormattedNumber( votesUpCount, increment );\n\n\t\t\tif ( parseInt( votesUpCount.html().replace(/,/g, '') ) == 0 )\n\t\t\t{\n\t\t\t\t$J('#VotesUpCountContainer_' + gid).hide();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$J('#VotesUpCountContainer_' + gid).show();\n\t\t\t}\n\t\t}\n\n\t\tif ( bVoteUp )\n\t\t{\n\t\t\t$J('#VoteUpBtn_' + gid).addClass( \"btn_active\" );\n\t\t\t$J('#VoteDownBtn_' + gid).removeClass( \"btn_active\" );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$J('#VoteDownBtn_' + gid).addClass( \"btn_active\" );\n\t\t\t$J('#VoteUpBtn_' + gid).removeClass( \"btn_active\" );\n\t\t}\n\n\n\n\t} )\n\t.fail( function( jqxhr ) {\n\t\tvar responseJSON = jqxhr.responseText.evalJSON();\n\t\tswitch ( responseJSON.success )\n\t\t{\n\t\t\tcase 21:\n\t\t\t\tShowAlertDialog( 'Ошибка', 'Чтобы выполнить это действие, войдите в аккаунт.' );\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\tShowAlertDialog( 'Ошибка',\n\t\t\t\t\t'Ваш аккаунт не отвечает необходимым требованиям для использования этой функции. Подробности на сайте <a class=\"whiteLink\" href=\"https://help.steampowered.com/ru/wizard/HelpWithLimitedAccount\" target=\"_blank\" rel=\"noreferrer\">службы поддержки Steam</a>.'\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 15:\n\t\t\t\tShowAlertDialog( 'Ошибка', 'У вас нет прав на это действие.' );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tShowAlertDialog( 'Ошибка', 'Произошла ошибка во время обработки вашего запроса:' + responseJSON.success );\n\t\t\t\tbreak;\n\t\t}\n\t} );\n\treturn false;\n}\n\nfunction GetResponsiveHeaderFixedOffsetAdjustment()\n{\n\t// for responsive pages - we need to adjust for the menu\n\tvar $ResponsiveHeader = $J('.responsive_header:visible');\n\tif ( $ResponsiveHeader.length && $ResponsiveHeader.css('position') == 'fixed' )\n\t\treturn $ResponsiveHeader.outerHeight();\n\telse\n\t\treturn 0;\n}\n\n/* Scroll to an element if it's not already in view.  If it's at the bottom of the viewport, then it will be\n scrolled to the top if less than nRequiredPixelsToShow are visible (defaults to the height of the element)\n */\nfunction ScrollToIfNotInView( elem, nRequiredPixelsToShow, nSpacingBefore, nAnimationSpeed )\n{\n\tvar $Elem = $JFromIDOrElement(elem);\n\n\tif ( typeof nSpacingBefore == 'undefined' )\n\t\tnSpacingBefore = 0;\n\n\t// for responsive pages - we need to adjust for the menu\n\tnSpacingBefore += GetResponsiveHeaderFixedOffsetAdjustment();\n\n\tvar elemTop = $Elem.offset().top;\n\tvar nViewportOffsetTop = elemTop - $J(window).scrollTop();\n\tvar bNeedToScroll = false;\n\tif ( nViewportOffsetTop < 0 )\n\t{\n\t\tbNeedToScroll = true;\n\t}\n\telse\n\t{\n\t\tif ( !nRequiredPixelsToShow )\n\t\t\tnRequiredPixelsToShow = $Elem.outerHeight();\n\n\t\tvar nViewportOffsetBottom = nViewportOffsetTop + nRequiredPixelsToShow;\n\n\t\tif ( nViewportOffsetBottom > $J(window).height() )\n\t\t\tbNeedToScroll = true;\n\t}\n\n\tif ( bNeedToScroll )\n\t{\n\t\tif ( nSpacingBefore )\n\t\t\tnViewportOffsetTop -= nSpacingBefore;\n\n\t\tif ( typeof nAnimationSpeed != 'undefined' )\n\t\t\t$J('html, body' ).animate( {scrollTop: nViewportOffsetTop}, nAnimationSpeed );\n\t\telse\n\t\t\twindow.scrollBy( 0, nViewportOffsetTop );\n\t}\n}\n\n\nfunction CAjaxInfiniteScrollingControls( rgSearchData, url )\n{\n\tthis.m_strActionURL = null;\n\tthis.m_cPageSize = null;\n\tthis.m_strElementPrefix = \"\";\n\tthis.m_strClassPrefix = \"\";\n\tthis.m_StrRowsId = \"\";\n\tthis.m_rgStaticParams = null;\n\n\tthis.m_bLoading = false;\n\n\tthis.m_fnPreRequestHandler = null;\n\tthis.m_fnResponseHandler = null;\n\tthis.m_fnPageChangingHandler = null;\n\tthis.m_fnPageChangedHandler = null;\n\tthis.m_fnRawScrollHandler = null;\n\n\tthis.m_LoadingDialog = null;\n\tthis.m_bRestoringScrollTop = false;\n\n\tthis.m_strActionURL = url;\n\n\tthis.m_strQuery = rgSearchData['query'];\n\tthis.m_cTotalCount = rgSearchData['total_count'];\n\tthis.m_iCurrentPage = rgSearchData['page'] || 0;\n\tthis.m_cPageSize = rgSearchData['pagesize'];\n\tthis.m_cMaxPages = Math.ceil( this.m_cTotalCount / this.m_cPageSize );\n\n\tthis.m_iTriggerHeight = rgSearchData['trigger_height'] || 750;\t// How many px from the bottom should we trigger a page load.\n\n\tthis.m_iCooldownTime = 0;       // ms from the epoch when we can next update.\n\tthis.m_iCooldownInterval = 200; // Minimum time (in ms) between updates\n\n\tif ( rgSearchData['prefix'] )\n\t\tthis.m_strElementPrefix = rgSearchData['prefix'];\n\n\t// Rows element name that's updated when we scroll.\n\tthis.m_StrRowsId = this.m_strElementPrefix + 'Rows';\n\n\tif ( rgSearchData['class_prefix'] )\n\t\tthis.m_strClassPrefix = rgSearchData['class_prefix'];\n\n\t// We want our handlers to get a copy of our infiniteScroll object when they're called, so we save it\n\t// into a var and build a closure around it.\n\tvar thisControl = this;\n\n\t// By saving the bound scroll-handler to a variable, we can then unload it when our search\n\t// options are upadated.\n\tthis.m_fnRawScrollHandler = function() { thisControl.OnScroll() };\n\t$J(document).scroll( this.m_fnRawScrollHandler );\n\n\t// If we have a _scroll_top element, then set our OnUnload handler.\n\tif ( $J( \"#\" + this.m_strElementPrefix + '_scroll_top').length )\n\t\twindow.addEventListener('beforeunload', function() { thisControl.OnUnload() } );\n\n\t// Optional: Dynamic data returned from the last request, to provided to the next request. Lets them\n\t// being stringed together with some memory\n\tthis.m_rgDynamicData = null;\n\n\tthis.RestoreScrollTop( true );\n}\n\nCAjaxInfiniteScrollingControls.prototype.DoneRestoreScrollTop = function()\n{\n\tthis.ClearLoadingDialog();\n\tthis.m_bRestoringScrollTop = false;\n};\n\nCAjaxInfiniteScrollingControls.prototype.ClearLoadingDialog = function()\n{\n\tif ( this.m_LoadingDialog )\n\t{\n\t\tthis.m_LoadingDialog.Dismiss();\n\t\tthis.m_LoadingDialog = null;\n\t}\n};\n\n// Stops this infinite scroll handler.\nCAjaxInfiniteScrollingControls.prototype.Stop = function()\n{\n\t// Clear loading notifiers.\n\tthis.ClearLoadingDialog();\n\tthis.HideThrobber();\n\n\t// Clear scheduled scroll, if there is one.\n\tif ( this.m_oScheduledScroll )\n\t\tclearTimeout( this.m_oScheduledScroll );\n\n\t// Unhook scroll handler.\n\t$J(document).off( \"scroll\", this.m_fnRawScrollHandler );\n\n\t// TODO: Do we need to call or clear BeforeUnload?\n};\n\nCAjaxInfiniteScrollingControls.prototype.RestoreScrollTop = function( bForce )\n{\n\tthis.m_bRestoringScrollTop |= bForce;\n\tif ( !this.m_bRestoringScrollTop )\n\t{\n\t\treturn;\n\t}\n\tvar scrollTopPrevious = parseInt( $J( \"#\" + this.m_strElementPrefix + '_scroll_top').val() );\n\tif ( scrollTopPrevious )\n\t{\n\t\tvar viewport = document.viewport.getDimensions(); // Gets the viewport as an object literal\n\t\tvar windowHeight = viewport.height; // Usable window height\n\t\tvar bodyHeight = $(document.body).getHeight();\n\n\t\t// done?\n\t\tif ( scrollTopPrevious < bodyHeight - windowHeight )\n\t\t{\n\t\t\tthis.DoneRestoreScrollTop();\n\t\t\twindow.scrollTo( 0, scrollTopPrevious );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ( this.m_LoadingDialog == null )\n\t\t\t{\n\t\t\t\tthis.m_LoadingDialog = ShowBlockingWaitDialog( 'Пожалуйста, подождите', 'Возвращаемся к месту на странице, где вы были в последний раз...' );\n\t\t\t}\n\t\t\twindow.scrollTo( 0, scrollTopPrevious );\n\t\t}\n\t}\n};\n\nCAjaxInfiniteScrollingControls.prototype.OnUnload = function()\n{\n\tvar scrollOffset = document.viewport.getScrollOffsets();\n\tvar scrollTop = scrollOffset.top;\n\t$J( \"#\" + this.m_strElementPrefix + '_scroll_top').val( scrollTop );\n};\n\nCAjaxInfiniteScrollingControls.prototype.OnScroll = function()\n{\n\tif ( this.m_bLoading )\n\t\treturn;\n\n\tvar iNow = new Date().getTime();\n\n\t// How soon can we scroll?\n\tvar iScrollWait = this.m_iCooldownTime - iNow;\n\n\t// If we haven't reached our cooldown, do nothing.\n\tif ( iScrollWait > 0 )\n\t{\n\t\t// console.log(\"InfiniScrolling too fast; engaging throttle\");\n\n\t\t// Schedule a scroll event for when they would be allowed to scroll. Without this, the\n\t\t// user needs to jiggle their scrollbar.\n\t\tif ( this.m_oScheduledScroll == null )\n\t\t{\n\t\t\tthis.m_oScheduledScroll = setTimeout( this.m_fnRawScrollHandler, iScrollWait );\n\t\t\tthis.ShowThrobber(); // Show throbber while waiting to begin load.\n\t\t}\n\n\t\treturn;\n\t}\n\n\tthis.m_oScheduledScroll = null;\n\n\t// The bottom of our screen is equal to how far we've scrolled, plus the height of our window.\n\tvar nCurrentScroll = $J(window).scrollTop() + $J(window).height();\n\n\tvar rows = $J('#' + this.m_StrRowsId);\n\tvar offset = rows.offset();\n\n\t// The bottom of our content is the height of our results, plus its offset from the top of the page.\n\t// We want to trigger a load this.m_iTriggerHeight before the user sees that.\n\tvar nTriggerPoint = rows.height() + offset.top - this.m_iTriggerHeight;\n\n\tif ( nCurrentScroll >  nTriggerPoint )\n\t{\n\t\tthis.m_iCooldownTime = iNow + this.m_iCooldownInterval;\n\n\t\tthis.NextPage();\n\t}\n};\n\nCAjaxInfiniteScrollingControls.prototype.GetActionURL = function( action )\n{\n\tvar url = this.m_strActionURL + action + '/';\n\treturn url;\n};\n\nCAjaxInfiniteScrollingControls.prototype.SetPreRequestHandler = function( fnHandler )\n{\n\tthis.m_fnPreRequestHandler = fnHandler;\n};\n\nCAjaxInfiniteScrollingControls.prototype.SetResponseHandler = function( fnHandler )\n{\n\tthis.m_fnResponseHandler = fnHandler;\n};\n\nCAjaxInfiniteScrollingControls.prototype.SetPageChangingHandler = function ( fnHandler )\n{\n\tthis.m_fnPageChangingHandler = fnHandler;\n};\n\nCAjaxInfiniteScrollingControls.prototype.SetPageChangedHandler = function ( fnHandler )\n{\n\tthis.m_fnPageChangedHandler = fnHandler;\n};\n\nCAjaxInfiniteScrollingControls.prototype.SetStaticParameters = function ( rgParams )\n{\n\tthis.m_rgStaticParams = rgParams;\n};\n\nCAjaxInfiniteScrollingControls.prototype.OnAJAXComplete = function()\n{\n\tthis.m_bLoading = false;\n};\n\nCAjaxInfiniteScrollingControls.prototype.NextPage = function()\n{\n\tif ( this.m_iCurrentPage < this.m_cMaxPages - 1 ) {\n\t\tthis.LoadPage( this.m_iCurrentPage + 1 );\n\t}\n\telse\n\t{\n\t\t// We're reached the end of our results!\n\t\tthis.Stop();\n\t}\n\n};\n\nCAjaxInfiniteScrollingControls.prototype.LoadPage = function( iPage, bForce )\n{\n\tif ( typeof( bForce )== 'undefined' || !bForce )\n\t{\n\t\tif ( this.m_bLoading || iPage >= this.m_cMaxPages || iPage < 0 )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse if ( iPage == this.m_iCurrentPage )\n\t\t{\n\t\t\tthis.RestoreScrollTop( false );\n\t\t}\n\t}\n\n\tvar params = {\n\t\tquery: this.m_strQuery,\n\t\tstart: this.m_cPageSize * iPage,\n\t\tcount: this.m_cPageSize,\n\t\tdynamic_data: this.m_rgDynamicData,\n\t};\n\n\tif ( this.m_rgStaticParams != null )\n\t{\n\t\tfor ( var sParamName in this.m_rgStaticParams )\n\t\t{\n\n\t\t\tif ( typeof sParamName != \"string\" )\n\t\t\t\tcontinue;\n\n\t\t\tvar typeOfParam = typeof this.m_rgStaticParams[sParamName];\n\n\t\t\tif ( typeOfParam != \"string\" && typeOfParam != \"number\" && typeOfParam != \"boolean\" )\n\t\t\t\tcontinue;\n\n\t\t\tparams[sParamName] = this.m_rgStaticParams[sParamName];\n\t\t}\n\t}\n\n\tif ( this.m_fnPageChangingHandler != null )\n\t\tthis.m_fnPageChangingHandler( iPage );\n\n\tif ( this.m_fnPreRequestHandler != null )\n\t\tthis.m_fnPreRequestHandler( params );\n\n\tthis.ShowThrobber();\n\n\tthis.m_bLoading = true;\n\n\tnew Ajax.Request( this.GetActionURL( '' ), {\n\t\tmethod: 'get',\n\t\tparameters: params,\n\t\tonSuccess: this.OnResponseRenderResults.bind( this ),\n\t\tonComplete: this.OnAJAXComplete.bind( this )\n\t});\n\n\treturn true;\n};\n\nCAjaxInfiniteScrollingControls.prototype.GetThrobber = function() {\n\t// NB: This is using prototype, *not* jQuery, hence the lack of 'J'.\n\treturn $(this.m_strElementPrefix + '_loading');\n};\n\nCAjaxInfiniteScrollingControls.prototype.HideThrobber = function() {\n\tvar throbber = this.GetThrobber();\n\n\tif (throbber)\n\t\tthrobber.hide();\n};\n\nCAjaxInfiniteScrollingControls.prototype.ShowThrobber = function() {\n\tvar throbber = this.GetThrobber();\n\n\tif (throbber)\n\t\tthrobber.show();\n};\n\nCAjaxInfiniteScrollingControls.prototype.OnResponseRenderResults = function( transport )\n{\n\n\tif ( transport.responseJSON && transport.responseJSON.success )\n\t{\n\t\tthis.HideThrobber();\n\n\t\tif ( typeof RecordAJAXPageView !== \"undefined\" )\n\t\t{\n\t\t\tRecordAJAXPageView( transport.request.url );\n\t\t}\n\n\t\tvar response = transport.responseJSON;\n\t\tthis.m_cTotalCount = response.total_count;\n\t\tthis.m_cMaxPages = Math.ceil( response.total_count / this.m_cPageSize );\n\t\tthis.m_iCurrentPage = Math.floor( response.start / this.m_cPageSize );\n\n\t\tif ( this.m_iCurrentPage != 0 && this.m_cTotalCount <= response.start )\n\t\t{\n\t\t\t// this page is no longer valid, flip back a page (deferred so that the AJAX handler exits and reset m_bLoading)\n\t\t\tthis.DoneRestoreScrollTop();\n\t\t\treturn;\n\t\t}\n\n\t\tvar elResults = $(this.m_StrRowsId);\n\n\t\telResults.insert( response.results_html );\n\n\t\tthis.m_rgDynamicData = ( response.dynamic_data ) ? response.dynamic_data : null;\n\n\t\tif ( this.m_fnResponseHandler != null )\n\t\t{\n\t\t\tthis.m_fnResponseHandler( response );\n\t\t}\n\n\t\tif ( this.m_fnPageChangedHandler != null )\n\t\t\tthis.m_fnPageChangedHandler( this.m_iCurrentPage, elResults );\n\n\t\tthis.m_bLoading = false;\n\t\tif ( this.m_iCurrentPage < this.m_cMaxPages - 1 )\n\t\t{\n\t\t\tthis.RestoreScrollTop( false );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.DoneRestoreScrollTop();\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.DoneRestoreScrollTop();\n\t}\n};\n\nfunction CAjaxPagingControls( rgSearchData, url )\n{\n\tthis.m_strActionURL = null;\n\tthis.m_cPageSize = null;\n\tthis.m_strElementPrefix = \"\";\n\tthis.m_strClassPrefix = \"\";\n\tthis.m_rgStaticParams = null;\n\n\tthis.m_strQuery = null;\n\tthis.m_cTotalCount = 0;\n\tthis.m_iCurrentPage = 0;\n\tthis.m_cMaxPages = 0;\n\tthis.m_bLoading = false;\n\n\tthis.m_fnPreRequestHandler = null;\n\tthis.m_fnResponseHandler = null;\n\tthis.m_fnPageChangingHandler = null;\n\tthis.m_fnPageChangedHandler = null;\n\n\n\tthis.m_strActionURL = url;\n\n\tthis.m_strQuery = rgSearchData['query'];\n\tthis.m_cTotalCount = rgSearchData['total_count'];\n\tthis.m_iCurrentPage = 0;\n\tthis.m_cPageSize = rgSearchData['pagesize'];\n\tthis.m_cMaxPages = Math.ceil( this.m_cTotalCount / this.m_cPageSize );\n\tthis.m_strDefaultAction = typeof rgSearchData['action'] != 'undefined' ? rgSearchData['action'] : 'render';\n\tthis.m_rgAvailableSizes = [];\n\n\tif ( rgSearchData['prefix'] )\n\t\tthis.m_strElementPrefix = rgSearchData['prefix'];\n\n\tif ( rgSearchData['class_prefix'] )\n\t\tthis.m_strClassPrefix = rgSearchData['class_prefix'];\n\n\t$(this.m_strElementPrefix + '_btn_prev').observe( 'click', this.PrevPage.bind( this ) );\n\t$(this.m_strElementPrefix + '_btn_next').observe( 'click', this.NextPage.bind( this ) );\n\tvar elPageSizeCtn = $(this.m_strElementPrefix + '_paging_size_ctn');\n\tfor( var i = 0; elPageSizeCtn && i < $( elPageSizeCtn ).children.length; ++i )\n\t{\n\t\t$(this.m_strElementPrefix + '_paging_size_' + i ).observe( 'click', this.OnChangeSize.bind( this ) );\n\n\t\tthis.m_rgAvailableSizes.push( $( elPageSizeCtn ).children[i].dataset.size );\n\t}\n\n\tthis.UpdatePagingDisplay();\n}\n\nCAjaxPagingControls.prototype.GetActionURL = function( action )\n{\n\tvar url = action ? this.m_strActionURL + action + '/' : this.m_strActionURL;\n\treturn url;\n};\n\nCAjaxPagingControls.prototype.SetPreRequestHandler = function( fnHandler )\n{\n\tthis.m_fnPreRequestHandler = fnHandler;\n};\n\nCAjaxPagingControls.prototype.SetResponseHandler = function( fnHandler )\n{\n\tthis.m_fnResponseHandler = fnHandler;\n};\n\nCAjaxPagingControls.prototype.SetPageChangingHandler = function ( fnHandler )\n{\n\tthis.m_fnPageChangingHandler = fnHandler;\n};\n\nCAjaxPagingControls.prototype.SetPageChangedHandler = function ( fnHandler )\n{\n\tthis.m_fnPageChangedHandler = fnHandler;\n};\n\nCAjaxPagingControls.prototype.SetStaticParameters = function ( rgParams )\n{\n\tthis.m_rgStaticParams = rgParams;\n};\n\nCAjaxPagingControls.prototype.OnAJAXComplete = function()\n{\n\tthis.m_bLoading = false;\n};\n\nCAjaxPagingControls.prototype.OnChangeSize = function( event )\n{\n\tif( event.target && event.target.dataset.size != this.m_cPageSize )\n\t{\n\t\tthis.m_cPageSize = event.target.dataset.size;\n\t\tthis.GoToPage( 0, true );\n\t}\n};\n\nCAjaxPagingControls.prototype.NextPage = function()\n{\n\tif ( this.m_iCurrentPage < this.m_cMaxPages - 1 )\n\t\tthis.GoToPage( this.m_iCurrentPage + 1 );\n};\n\nCAjaxPagingControls.prototype.PrevPage = function()\n{\n\tif ( this.m_iCurrentPage > 0 )\n\t\tthis.GoToPage( this.m_iCurrentPage - 1 );\n};\n\nCAjaxPagingControls.prototype.GoToPage = function( iPage, bForce )\n{\n\tif ( typeof( bForce )== 'undefined' || !bForce )\n\t{\n\t\tif ( this.m_bLoading || iPage >= this.m_cMaxPages || iPage < 0 || iPage == this.m_iCurrentPage )\n\t\t\treturn false;\n\t}\n\n\tvar params = {\n\t\tquery: this.m_strQuery,\n\t\tstart: this.m_cPageSize * iPage,\n\t\tcount: this.m_cPageSize\n\t};\n\n\tif ( this.m_rgStaticParams != null )\n\t{\n\t\tfor ( var sParamName in this.m_rgStaticParams )\n\t\t{\n\t\t\tif ( typeof sParamName != \"string\" )\n\t\t\t\tcontinue;\n\n\t\t\tparams[sParamName] = this.m_rgStaticParams[sParamName];\n\t\t}\n\t}\n\n\tif ( this.m_fnPageChangingHandler != null )\n\t\tthis.m_fnPageChangingHandler( iPage );\n\n\tif ( this.m_fnPreRequestHandler != null )\n\t\tthis.m_fnPreRequestHandler( params );\n\n\tthis.m_bLoading = true;\n\tnew Ajax.Request( this.GetActionURL( this.m_strDefaultAction ), {\n\t\tmethod: 'get',\n\t\tparameters: params,\n\t\tonSuccess: this.OnResponseRenderResults.bind( this ),\n\t\tonComplete: this.OnAJAXComplete.bind( this )\n\t});\n\n\treturn true;\n};\n\nCAjaxPagingControls.prototype.OnResponseRenderResults = function( transport )\n{\n\tif ( transport.responseJSON && transport.responseJSON.success )\n\t{\n\t\tif ( typeof RecordAJAXPageView !== \"undefined\" )\n\t\t{\n\t\t\tRecordAJAXPageView( transport.request.url );\n\t\t}\n\n\t\tvar response = transport.responseJSON;\n\t\tthis.m_cTotalCount = response.total_count;\n\t\tthis.m_cMaxPages = Math.ceil( response.total_count / this.m_cPageSize );\n\t\tthis.m_iCurrentPage = Math.floor( response.start / this.m_cPageSize );\n\n\t\tif ( this.m_iCurrentPage != 0 && this.m_cTotalCount <= response.start )\n\t\t{\n\t\t\t// this page is no longer valid, flip back a page (deferred so that the AJAX handler exits and reset m_bLoading)\n\t\t\tthis.GoToPage.bind( this, this.m_iCurrentPage - 1 ).defer();\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar elResults = $(this.m_strElementPrefix + 'Rows');\n\n\t\tif( elResults)\n\t\t\telResults.update( response.results_html );\n\n\t\tif ( this.m_fnResponseHandler != null )\n\t\t\tthis.m_fnResponseHandler( response );\n\n\t\tthis.UpdatePagingDisplay();\n\n\t\tScrollToIfNotInView( $(this.m_strElementPrefix + 'Table'), 40 );\n\t}\n};\n\nCAjaxPagingControls.prototype.UpdatePagingDisplay = function()\n{\n\tvar elemNoResults = $(this.m_strElementPrefix + '_no_results');\n\tif ( this.m_cTotalCount == 0 )\n\t{\n\t\t$(this.m_strElementPrefix + '_ctn').hide();\n\t\tif ( elemNoResults )\n\t\t\telemNoResults.show();\n\t}\n\telse\n\t{\n\t\t$(this.m_strElementPrefix + '_ctn').show();\n\t\tif ( elemNoResults )\n\t\t\telemNoResults.hide();\n\n\t\t$(this.m_strElementPrefix + '_total').update( v_numberformat( this.m_cTotalCount ) );\n\t\t$(this.m_strElementPrefix + '_start').update( v_numberformat( this.m_iCurrentPage * this.m_cPageSize + 1 ) );\n\t\t$(this.m_strElementPrefix + '_end').update( Math.min( ( this.m_iCurrentPage + 1 ) * this.m_cPageSize, this.m_cTotalCount ) );\n\t}\n\n\t\tif( this.m_rgAvailableSizes && this.m_rgAvailableSizes.length > 0 )\n\t{\n\t\tif( this.m_cTotalCount <= this.m_rgAvailableSizes[0] )\n\t\t{\n\t\t\t$(this.m_strElementPrefix + '_per_page_ctn').hide();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$(this.m_strElementPrefix + '_per_page_ctn').show();\n\t\t}\n\t}\n\n\tif ( this.m_cMaxPages <= 1 )\n\t{\n\t\t$(this.m_strElementPrefix + '_controls').hide();\n\t}\n\telse\n\t{\n\t\t$(this.m_strElementPrefix + '_controls').show();\n\t\tif ( this.m_iCurrentPage > 0 )\n\t\t\t$(this.m_strElementPrefix + '_btn_prev').removeClassName('disabled');\n\t\telse\n\t\t\t$(this.m_strElementPrefix + '_btn_prev').addClassName('disabled');\n\n\t\tif ( this.m_iCurrentPage < this.m_cMaxPages - 1 )\n\t\t\t$(this.m_strElementPrefix + '_btn_next').removeClassName('disabled');\n\t\telse\n\t\t\t$(this.m_strElementPrefix + '_btn_next').addClassName('disabled');\n\n\t\tvar elPageLinks = $(this.m_strElementPrefix + '_links');\n\t\telPageLinks.update('');\n\t\t// we always show first, last, + 3 page links closest to current page\n\t\tvar cPageLinksAheadBehind = 2;\n\t\tvar firstPageLink = Math.max( this.m_iCurrentPage - cPageLinksAheadBehind, 1 );\n\t\tvar lastPageLink = Math.min( this.m_iCurrentPage + (cPageLinksAheadBehind*2) + ( firstPageLink - this.m_iCurrentPage ), this.m_cMaxPages - 2 );\n\n\t\tif ( lastPageLink - this.m_iCurrentPage < cPageLinksAheadBehind )\n\t\t\tfirstPageLink = Math.max( this.m_iCurrentPage - (cPageLinksAheadBehind*2) + ( lastPageLink - this.m_iCurrentPage ), 1 );\n\n\t\tthis.AddPageLink( elPageLinks, 0 );\n\t\tif ( firstPageLink != 1 )\n\t\t\telPageLinks.insert( ' ... ' );\n\n\t\tfor ( var iPage = firstPageLink; iPage <= lastPageLink; iPage++ )\n\t\t{\n\t\t\tthis.AddPageLink( elPageLinks, iPage );\n\t\t}\n\n\t\tif ( lastPageLink != this.m_cMaxPages - 2 )\n\t\t\telPageLinks.insert( ' ... ' );\n\t\tthis.AddPageLink( elPageLinks, this.m_cMaxPages - 1 );\n\t}\n\n\t\tif( this.m_rgAvailableSizes.indexOf( this.m_cPageSize ) > -1 )\n\t{\n\t\tfor( var i = 0; i < this.m_rgAvailableSizes.length; ++ i )\n\t\t{\n\t\t\tvar elSizeItem = $(this.m_strElementPrefix + '_paging_size_' + i );\n\t\t\tif( elSizeItem.dataset.size == this.m_cPageSize )\n\t\t\t{\n\t\t\t\telSizeItem.addClassName( 'size_selected' );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\telSizeItem.removeClassName( 'size_selected' );\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( this.m_fnPageChangedHandler != null )\n\t\tthis.m_fnPageChangedHandler( this.m_iCurrentPage );\n};\n\nCAjaxPagingControls.prototype.AddPageLink = function( elPageLinks, iPage )\n{\n\tvar el = new Element( 'span', {'class': ( this.m_strClassPrefix != \"\" ? this.m_strClassPrefix : this.m_strElementPrefix ) + '_paging_pagelink' } );\n\tel.update( (iPage + 1) + ' ' );\n\n\tif ( iPage == this.m_iCurrentPage )\n\t\tel.addClassName( 'active' );\n\telse\n\t\tel.observe( 'click', this.GoToPage.bind( this, iPage ) );\n\n\telPageLinks.insert( el );\n};\n\n\nfunction CSlider( $Container, $Grabber, args )\n{\n\tthis.m_$Container = $Container;\n\tthis.m_$Grabber = $Grabber || $Container.find('.handle');\n\tthis.m_nMinVal = args.min || 0;\n\tthis.m_nMaxVal = args.max || 100;\n\tthis.m_nIncrement = args.increment || 1;\n\tthis.m_nValue = args.value || 0;\n\tthis.m_fnOnChange = args.fnOnChange || function( value, bInDrag ) {};\n\n\tthis.m_$Grabber.css( 'position', 'absolute' );\n\tthis.CalcRatios();\n\tthis.SetValue( this.m_nValue );\n\n\tvar fnGetPageX = function( event )\n\t{\n\t\tif ( event.type.indexOf( 'touch' ) == 0 )\n\t\t{\n\t\t\tvar TouchEvent = event.originalEvent;\n\t\t\tvar rgTouches = TouchEvent ? TouchEvent.touches : null;\n\t\t\tif ( !rgTouches || rgTouches.length < 1 )\n\t\t\t\treturn event.pageX || 0;\t//probably wrong\n\t\t\treturn rgTouches[0].pageX || 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn event.pageX || 0;\n\t\t}\n\t};\n\n\tvar _this = this;\n\tthis.m_$Container.on( 'mousedown touchstart', function( event ) {\n\t\t_this.CalcRatios();\n\n\t\tif ( !_this.m_$Grabber.is( event.target ) )\n\t\t{\n\t\t\t// jump the grabber to this position and start the drag\n\t\t\tvar nPosition = fnGetPageX( event ) - _this.m_$Container.offset().left;\n\t\t\t// we want the grabber centered under the mosue if possible\n\t\t\tnPosition -= Math.floor( _this.m_$Grabber.width() / 2 );\n\t\t\tvar nNewPosition = Math.min( Math.max( nPosition, 0 ), _this.m_nWidth );\n\n\t\t\t_this.m_$Grabber.css('left', nNewPosition + 'px' );\n\t\t\t_this.m_nValue = nNewPosition / _this.m_flRatio;\n\t\t\tif ( _this.m_nIncrement > 1 && _this.m_nValue < _this.m_nMaxVal ) {\n\t\t\t\t//_this.m_nValue += _this.m_nIncrement - 1;\n\t\t\t\t_this.m_nValue = parseInt(_this.m_nValue / _this.m_nIncrement) * _this.m_nIncrement;\n\t\t\t}\n\n\t\t\t_this.m_fnOnChange( _this.m_nValue, true );\n\t\t}\n\t\tvar nInitialPosition = parseInt( _this.m_$Grabber.css('left') );\n\t\tvar nStartDragX = fnGetPageX( event );\n\n\t\t$J(document).on( 'mousemove.CSlider touchmove.CSlider', function( event ) {\n\t\t\tvar nDelta = fnGetPageX( event ) - nStartDragX;\n\n\t\t\tvar nNewPosition = Math.min( Math.max( nInitialPosition + nDelta, 0 ), _this.m_nWidth );\n\n\t\t\t_this.m_$Grabber.css('left', nNewPosition + 'px' );\n\t\t\t_this.m_nValue = nNewPosition / _this.m_flRatio;\n\t\t\tif ( _this.m_nIncrement > 1  && _this.m_nValue < _this.m_nMaxVal ) {\n\t\t\t\t//_this.m_nValue += _this.m_nIncrement - 1;\n\t\t\t\t_this.m_nValue = parseInt(_this.m_nValue / _this.m_nIncrement) * _this.m_nIncrement;\n\t\t\t}\n\n\t\t\t_this.m_fnOnChange( _this.m_nValue, true );\n\t\t});\n\t\t$J(document).on( 'mouseup.CSlider touchend.CSlider', function( event ) {\n\t\t\t$J(document).off('.CSlider');\n\t\t\t_this.m_fnOnChange( _this.m_nValue, false );\n\t\t});\n\n\t\tevent.preventDefault();\n\t});\n}\n\nCSlider.prototype.CalcRatios = function()\n{\n\tvar nGrabberWidth = this.m_$Grabber.width();\n\tthis.m_nWidth = this.m_$Container.width() - nGrabberWidth;\n\n\tthis.m_flRatio = this.m_nWidth / ( this.m_nMaxVal - this.m_nMinVal );\n};\n\nCSlider.prototype.SetValue = function( nValue, nAnimationSpeed )\n{\n\tthis.m_nValue = Math.min( Math.max( nValue, this.m_nMinVal ), this.m_nMaxVal );\n\n\tvar nNewPosition = Math.floor( ( this.m_nValue - this.m_nMinVal ) * this.m_flRatio );\n\n\tthis.m_$Grabber.stop();\n\tif ( nAnimationSpeed )\n\t\tthis.m_$Grabber.animate( {left: nNewPosition }, nAnimationSpeed );\n\telse\n\t\tthis.m_$Grabber.css( 'left',  nNewPosition + 'px' );\n};\n\nCSlider.prototype.GetValue = function()\n{\n\treturn this.m_nValue;\n};\n\nCSlider.prototype.GetMin = function()\n{\n\treturn this.m_nMinVal;\n};\n\nCSlider.prototype.GetMax = function()\n{\n\treturn this.m_nMaxVal;\n};\n\nCSlider.prototype.SetRange = function( nMinVal, nMaxVal, nValue )\n{\n\tthis.m_nMinVal = nMinVal;\n\tthis.m_nMaxVal = nMaxVal;\n\tif ( typeof nValue != 'undefined' )\n\t\tthis.m_nValue = nValue;\n\tthis.CalcRatios();\n\tthis.SetValue( this.m_nValue );\n};\n\nCSlider.prototype.SetIncrement = function( nIncrement )\n{\n\tthis.m_nIncrement = nIncrement;\n};\n\nfunction CScrollSlider( $Scroll, $Container, $Grabber, args )\n{\n\tthis.m_$Scroll = $Scroll;\n\tthis.m_$SliderCtn = $Container;\n\n\tvar $Slider = $Container.children('.slider');\n\n\tthis.m_Slider = new CSlider( $Slider.length ? $Slider : $Container, $Grabber, { fnOnChange: $J.proxy( this.OnSliderChange, this )} );\n\n\tthis.m_$Scroll.css('overflowX', 'scroll');\n\t// add momentum on iOS\n\tthis.m_$Scroll.css('-webkit-overflow-scrolling', 'touch');\n\n\tvar _this = this;\n\tvar bDidInitialRecalc = false;\n\tthis.m_$Scroll.on( 'scroll.ScrollSlider', function() {\n\t\tif ( !bDidInitialRecalc )\n\t\t{\n\t\t\t// we don't want to do this all the time, but on some browsers the first call to\n\t\t\t//\tupdate ranges is too early and values don't compute correctly.\n\t\t\t_this.UpdateRanges();\n\t\t\tbDidInitialRecalc = true;\n\t\t}\n\t\t_this.m_Slider.SetValue( _this.m_$Scroll.scrollLeft() );\n\t});\n\t$J(window).on('resize.ScrollSlider', function() {\n\t\t_this.UpdateRanges();\n\t} );\n\tthis.m_$Scroll.on( 'v_contentschanged', function() {\n\t\t_this.UpdateRanges();\n\t} );\n\n\tthis.UpdateRanges();\n}\n\nCScrollSlider.prototype.SetValue = function( value, nAnimationSpeed ) {\n\tif ( nAnimationSpeed )\n\t{\n\t\tthis.m_$Scroll.stop().animate( {'scrollLeft': value }, nAnimationSpeed );\n\t}\n\telse\n\t{\n\t\tthis.m_$Scroll.stop().scrollLeft( value );\n\t}\n};\n\nCScrollSlider.prototype.GetValue = function() {\n\treturn this.m_Slider.GetValue();\n};\n\nCScrollSlider.prototype.UpdateRanges = function()\n{\n\tvar nParentWidth = this.m_$Scroll.width();\n\tvar nScrollWidth = this.m_$Scroll[0].scrollWidth;\n\n\tif ( nScrollWidth <= nParentWidth )\n\t{\n\t\tthis.m_$SliderCtn.hide();\n\t}\n\telse\n\t{\n\t\tthis.m_Slider.SetRange( 0, nScrollWidth - nParentWidth, this.m_$Scroll.scrollLeft() );\n\t\tthis.m_$SliderCtn.show();\n\t}\n};\n\nCScrollSlider.prototype.OnSliderChange = function( value, bInDrag )\n{\n\tthis.m_$Scroll.stop().scrollLeft( value );\n};\n\nfunction IsValidEmailAddress( email )\n{\n\tvar email_regex = /^((\"[\\w-\\s]+\")|([\\w-]+(?:\\.[\\w-]+)*)|(\"[\\w-\\s]+\")([\\w-]+(?:\\.[\\w-]+)*))(@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,6}(?:\\.[a-z]{2})?)$)|(@\\[?((25[0-5]\\.|2[0-4][0-9]\\.|1[0-9]{2}\\.|[0-9]{1,2}\\.))((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\\.){2}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\\]?$)/i;\n\treturn ( email != '' && email_regex.test(email) );\n}\n\n\n(function ($) {\n  $.deparam = function (params, coerce) {\n    var obj = {},\n        coerce_types = { 'true': !0, 'false': !1, 'null': null };\n\n    $.each(params.replace(/\\+/g, ' ').split('&'), function (j,v) {\n      var param = v.split('='),\n          key = decodeURIComponent(param[0]),\n          val,\n          cur = obj,\n          i = 0,\n\n          keys = key.split(']['),\n          keys_last = keys.length - 1;\n\n      if (/\\[/.test(keys[0]) && /\\]$/.test(keys[keys_last])) {\n        keys[keys_last] = keys[keys_last].replace(/\\]$/, '');\n\n        keys = keys.shift().split('[').concat(keys);\n\n        keys_last = keys.length - 1;\n      } else {\n        keys_last = 0;\n      }\n\n      if (param.length === 2) {\n        val = decodeURIComponent(param[1]);\n\n        if (coerce) {\n          val = val && !isNaN(val)              ? +val              // number\n              : val === 'undefined'             ? undefined         // undefined\n              : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null\n              : val;                                                // string\n        }\n\n        if ( keys_last ) {\n          for (; i <= keys_last; i++) {\n            key = keys[i] === '' ? cur.length : keys[i];\n            cur = cur[key] = i < keys_last\n              ? cur[key] || (keys[i+1] && isNaN(keys[i+1]) ? {} : [])\n              : val;\n          }\n\n        } else {\n\n          if ($.isArray(obj[key])) {\n            obj[key].push( val );\n\n          } else if (obj[key] !== undefined) {\n            obj[key] = [obj[key], val];\n\n          } else {\n            obj[key] = val;\n          }\n        }\n\n      } else if (key) {\n        obj[key] = coerce\n          ? undefined\n          : '';\n      }\n    });\n\n    return obj;\n  };\n})(jQuery);\n\n/**\n * Generic search field that handles:\n * 1.) Showing default text if the input field is empty\n * 2.) When the input field gets focus, the text field clears\n * 3.) Adding CSS class to the input field when it is default text\n * 4.) When the user presses return/enter in  the field\n *\n * Call ClearIfDefaultValue() before submitting the form\n */\nfunction SearchFieldWithText( elemID, defaultSearchText, onEnterFunc, defaultTextCSSClass )\n{\n\tvar elem = $( elemID );\n\n\tthis.elem = elem;\n\tthis.defaultSearchText = defaultSearchText;\n\tthis.defaultTextCSSClass = defaultTextCSSClass;\n\tthis.onEnterFunc = onEnterFunc;\n\n\tEvent.observe( elem, 'click', this.handleClickOrFocus.bind(this));\n\tEvent.observe( elem, 'focus', this.handleClickOrFocus.bind(this));\n\tEvent.observe( elem, 'blur', this.handleBlur.bind(this));\n\tEvent.observe( elem, 'keypress', this.handleKeypress.bind(this));\n\tEvent.observe( elem.form, 'submit', this.ClearIfDefaultValue.bind(this));\n\n\tthis.handleBlur();\n}\n\nSearchFieldWithText.prototype.handleClickOrFocus = function()\n{\n\tif ( this.elem.value == this.defaultSearchText )\n\t{\n\t\tthis.elem.value = '';\n\t\tif ( this.defaultTextCSSClass )\n\t\t\tthis.elem.removeClassName( this.defaultTextCSSClass );\n\t}\n};\n\nSearchFieldWithText.prototype.handleBlur = function()\n{\n\tif ( this.elem.value == '')\n\t{\n\t\tthis.elem.value = this.defaultSearchText;\n\t\tif ( this.defaultTextCSSClass )\n\t\t\tthis.elem.addClassName( this.defaultTextCSSClass );\n\t}\n};\n\nSearchFieldWithText.prototype.handleKeypress = function()\n{\n\tif ( !this.onEnterFunc )\n\t\treturn;\n\n\tvar keyCode = null;\n\tif( event.which )\n\t{\n\t\tkeyCode = event.which;\n\t}\n\telse if( event.keyCode )\n\t{\n\t\tkeyCode = evt.keyCode;\n\t}\n\tif ( 13 == keyCode )\n\t{\n\t\tthis.onEnterFunc();\n\t}\n};\n\nSearchFieldWithText.prototype.ClearIfDefaultValue = function()\n{\n\tif ( this.elem.value == this.defaultSearchText )\n\t{\n\t\tthis.elem.value = '';\n\t}\n};\n\n\nfunction CWebAPI( strWebAPIHost, strSecureWebAPIHost, strOAuth2Token )\n{\n\tthis.m_strHost = strWebAPIHost;\n\tthis.m_strSecureWebAPIHost = strSecureWebAPIHost;\n\tthis.m_strOAuth2Token = strOAuth2Token;\n}\n\nCWebAPI.prototype.BuildURL = function( strInterface, strMethod, bSecure, strVersion )\n{\n\tif ( !strVersion )\n\t\tstrVersion = 'v0001';\n\n\tvar strURL = ( bSecure ? this.m_strSecureWebAPIHost : this.m_strHost );\n\tstrURL += strInterface + '/' + strMethod + '/' + strVersion + '/';\n\n\treturn strURL;\n};\n\nCWebAPI.prototype.ExecJSONP = function( strInterface, strMethod, rgParams, bSecure, strVersion, cTimeoutSecs )\n{\n\trgParams.access_token = this.m_strOAuth2Token;\n\n\tvar rgJQueryParams = {\n\t\turl: this.BuildURL( strInterface, strMethod, bSecure, strVersion ),\n\t\tdataType: 'jsonp',\n\t\tjsonp: 'jsonp',\t\t\t\tdata: rgParams\n\t};\n\n\tif ( cTimeoutSecs )\n\t\trgJQueryParams['timeout'] = cTimeoutSecs * 1000;\n\n\treturn $J.ajax( rgJQueryParams );\n\n\t/*\n\t// using jsonp plugin instead of built-in jquery jsonp handling.  this library supposedly\n\t//\tworks around the firefox \"waiting for host...\" issue, but it doesn't work.\n\treturn $J.jsonp({\n\t\turl: this.BuildURL( strInterface, strMethod, bSecure, strVersion ),\n\t\tcallbackParameter: 'jsonp',\t\t\t\tdata: rgParams\n\t});\n\t*/\n};\n\n// Send a \"beacon\", which is specifically intended for use in OnUnload events (as outsdanding AJAX/JSONP requests may be cancelled)\n// as of sept 2015, only chrome and firefox support this, no iOS or IE support.  Check for support before calling.\n// Beacons are (per spec) always a POST request, and always include CORS headers.  WebAPI respondes properly to CORS for Valve domains.\nCWebAPI.prototype.ExecBeacon = function( strInterface, strMethod, rgParams, bSecure, strVersion )\n{\n\trgParams.access_token = this.m_strOAuth2Token;\n\n\tvar fdParams = new FormData();\n\tfor ( var key in rgParams )\n\t\tfdParams.append( key, rgParams[key] );\n\n\tnavigator.sendBeacon( this.BuildURL( strInterface, strMethod, bSecure, strVersion ), fdParams );\n};\n\n\nCWebAPI.prototype.ExecPOST = function( strInterface, strMethod, rgParams, bSecure, strVersion )\n{\n\trgParams.access_token = this.m_strOAuth2Token;\n\trgParams.format = 'json';\n\n\treturn $J.ajax( {\n\t\turl: this.BuildURL( strInterface, strMethod, bSecure, strVersion ),\n\t\ttype: 'POST',\n\t\tdata: rgParams\n\t});\n};\n\n// register some events to dismiss popup (ie, user clicking elsewhere on the window, escape)\n//   cleans up event binds afterwards.  clicks to children of \"elemIgnore\" will not dismiss popup\nfunction RegisterPopupDismissal( dismissFunc, elemIgnore )\n{\n\tvar $Ignore = $JFromIDOrElement( elemIgnore );\n\t// delay registration by one frame so that we don't catch the event that triggered this popup.\n\twindow.setTimeout( function() {\n\t\t$J(document).on('click.RegisterPopupDismissal keydown.RegisterPopupDismissal', function (event) {\n\n\t\t\tif (event.keyCode && event.keyCode != 27 /* KEY_ESC */) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar elem = $J(event.target);\n\n\t\t\tif ( $Ignore.length && $J.contains( $Ignore[0], elem[0] ) )\n\t\t\t\treturn;\n\n\t\t\tdismissFunc();\n\t\t\tUnregisterPopupDismissal( elemIgnore );\n\t\t});\n\n\t\t// support gamepad B button to dismiss\n\t\t$Ignore.on( 'vgp_oncancel', function ( event ) {\n\t\t\tdismissFunc();\n\t\t\tUnregisterPopupDismissal( elemIgnore );\n\n\t\t\tevent.stopPropagation();\n\t\t\tevent.preventDefault();\n\t\t});\n\t}, 1 );\n}\n\n/* Cleanup function for the above RegisterPopupDismissal()\n   This needs to be accessible to popup owners so they can call this if they're closing the popup */\nfunction UnregisterPopupDismissal( elemIgnore )\n{\n\t$J(document).off( '.RegisterPopupDismissal' );\n\n\tif ( elemIgnore )\n\t{\n\t\t// unregister gamepad B button press handling\n\t\t$JFromIDOrElement( elemIgnore ).off( 'vgp_oncancel' );\n\t}\n}\n\n\nfunction ShowMenu( elemLink, elemPopup, align, valign, bLinkHasBorder )\n{\n\tvar $Popup = $JFromIDOrElement(elemPopup);\n\n\t// If we're in tablet screen mode put the menu content in a modal dialog\n\tvar bUseTabletScreenMode = window.UseTabletScreenMode && window.UseTabletScreenMode();\n\tif ( bUseTabletScreenMode )\n\t{\n\t\t// detach this element and when the dialog closes re-attach to the document body\n\t\t$Popup.detach();\n\t\tvar originalPopupPosition = $Popup.css( 'position' );\n\t\t$Popup.css( 'position', 'static' ); // clear possible absolute positioning\n\t\t$Popup.show();\n\n\t\tShowDialog( '', $Popup ).always(\n\t\t\tfunction() {\n\t\t\t\t// save it away again for later\n\t\t\t\t$Popup.hide();\n\t\t\t\t$Popup.css( 'position', originalPopupPosition ); // restore positioning\n\t\t\t\t$J( document.body ).append( $Popup );\n\t\t\t}\n\t\t);\n\n\t\treturn;\n\t}\n\n\tvar $Link = $JFromIDOrElement(elemLink);\n\tif ( $Link.hasClass('focus') )\n\t{\n\t\tHideMenu( elemLink, elemPopup );\n\t\treturn;\n\t}\n\n\tAlignMenu( $Link, $Popup, align, valign, bLinkHasBorder );\n\n\tShowWithFade( $Popup );\n\t$Link.addClass('focus');\n\tRegisterPopupDismissal( function() { HideMenu( elemLink, elemPopup ); }, $Popup );\n\n\t// If we use this control on gamepad (haven't found an example yet we're going to keep) then we'll need to\n\t// add calling: GPOnShowingModalWindow( $Popup[0] ).  See shared_responsive_adapter.js for example\n}\n\nfunction HideMenu( elemLink, elemPopup )\n{\n\tvar $Link = $JFromIDOrElement(elemLink);\n\tvar $Popup = $JFromIDOrElement(elemPopup);\n\n\t$Link.data( 'menu-active', false );\n\tHideWithFade( $Popup );\n\t$Link.removeClass( 'focus' );\n\n\tUnregisterPopupDismissal( elemPopup );\n}\n\nfunction HideMenuFast( elemLink, elemPopup )\n{\n\tvar $Link = $JFromIDOrElement(elemLink);\n\tvar $Popup = $JFromIDOrElement(elemPopup);\n\n\t$Popup.hide();\n\t$Link.removeClass( 'focus' );\n\n\tUnregisterPopupDismissal( elemPopup );\n}\n\n\nfunction RegisterFlyout( elemLink, elemPopup, align, valign, bLinkHasBorder )\n{\n\tvar $Link = $JFromIDOrElement( elemLink );\n\tvar $Popup = $JFromIDOrElement( elemPopup );\n\n\t$Link.on( 'mouseenter', function( event ) {\n\t\tFlyoutMenu( $Link, $Popup, align, valign, bLinkHasBorder );\n\t});\n\n\t$Link.add( $Popup ).on( 'mouseleave', function( event ) {\n\t\tHideFlyoutMenu( event, $Link, $Popup );\n\t});\n}\n\nfunction UseSmallScreenMenu()\n{\n\t// the new mobile app uses the small screen menu regardless of screen size\n\treturn ( window.UseSmallScreenMode && window.UseSmallScreenMode() ) || ( window.UseNewMobileAppMode && window.UseNewMobileAppMode() );\n}\n\nfunction FlyoutMenu( elemLink, elemPopup, align, valign, bLinkHasBorder, elemAlternateAlignTo )\n{\n\tvar $Link = $JFromIDOrElement(elemLink);\n\tvar $Popup = $JFromIDOrElement(elemPopup);\n\n\tif ( !$Popup.is(':visible') || $Popup.css('opacity') < 1.0 )\n\t{\n\t\tif ( $Popup.hasClass( 'responsive_slidedown') && UseSmallScreenMenu() )\n\t\t{\n\t\t\t$Popup.stop().slideDown();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Responsive mode calls slideDown, which applies position: relative to the element and we need to clear it.\n\t\t\t// This will only happen if the user interacted with the menu in the responsive mode, then resized\n\t\t\t// their window to be large and hovered the elements.\n\t\t\t$Popup.css( { position: '' } );\n\t\t\tAlignMenu( $Link, $Popup, align, valign, bLinkHasBorder, elemAlternateAlignTo || null );\n\t\t\tShowWithFade( $Popup );\n\t\t}\n\n\t\t$Link.addClass('focus');\n\t}\n\n}\n\nfunction HideFlyoutMenu( event, elemLink, elemPopup )\n{\n\tvar $Link = $JFromIDOrElement(elemLink);\n\tvar $Popup = $JFromIDOrElement(elemPopup);\n\n\tif ( !$Link.hasClass('focus') )\n\t\treturn;\n\n\tif ( event )\n\t{\n\t\tvar reltarget = $J( event.relatedTarget );\n\t\tif ( !reltarget.length ||\n\t\t\t( $Link.length && $J.contains( $Link[0], reltarget[0] ) ) ||\n\t\t\t( $Popup.length && $J.contains( $Popup[0], reltarget[0] ) ) ||\n\t\t\t$Link.is( reltarget ) )\n\t\t\treturn;\n\t}\n\t// start hiding in a little bit, have to let the fade in animation start before we can cancel it\n\n\tif ( $Popup.hasClass( 'responsive_slidedown') && UseSmallScreenMenu() )\n\t\t$Popup.stop().slideUp();\n\telse\n\t\twindow.setTimeout( function() { HideWithFade( $Popup ); }, 33 );\n\n\t$Link.removeClass('focus');\n\t$J(document).off('.FlyoutDismiss');\n}\n\nfunction AlignMenu( elemLink, elemPopup, align, valign, bLinkHasBorder, elemAlternateAlignTo )\n{\n\tvar align = align ? align : 'left';\n\n\t// alternate align to is used to align the genre menu on the store; it's only used for horizontal alignment,\n\t// trying to align to it vertically messes up responsive view.\n\tvar $LinkVertical = $JFromIDOrElement(elemLink);\n\tvar $LinkHorizontal = elemAlternateAlignTo ? $JFromIDOrElement(elemAlternateAlignTo) : $LinkVertical;\n\n\tvar $Popup = $JFromIDOrElement(elemPopup);\n\n\n\tvar offsetLinkVertical = $LinkVertical.offset();\n\tvar offsetLinkHorizontal = $LinkHorizontal.offset();\n\tvar nWindowScrollTop = $J(window).scrollTop();\n\tvar nViewportHeight = $J(window).height();\n\n\tvar nLinkViewportTop = offsetLinkVertical.top - nWindowScrollTop;\n\n\t// add a little bit of padding so we don't position it flush to an edge if possible\n\tvar nPopupHeight = $Popup.height() + 8;\n\n\tif ( !valign )\n\t{\n\t\t//if there's not enough room between our spot and the top of the document, we definitely want to drop down\n\t\tif ( nWindowScrollTop + offsetLinkVertical.top < nPopupHeight )\n\t\t{\n\t\t\tvalign = 'bottom';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar nSpaceAbove = nLinkViewportTop;\n\t\t\tvar nSpaceBelow = nViewportHeight - ( nLinkViewportTop + $LinkVertical.height() );\n\t\t\t//otherwise we only want to drop down if we've got enough space below us (measured based on view area)\n\t\t\t// or if there's not enough space above to pop in either direction and there's more space below\n\t\t\tif ( nSpaceBelow > nPopupHeight || ( nSpaceAbove < nPopupHeight && nSpaceBelow > nSpaceAbove ) )\n\t\t\t\tvalign = 'bottom';\n\t\t\telse\n\t\t\t\tvalign = 'top';\n\n\t\t}\n\t}\n\n\tvar borderpx = bLinkHasBorder ? 1 : 0;\n\tvar shadowpx = $Popup.hasClass( 'popup_block_new' ) ? 0 : 12;\n\tvar offsetLeft = 0;\n\n\tif ( align == 'left' )\n\t{\n\t\t//elemPopup.style.left = ( elemLink.positionedOffset()[0] - 12 ) + 'px';\n\t\toffsetLeft = -shadowpx - borderpx;\n\t}\n\telse if ( align == 'right' )\n\t{\n\t\t//elemPopup.style.left = ( elemLink.positionedOffset()[0] + elemLink.getWidth() - elemPopup.getWidth() + 13 ) + 'px';\n\t\toffsetLeft = $LinkHorizontal.outerWidth() - $Popup.outerWidth() + shadowpx + borderpx;\n\t}\n\telse if ( align == 'leftsubmenu' )\n\t{\n\t\t//elemPopup.style.left = ( elemLink.positionedOffset()[0] - elemPopup.getWidth() + 12 ) + 'px';\n\t\toffsetLeft = -$Popup.outerWidth() + shadowpx - borderpx;\n\t}\n\telse if ( align == 'rightsubmenu' )\n\t{\n\t\t//elemPopup.style.left = ( elemLink.positionedOffset()[0] + elemLink.getWidth() - 12 ) + 'px';\n\t\toffsetLeft = $LinkHorizontal.outerWidth()  - shadowpx + 2 * borderpx;\n\t}\n\n\tvar offsetTop = 0;\n\tif ( valign == 'bottom' )\n\t{\n\t\t//elemPopup.style.top = ( elemLink.positionedOffset()[1] + elemLink.getHeight() - 12 ) + 'px';\n\t\toffsetTop = $LinkVertical.outerHeight() - shadowpx;\n\t}\n\telse if ( valign == 'top' )\n\t{\n\t\t//elemPopup.style.top = ( elemLink.positionedOffset()[1] - elemPopup.getHeight() + 12 ) + 'px';\n\t\toffsetTop = -$Popup.outerHeight() + shadowpx;\n\t}\n\telse if ( valign == 'bottomsubmenu' )\n\t{\n\t\t//elemPopup.style.top = ( elemLink.positionedOffset()[1] - 12 ) + 'px';\n\t\toffsetTop = -shadowpx;\n\t}\n\n\n\tvar bPopupHidden = !$Popup.is(':visible');\n\n\tif ( bPopupHidden )\n\t{\n\t\t// IE can't do this with display: none elements\n\t\t$Popup.css( 'visibility', 'hidden' );\n\t\t$Popup.show();\n\t}\n\n\t$Popup.offset( {\n\t\ttop: Math.max( offsetLinkVertical.top + offsetTop, 0 ),\n\t\tleft: Math.max( offsetLinkHorizontal.left + offsetLeft, 0 )\n\t});\n\n\tif ( bPopupHidden )\n\t{\n\t\t// restore visibility\n\t\t$Popup.hide();\n\t\t$Popup.css( 'visibility', 'visible' );\n\t}\n}\n\nfunction BindAutoFlyoutEvents()\n{\n\tvar fnShowFlyout = function( $Tab, bIsHover, bTakeFocus )\n\t{\n\t\tvar $Content = $J('#' + $Tab.data('flyout') );\n\t\tvar bResponsiveSlidedownMenu = UseSmallScreenMenu() && $Content.hasClass('responsive_slidedown');\n\n\t\tif ( !$Content.length || $Content.data('flyout-event-running') ||\n\t\t\t(bIsHover && bResponsiveSlidedownMenu ) )\n\t\t\treturn;\n\n\t\t$Content.data( 'flyout-event-running', true );\n\t\twindow.setTimeout( function() { $Content.data('flyout-event-running', false ); }, 1 );\n\n\t\tif ( $Content.is(':visible') )\n\t\t{\n\t\t\tif ( !bIsHover )\n\t\t\t\tHideFlyoutMenu( null, $Tab, $Content );\n\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !$Content.data('flyout-events-bound') )\n\t\t{\n\t\t\t$Content.on('mouseleave.Flyout', function( e ) {\n\t\t\t\tif ( UseSmallScreenMenu() && $Content.hasClass('responsive_slidedown') )\n\t\t\t\t\treturn;\n\n\t\t\t\tif ( $Tab.is( e.relatedTarget ) || $J.contains( $Tab[0], e.relatedTarget ) )\n\t\t\t\t\treturn;\n\n\t\t\t\tHideFlyoutMenu( null, $Tab, $Content );\n\t\t\t});\n\n\t\t\t$Content.add($Tab).on('vgp_oncancel', function( e ) {\n\t\t\t\tHideFlyoutMenu( null, $Tab, $Content );\n\t\t\t\tif ( typeof GPNavFocusChild != 'undefined' )\n\t\t\t\t\tGPNavFocusChild( $Tab );\n\t\t\t});\n\n\t\t\t$Content.on('vgp_onblur', function( e ) {\n\t\t\t\tvar node = e.originalEvent.detail.focusedNode;\n\t\t\t\tconsole.log( node );\n\t\t\t\tif ( !node || !$J.contains( e.currentTarget, node.Element ) )\n\t\t\t\t\tHideFlyoutMenu( null, $Tab, $Content );\n\t\t\t});\n\n\t\t\t$Content.data('flyout-events-bound', true );\n\t\t}\n\n\n\t\tFlyoutMenu( $Tab, $Content, $Tab.data('flyout-align'), $Tab.data('flyout-valign'), false, $Tab.data('flyout-align-to-element' ) );\n\n\t\tif ( bTakeFocus && typeof GPNavFocusChild !== 'undefined' )\n\t\t{\n\t\t\twindow.setTimeout( function() {\n\t\t\t\tconsole.log( 'Request focus in', $Content[0] );\n\t\t\t\tGPNavFocusChild( $Content );\n\t\t\t}, 5 );\n\t\t}\n\n\t\tif ( window.UseTouchFriendlyMode && window.UseTouchFriendlyMode() )\n\t\t{\n\t\t\twindow.setTimeout( function() {\n\t\t\t\t$J(document).on('click.FlyoutDismiss', function(e) {\n\t\t\t\t\tif ( $J.contains( $Content[0], e.target ) || $Content.is( e.target ) )\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tHideFlyoutMenu( null, $Tab, $Content );\n\t\t\t\t\te.preventDefault();\n\t\t\t\t});\n\t\t\t}, 1 );\n\t\t}\n\t};\n\n\t$J(document).on( 'mouseenter.Flyout click.Flyout', '.flyout_tab', function(e) {\n\t\tvar $Tab = $J(this);\n\t\tvar msDelay = $Tab.data('flyout-delay');\n\n\t\tvar bIsHover = e.type == 'mouseenter';\n\n\t\tif ( !bIsHover || !msDelay )\n\t\t{\n\t\t\tfnShowFlyout( $Tab, bIsHover );\n\t\t}\n\t\telse if ( !$Tab.data( 'iFlyoutInterval' ) )\n\t\t{\n\t\t\tvar fnCleanupFlyoutInterval = function() {\n\t\t\t\t$Tab.removeData( 'iFlyoutInterval' );\n\t\t\t\t$Tab.off( 'mouseleave.FlyoutCancel' );\n\t\t\t}\n\t\t\t$Tab.on( 'mouseleave.FlyoutCancel', function(e) {\n\t\t\t\twindow.clearTimeout( $Tab.data('iFlyoutInterval') );\n\t\t\t\tfnCleanupFlyoutInterval();\n\t\t\t});\n\t\t\t$Tab.data( 'iFlyoutInterval', window.setTimeout( function() {\n\t\t\t\tfnCleanupFlyoutInterval();\n\t\t\t\tfnShowFlyout( $Tab, bIsHover );\n\t\t\t}, msDelay ) );\n\t\t}\n\n\t});\n\n\t$J(document).on('mouseleave.Flyout', '.flyout_tab', function(e) {\n\t\tvar $Tab = $J(this);\n\t\tvar $Content = $J('#' + $Tab.data('flyout') );\n\t\tvar bResponsiveSlidedownMenu = UseSmallScreenMenu() && $Content.hasClass('responsive_slidedown');\n\n\t\tif ( !$Content.length || $Content.data('flyout-event-running') || bResponsiveSlidedownMenu ||\n\t\t\t$Content.is( e.relatedTarget ) || $J.contains( $Content[0], e.relatedTarget ) )\n\t\t\treturn;\n\n\t\tif ( $Content.is(':visible') )\n\t\t{\n\t\t\tHideFlyoutMenu( null, $Tab, $Content );\n\n\t\t\treturn;\n\t\t}\n\t});\n\n\t\t$J(document).on('vgp_onok', '.flyout_tab', function( e ) {\n\t\tfnShowFlyout( $J(this), false, true );\n\t\te.stopPropagation();\n\t});\n}\n\nfunction PollOnUserActionAfterInterval( strNamespace, nPollInterval, fnCallback, nPollImmediateInterval )\n{\n\tvar bCallbackInvoked = false;\n\tvar tsLastUserAction = $J.now();\n\tvar fnInvokeCallbackOnNextUserAction;\n\n\tvar strEvents = ['touchstart','mousemove','focus','scroll',''].join( '.' + strNamespace + ' ' );\n\n\tvar fnDoPoll = function() {\n\t\tif ( !bCallbackInvoked )\n\t\t\tfnCallback();\n\t\tbCallbackInvoked = true;\n\t\tfnInvokeCallbackOnNextUserAction();\n\t};\n\n\tfnInvokeCallbackOnNextUserAction = function() {\n\t\twindow.setTimeout( function() {\n\t\t\tbCallbackInvoked = false;\n\t\t\tif ( nPollImmediateInterval && $J.now() <= tsLastUserAction + nPollImmediateInterval )\n\t\t\t{\n\t\t\t\tfnDoPoll();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$J(window).on( strEvents, function() {\n\t\t\t\t\t$J(window ).off( '.' + strNamespace );\n\t\t\t\t\ttsLastUserAction = $J.now();\n\t\t\t\t\tfnDoPoll();\n\t\t\t\t});\n\t\t\t}\n\t\t}, nPollInterval );\n\t};\n\n\tfnInvokeCallbackOnNextUserAction();\n}\n\nvar DELAY_BETWEEN_NOTIFICATION_COUNT_POLLS_MS = 60 * 1000;\nfunction EnableNotificationCountPolling()\n{\n\tPollOnUserActionAfterInterval( 'NotificationCountPoll', DELAY_BETWEEN_NOTIFICATION_COUNT_POLLS_MS, UpdateNotificationCounts );\n}\n\nfunction UpdateNotificationCounts()\n{\n\tif ( window.RefreshSteamNotifications )\n\t\twindow.RefreshSteamNotifications();\n}\n\nfunction PostToURLWithSession( url, rgParams )\n{\n\tvar $Form = $J('<form/>', {'action': url, 'method': 'POST' } );\n\n\t// site must set this js var or pass to this function\n\tif ( typeof g_sessionID != 'undefined' )\n\t\t$Form.append( $J('<input/>', {'type': 'hidden', 'name': 'sessionid', 'value': g_sessionID } ) );\n\n\tif ( rgParams )\n\t{\n\t\tfor ( var name in rgParams )\n\t\t\t$Form.append( $J('<input/>', {'type': 'hidden', 'name': name, 'value': rgParams[name] } ) );\n\t}\n\t$Form.appendTo( 'body' );\n\t$Form.submit();\n}\n\n\nfunction ShowWithFade( elem, speed )\n{\n\tvar $Elem = $JFromIDOrElement(elem);\n\n\t$Elem.stop();\n\t$Elem.fadeTo( speed || 200, 1.0 );\t//fadeTo rather than fadeIn in case it was already in a fade\n}\n\nfunction HideWithFade( elem, speed )\n{\n\tvar $Elem = $JFromIDOrElement(elem);\n\n\t$Elem.stop();\n\t$Elem.fadeOut( speed || 200 );\n}\n\n\nfunction LaunchWebChat( params, paramsFriendsUI )\n{\n\tvar winChat = window.open( '', 'SteamWebChat', 'height=790,width=1015,resize=yes,scrollbars=yes' );\n\tif ( !winChat )\n\t{\n\t\t// popup blocked - this sometimes happens when chat is initiated from the store.  just roll with it.\n\t\treturn;\n\t}\n\n\tvar bNewPopup = false;\n\tvar bCrossOrigin = false;\n\n\ttry {\n\t\tbNewPopup = (winChat.location ==  'about:blank' );\n\t}\n\tcatch ( e )\n\t{\n\t\t// cross-origin exception on http pages etc\n\t\tbCrossOrigin = true;\n\t}\n\n\tif ( bNewPopup )\n\t{\n\t\tif ( params )\n\t\t\tSetValueLocalStorage( 'rgChatStartupParam', V_ToJSON( params ) );\n\n\t\tif ( paramsFriendsUI )\n\t\t{\n\t\t\tvar fnBoundMessageListener = function( event )\n\t\t\t{\n\t\t\t\tif ( event.source == winChat && event.data == \"FriendsUIReady\" &&\n\t\t\t\t\tevent.origin == 'https://steamcommunity.com')\n\t\t\t\t{\n\t\t\t\t\twinChat.postMessage( paramsFriendsUI, 'https://steamcommunity.com/' );\n\t\t\t\t\twindow.removeEventListener( 'message', fnBoundMessageListener );\n\t\t\t\t}\n\t\t\t};\n\t\t\twindow.addEventListener( 'message', fnBoundMessageListener );\n\t\t}\n\n\t\t// created a new window, set the url\n\t\twinChat.location = 'https://steamcommunity.com/chat/';\n\t}\n\telse\n\t{\n\t\tif ( params && !bCrossOrigin && winChat.OnWebchatLaunchURL )\n\t\t\twinChat.OnWebchatLaunchURL( params );\n\n\t\tif ( paramsFriendsUI )\n\t\t\twinChat.postMessage( paramsFriendsUI, 'https://steamcommunity.com/' );\n\t}\n\twinChat.focus();\n}\n\nfunction ShowSupportAlerts(url)\n{\n\twindow.open( url, 'SupportAlerts', 'height=700,width=700,resize=yes,scrollbars=yes' );\n}\n\nfunction UnlockFamilyView( strURL )\n{\n\twindow.location = strURL;\n}\n\nfunction LockFamilyView( bStore )\n{\n\n\tvar urlFirst = '';\n\tvar urlSecond = '';\n\tif ( bStore )\n\t{\n\t\turlFirst = 'https://store.steampowered.com/';\n\t\turlSecond = 'https://steamcommunity.com/';\n\t}\n\telse\n\t{\n\t\turlFirst = 'https://steamcommunity.com/';\n\t\turlSecond = 'https://store.steampowered.com/';\n\t}\n\n\tShowConfirmDialog( 'Вернуться в семейный просмотр',\n\t\t'Вы уверены, что хотите вернуться в семейный просмотр?',\n\t\t'Вернуться в семейный просмотр'\n\t).done( function() {\n\t\tShowBlockingWaitDialog( 'Вернуться в семейный просмотр' );\n\n\t\tCrossDomainPost( urlFirst + '/parental/ajaxlock', {} ).then( function() {\n\t\t\t$J.when(\n\t\t\t\t\t\t\t\t\tCrossDomainPost( 'https://checkout.steampowered.com/parental/ajaxlock', {} ),\n\t\t\t\t\t\t\t\tCrossDomainPost( 'https://steam.tv/parental/ajaxlock', {} ),\n\t\t\t\tCrossDomainPost( urlSecond + 'parental/ajaxlock', {} )\n\t\t\t).always( function()\n\t\t\t{\n\t\t\t\twindow.location = urlFirst;\n\t\t\t} );\n\t\t});\n\t} );\n}\n\nfunction setTimezoneCookies()\n{\n\tvar now = new Date();\n\tvar expire = new Date();\n\n\t// One year expiration, this way we don't need to wait at least one page\n\t// load to have accurate timezone info each session, but only each time the user\n\t// comes with cleared cookies\n\texpire.setTime( now.getTime() + 3600000*24*365 );\n\tvar tzOffset = now.getTimezoneOffset() * -1 * 60;\n\tvar isDST = 0;\n\n\tvar sameSite = '';\n\tif ( window.location.protocol == 'https' )\n\t\tsameSite = '; Secure; SameSite=None;'\n\tdocument.cookie = \"timezoneOffset=\" + tzOffset + \",\" + isDST + \";expires=\"+expire.toGMTString() + \";path=/\" + sameSite;\n}\n\nfunction FlushStyleChanges( element )\n{\n\t$J( element ).css( 'opacity');\n}\n\nvar k_EScrollbarDirectionVertical = 1;\nvar k_EScrollbarDirectionHorizontal = 2;\n\nwindow.VScrollbar = function( eleTarget, eleHandle, direction )\n{\n\tthis.m_eleHandle = eleHandle;\n\tthis.m_eleTarget = eleTarget;\n\n\tvar instance = this;\n\n\tvar propOffset, propSize, propOuterSize, propDimension, propPage, directionInvert, propOffsetEvent;\n\n\tif( direction == k_EScrollbarDirectionVertical)\n\t{\n\t\tpropOffset = 'top';\n\t\tpropSize = 'height';\n\t\tpropOuterSize = 'outerHeight';\n\t\tpropDimension = 'y';\n\t\tpropPage = 'pageY';\n\t\tpropOffsetEvent = 'offsetY';\n\t} else if( direction == k_EScrollbarDirectionHorizontal )\n\t{\n\t\tpropOffset = 'left';\n\t\tpropSize = 'width';\n\t\tpropOuterSize = 'outerWidth';\n\t\tpropDimension = 'x';\n\t\tpropPage = 'pageX';\n\t\tpropOffsetEvent = 'offsetX';\n\n\t\tthis.m_eleTarget.first().css({'white-space': 'nowrap'});\n\t}\n\n\t// Set up some CSS properties we need\n\tthis.m_eleHandle.css({position: 'absolute'});\n\tif( this.m_eleHandle.parent().css('position') == 'static' )\n\t\tthis.m_eleHandle.parent().css({position: 'relative'}); // Needs to be relative or absolute, only set it if we didn't do it in CSS\n\tthis.m_eleTarget.css({position: 'relative', float: 'left'});\n\tthis.m_eleTarget.css(propOffset, '0px');\n\tthis.m_eleTarget.addClass('animating');\n\tthis.m_eleTarget.parent().addClass('v_scrollbar_target');\n\tthis.m_eleTarget.parent().css({position: 'relative', overflow: 'hidden'});\n\tthis.m_nDesiredPosition = 0;\n\tthis.m_flPercent = 0;\n\n\n\tvar funcUpdate = function( bDisableTransitions )\n\t{\n\t\tvar bScrolled = true;\n\t\tif( instance.m_eleTarget[propSize]() - instance.m_eleTarget.parent()[propSize]() <= 0 )\n\t\t{\n\t\t\tinstance.m_eleHandle.parent().addClass('disabled');\n\t\t\tinstance.m_flPercent = 0;\n\t\t\tbScrolled = false;\n\t\t} else\n\t\t\tinstance.m_eleHandle.parent().removeClass('disabled');\n\n\t\tif( instance.m_flPercent < 0 )\n\t\t\tinstance.m_flPercent = 0;\n\n\t\tif( instance.m_flPercent > 1 )\n\t\t\tinstance.m_flPercent = 1;\n\n\n\t\tvar percent = instance.m_flPercent;\n\n\t\tif( bDisableTransitions )\n\t\t\tinstance.DisableTransitions();\n\n\t\tinstance.m_nDesiredPosition = -percent * ( instance.m_eleTarget[propSize]() - instance.m_eleTarget.parent()[propSize]());\n\n\t\t// Update container\n\t\tinstance.m_eleTarget[0].style[propOffset] = instance.m_nDesiredPosition + 'px';\n\n\t\t// Update scroll handle\n\t\tvar handleMax = instance.m_eleHandle.parent()[propSize]() - instance.m_eleHandle[propOuterSize]();\n\t\tinstance.m_eleHandle[0].style[propOffset] = ( percent * handleMax ) + 'px';\n\n\t\tif( bDisableTransitions )\n\t\t\tinstance.EnableTransitions();\n\n\t\treturn bScrolled;\n\t};\n\n\tvar funcMouseMove = function( event ) {\n\t\tvar localDimension = event[propPage] - instance.m_eleHandle.parent().offset()[propOffset];\n\t\tvar localMax = instance.m_eleHandle.parent()[propSize]() - instance.m_eleHandle[propOuterSize]();\n\n\t\tvar percent = localDimension / localMax;\n\t\tinstance.m_flPercent = percent;\n\n\t\tif( funcUpdate(true) )\n\t\t\tevent.preventDefault();\n\n\n\t};\n\n\t$J(eleTarget).bind('mousewheel DOMMouseScroll',function( event ){\n\t\tvar delta = event.originalEvent.wheelDelta || event.originalEvent.detail * -12;\n\n\t\tvar localY = instance.m_nDesiredPosition * -1;\n\t\tvar localMax = instance.m_eleTarget[propOuterSize]() - instance.m_eleTarget.parent()[propSize]();\n\n\t\tif( localY <= 0 && delta > 0 || localY == localMax && delta < 0 )\n\t\t\treturn;\n\n\t\tlocalY -= delta;\n\n\t\tif( localY < 0 ) localY = 0;\n\t\tif( localY > localMax  ) localY = localMax;\n\n\t\tvar percent = localY / localMax;\n\n\t\tinstance.m_flPercent = percent;\n\n\t\tif( funcUpdate() )\n\t\t\tevent.preventDefault();\n\t});\n\n\t$J(eleHandle.parent()).bind('click',function( event ){\n\t\tvar localY = instance.m_eleTarget.position()[propOffset] * -1;\n\t\tvar localMax = instance.m_eleTarget[propOuterSize]() - instance.m_eleTarget.parent()[propSize]();\n\n\t\tvar step = instance.m_eleTarget.parent()[propSize]();\n\n\t\tif( event[propOffsetEvent] < instance.m_eleHandle.position()[propOffset] )\n\t\t\tstep *= -1;\n\n\t\tlocalY += step;\n\n\t\tif( localY < 0 ) localY = 0;\n\t\tif( localY > localMax  ) localY = localMax;\n\n\t\tvar percent = localY / localMax;\n\n\t\tinstance.m_flPercent = percent;\n\n\t\tif( funcUpdate() )\n\t\t\tevent.preventDefault();\n\t});\n\n\teleHandle.mousedown(function( event ){\n\t\t$J(window).bind('mousemove.scroll', funcMouseMove);\n\t\tevent.stopPropagation();\n\t});\n\n\teleHandle.click(function( event ){\n\t\tevent.stopPropagation();\n\t});\n\n\t$J(window).mouseup(function( event ){\n\t\t$J(window).unbind('mousemove.scroll');\n\t\tevent.stopPropagation();\n\t});\n\n\t// Resets scroll position to 0 and updates the window. Useful when adding/removing elements or resizing the scroll area\n\tthis.Reset = function() {\n\t\tinstance.m_flPercent = 0;\n\n\t\treturn funcUpdate(true);\n\t};\n\n\t// Ensures target element is visible. This is taken from position() (NOT OFFSET) so the element must be a direct child of the scroll area\n\tthis.EnsureVisible = function( ele ) {\n\t\tvar $ele = $J(ele);\n\t\tvar eleSize = $ele[propOuterSize](true);\n\t\tvar minEdge = $ele.position()[propOffset] - (eleSize * 0.5);\n\t\tvar maxEdge = minEdge + (eleSize * 2);\n\n\n\t\tvar viewportMax = instance.m_eleTarget[propOuterSize]() - instance.m_eleTarget.parent()[propSize]();\n\t\tvar viewportSize = instance.m_eleTarget.parent()[propSize]();\n\t\tvar viewportPosition = instance.m_eleTarget.position()[propOffset] * -1;\n\n\t\tif( viewportPosition > minEdge )\n\t\t\tinstance.m_flPercent = minEdge / viewportMax;\n\t\telse if( ( viewportPosition + viewportSize ) < maxEdge )\n\t\t\tinstance.m_flPercent = ( maxEdge - viewportSize ) / viewportMax;\n\n\t\treturn funcUpdate();\n\t};\n\n\tthis.EnableTransitions = function() {\n\t\tinstance.m_eleTarget.addClass('animating');\n\t};\n\n\tthis.DisableTransitions = function() {\n\t\tinstance.m_eleTarget.removeClass('animating');\n\t};\n\n\tfuncUpdate(true);\n\n\n};\n\nfunction InitAutoComplete( elInput, fnSearch, fnOnChange )\n{\n\treturn new CAutoComplete( elInput, fnSearch, fnOnChange );\n}\n\nfunction CAutoComplete( elInput, fnSearch, fnOnChange )\n{\n\tthis.m_bSuppresseNextKeyUp = false;\n\tthis.m_hSearchTimeout = 0;\n\tthis.m_strLastSearch = '';\n\n\tthis.m_$Input = $J( elInput );\n\tthis.m_fnSearch = fnSearch;\n\tthis.m_fnOnChange = fnOnChange;\n\n\t\tvar strName = this.m_$Input.attr( 'name' );\n\tif ( !strName )\n\t\tstrName = 'unknown';\n\n\tstrName = strName + '_autocomplete';\n\n\tthis.m_$Popup = $J ( '<div class=\"' + strName + '\"></div>' );\n\tthis.m_$Popup.css( 'width', this.m_$Input.outerWidth() + 'px' );\n\tthis.m_$Input.after( this.m_$Popup );\n\tthis.m_$Popup.hide();\n\n\tvar _this = this;\n\tthis.m_$Input.on( 'keydown.autocomplete', function( event ) { _this.OnInputKeyDown( event ); } );\n\tthis.m_$Input.on( 'keyup.autocomplete', function( event ) { _this.OnInputKeyUp( event ); } );\n\tthis.m_$Input.on( 'blur.autocomplete', function( event ) { _this.OnInputBlur( event ); } );\n\tthis.m_$Input.on( 'change input paste', function( event ) { _this.OnInputChange( event ); } );\n\n\tthis.m_$Popup.on( 'mousedown.autocomplete', function( event ) { _this.m_$Popup.data( 'mousedown', true ); } );\n\tthis.m_$Popup.on( 'mouseup.autocomplete', function( event ) { _this.m_$Popup.data( 'mousedown', false ); } );\n}\n\nCAutoComplete.KEY_ENTER = 13;\nCAutoComplete.KEY_UP = 38;\nCAutoComplete.KEY_DOWN = 40;\n\nCAutoComplete.prototype.OnInputChange = function( event )\n{\n\t\tif ( this.m_fnOnChange )\n\t\tthis.m_fnOnChange( this.m_$Input, null );\n\n\tif ( this.m_hSearchTimeout == 0 )\n\t{\n\t\tvar _this = this;\n\t\tvar fnDoSearch = function()\n\t\t{\n\t\t\t_this.m_hSearchTimeout = 0;\n\t\t\tvar strSearch = _this.m_$Input.val();\n\t\t\tif ( strSearch == _this.m_strLastSearch )\n\t\t\t\treturn;\n\n\t\t\t_this.m_strLastSearch = strSearch;\n\t\t\t_this.m_fnSearch( _this.m_$Input, strSearch, function( $Contents ) { _this.SetPopupContents( $Contents ); } );\n\t\t};\n\n\t\tthis.m_hSearchTimeout = window.setTimeout( fnDoSearch, 300 );\n\t}\n}\n\nCAutoComplete.prototype.SetPopupContents = function( $Contents )\n{\n\tif ( !$Contents )\n\t{\n\t\tthis.ClosePopup();\n\t\treturn;\n\t}\n\n\tthis.m_$Popup.html( '' );\n\tthis.m_$Popup.append( $Contents );\n\n\tvar _this = this;\n\tthis.m_$Popup.children().on( 'click.autocomplete', function( event ) { _this.SelectSuggestion( $J( this ) ); } );\n\tthis.m_$Popup.show();\n}\n\nCAutoComplete.prototype.OnInputBlur = function( event )\n{\n\tif ( !this.m_$Popup.data( 'mousedown' ) )\n\t\tthis.ClosePopup();\n}\n\nCAutoComplete.prototype.SelectSuggestion = function( $Suggestion )\n{\n\tif ( $Suggestion.length == 0 )\n\t\treturn;\n\n\tthis.m_$Input.val( $Suggestion.data( 'suggestion' ) );\n\tif ( this.m_fnOnChange )\n\t\tthis.m_fnOnChange( this.m_$Input, $Suggestion );\n\n\tthis.ClosePopup();\n\tthis.m_$Input.focus();\n}\n\nCAutoComplete.prototype.ClosePopup = function()\n{\n\tif ( this.m_hSearchTimeout != 0 )\n\t{\n\t\twindow.clearTimeout( this.m_hSearchTimeout );\n\t\tthis.m_hSearchTimeout = 0;\n\t}\n\n\tthis.m_strLastSearch = '';\n\tthis.m_$Popup.hide();\n}\n\nCAutoComplete.prototype.OnInputKeyDown = function( event )\n{\n\tvar $CurSuggestion = this.m_$Popup.children('.focus');\n\tvar $NewSuggestion = $J();\n\n\tif ( event.keyCode == CAutoComplete.KEY_ENTER )\n\t{\n\t\tthis.SelectSuggestion( $CurSuggestion );\n\t\tthis.m_bSuppressNextKeyUp = true;\n\t\tevent.preventDefault();\n\t\treturn;\n\t}\n\n\tif ( event.keyCode == CAutoComplete.KEY_UP || event.keyCode == CAutoComplete.KEY_DOWN )\n\t{\n\t\tif ( event.keyCode == CAutoComplete.KEY_UP )\n\t\t{\n\t\t\tif ( $CurSuggestion.length )\n\t\t\t\t$NewSuggestion = $CurSuggestion.prev();\n\t\t\tif ( !$NewSuggestion.length )\n\t\t\t\t$NewSuggestion = this.m_$Popup.children( 'div:last-child' );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ( $CurSuggestion.length )\n\t\t\t\t$NewSuggestion = $CurSuggestion.next();\n\t\t\tif ( !$NewSuggestion.length )\n\t\t\t\t$NewSuggestion = this.m_$Popup.children( 'div:first-child' );\n\t\t}\n\n\t\tif ( $NewSuggestion.length  )\n\t\t{\n\t\t\t$CurSuggestion.removeClass( 'focus' );\n\t\t\t$NewSuggestion.addClass( 'focus' );\n\t\t}\n\n\t\t\t\tevent.preventDefault();\n\t}\n}\n\nCAutoComplete.prototype.OnInputKeyUp = function( event )\n{\n\tif ( this.m_bSuppressNextKeyUp && event.keyCode == CAutoComplete.KEY_ENTER )\n\t{\n\t\tthis.m_bSuppressNextKeyUp = false;\n\t\tevent.preventDefault();\n\t}\n}\n\n\n\nfunction GetCurrentScrollPercentage()\n{\n\tvar s = $J(window).scrollTop();\n\tvar d = $J(document).height();\n\tvar c = $J(window).height();\n\tvar scrollPercent = (s / (d-c)) * 100;\n\treturn scrollPercent;\n}\n\n// @elemID id of the element\n// @fixedOffsetTop offset from the top when fixed\n// @bScrollWithPageIfTooTall if the element is taller than the page, then it will \"scroll\" with the page if this is true\n// @docHeightOffset if bScrollWithPageIfTooTall is set to true, then this is how much the document height is reduced by (recommend this to be 130 for the typical footer)\nfunction FixedElementOnScrollWrapper ( elemID, fixedOffsetTop, bScrollWithPageIfTooTall, docHeightOffset, params )\n{\n\tparams = $J.extend( {\n\t\tfixedClass: null\n\t}, params );\n\n\tthis.fixedElement = $( elemID );\n\tthis.$FixedElement = $JFromIDOrElement( elemID );\n\tthis.fixedOffsetTop = typeof fixedOffsetTop != \"undefined\" ? fixedOffsetTop : 0;\n\tthis.bScrollWithPageIfTooTall = typeof bScrollWithPageIfTooTall != \"undefined\" ? bScrollWithPageIfTooTall : false;\n\tthis.docHeightOffset = typeof docHeightOffset != \"undefined\" ? docHeightOffset : 0;\n\tthis.homePosn = { x: this.fixedElement.cumulativeOffset()[0], y: this.fixedElement.cumulativeOffset()[1] };\n\tthis.fixedClass = params.fixedClass;\n\n\n\tthis.$FixedElementPadding = $J('<div/>', {'class': 'FixedElementOnScrollWrapper_padding', 'id': 'ScrollWrapperPadding_' + elemID } ).hide();\n\tthis.fixedElement.insert( { before: this.$FixedElementPadding[0] } );\n\n\tvar _this = this;\n\t$J(window).on( 'scroll.FixedElementOnScrollWrapper hashchange.FixedElementOnScrollWrapper', function() { _this.handleScroll() } );\n\t$J(window).on( 'resize.FixedElementOnScrollWrapper', function() { _this.handleScroll( true /* force recalc */ ) } );\n\tthis.handleScroll();\n}\n\nFixedElementOnScrollWrapper.prototype.BIsFixed = function()\n{\n\tif ( this.fixedClass )\n\t\treturn this.$FixedElement.hasClass( this.fixedClass );\n\telse\n\t\treturn this.$FixedElement.css( 'position' ) == 'fixed';\n}\n\nFixedElementOnScrollWrapper.prototype.handleScroll = function( bForceRecalc )\n{\n\tthis.scrollOffset = document.viewport.getScrollOffsets().top;\n\tvar offsetTop = this.fixedOffsetTop + GetResponsiveHeaderFixedOffsetAdjustment();\n\n\tif ( bForceRecalc && !this.BIsFixed() )\n\t\tthis.homePosn = { x: this.fixedElement.cumulativeOffset()[0], y: this.fixedElement.cumulativeOffset()[1] };\n\n\tif ( this.scrollOffset > ( this.homePosn.y - offsetTop ) )\n\t{\n\t\tif ( !this.BIsFixed() || bForceRecalc )\n\t\t{\n\t\t\tif ( this.fixedClass )\n\t\t\t\tthis.$FixedElement.addClass( this.fixedClass );\n\t\t\telse\n\t\t\t\tthis.$FixedElement.css( 'position', 'fixed' );\n\n\t\t\tthis.fixedElement.style.top = offsetTop + 'px';\n\t\t\tthis.fixedElement.style.left = this.homePosn.x;\n\n\t\t\t// jquery show() sets display to block, which prevents css from hiding this element if needed.\n\t\t\tthis.$FixedElementPadding.css( 'display', '' );\n\t\t\tthis.$FixedElementPadding.css( 'height', this.fixedElement.getHeight() + 'px' );\n\t\t}\n\n\t\tif ( this.bScrollWithPageIfTooTall )\n\t\t{\n\t\t\t// this forces the element to scroll off the page, but there's enough that isn't on the page, \"scroll\" this guy percentage-wise\n\t\t\tvar elemHeight = this.fixedElement.getHeight() + offsetTop;\n\t\t\tif ( elemHeight > document.viewport.getHeight() )\n\t\t\t{\n\t\t\t\tvar currentScrollPercentage = GetCurrentScrollPercentage();\n\t\t\t\tvar heightDiff = elemHeight - ( document.viewport.getHeight() - this.docHeightOffset );\n\t\t\t\toffsetTop -= Math.floor( heightDiff * currentScrollPercentage / 100 );\n\t\t\t\tthis.fixedElement.style.top = offsetTop + 'px';\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif ( this.BIsFixed() )\n\t\t{\n\t\t\tif ( this.fixedClass )\n\t\t\t\tthis.$FixedElement.removeClass( this.fixedClass );\n\t\t\telse\n\t\t\t\tthis.$FixedElement.css( 'position', '' );\n\n\t\t\tthis.$FixedElement.css( 'top', '' ).css( 'left', '' );\n\t\t\tthis.$FixedElementPadding.css( 'display', 'none' );\n\t\t}\n\t}\n}\n\n// general text suggestion control\n\n// fnSuggestForTerm will be called with two values, the current string to get suggestions for,\n//\tand the callback to invoke with the new values.  You should always invoke the callback per call\n//\tto fnSuggestForTerm, but can delay due to ajax if needed.\nfunction CTextInputSuggest( $InputElement, fnSuggestForTerm, fnOnSuggest, strCssClass )\n{\n\tthis.Init( $InputElement, fnSuggestForTerm, fnOnSuggest, strCssClass );\n}\n\nCTextInputSuggest.prototype.Init = function( $InputElement, fnSuggestForTerm, fnOnSuggest, strCssClass )\n{\n\tif( !strCssClass )\n\t\tstrCssClass = 'popup_block_new';\n\tthis.m_bHaveSuggestions = false;\n\tthis.m_$Input = $InputElement;\n\tthis.m_fnSuggestForTerm = fnSuggestForTerm;\n\tthis.m_fnOnSuggest = fnOnSuggest || function( term ) {};\n\tthis.m_strLastVal = '';\n\tthis.m_align = 'left';\n\tthis.m_valign = 'bottom';\n\n\tthis.m_$Focus = $J();\n\tthis.m_strLastFocusVal = null;\n\n\tthis.m_nNextRequestID = 1;\n\tthis.m_nRequestIDRecvd = 0;\n\n\n\tthis.m_$SuggestionsCtn = $J('<div/>', {'class': strCssClass, style: 'display: none;' } );\n\tthis.m_$Suggestions = $J('<div/>', {'class': 'popup_body popup_menu' } );\n\tthis.m_$SuggestionsCtn.append( this.m_$Suggestions );\n\n\tthis.m_$SuggestionsCtn.hide();\n\t$J(document.body).append( this.m_$SuggestionsCtn );\n\n\tvar zIndex = 200;\t//normal popup zindex\n\tthis.m_$Input.parents().each( function() {\n\t\tvar zIndexParent = $J(this).css('zIndex');\n\t\tif ( zIndexParent != 'auto' && zIndexParent != 0 )\n\t\t{\n\t\t\tzIndex = zIndexParent;\n\t\t}\n\t});\n\tthis.m_$SuggestionsCtn.css( 'zIndex', zIndex + 20 );\n\n\tvar _this = this;\n\tthis.m_$Input.on( 'keyup.CTextInputSuggest click.CTextInputSuggest', function( event ) { _this.OnTextChanged( event ) } );\n\tthis.m_$Input.on( 'paste.CTextInputSuggest cut.CTextInputSuggest', function() { window.setTimeout( function() { _this.OnTextChanged() }, 1 ); } );\n\tthis.m_$Input.on( 'keydown.CTextInputSuggest', function( event ) { _this.OnKeyDown( event ) } );\n\tthis.m_$Input.on( 'focus.CTextInputSuggest', function() { _this.ShowSuggestions() } );\n\tthis.m_$Input.on( 'blur.CTextInputSuggest', function() { _this.HideSuggestions() } );\n}\n\nCTextInputSuggest.prototype.SetAlignment = function( align, valign )\n{\n\tthis.m_align = align || 'left';\n\tthis.m_valign = valign || 'bottom';\n};\n\nCTextInputSuggest.prototype.SetSuggestionsContainerId = function( strSuggestionsCtnId )\n{\n\tthis.m_$SuggestionsCtn.attr( 'id', strSuggestionsCtnId );\n};\n\nCTextInputSuggest.prototype.ShowSuggestions = function()\n{\n\tif ( !this.m_$SuggestionsCtn.find(':visible').length && this.m_bHaveSuggestions )\n\t{\n\t\tAlignMenu( this.m_$Input[0], this.m_$SuggestionsCtn[0], this.m_align, this.m_valign, true );\n\t\tthis.m_$SuggestionsCtn.fadeIn( 'fast' );\n\t}\n};\n\nCTextInputSuggest.prototype.HideSuggestions = function()\n{\n\tif ( this.m_bHaveSuggestions )\n\t\tthis.m_$SuggestionsCtn.fadeOut( 'fast' );\n\telse\n\t\tthis.m_$SuggestionsCtn.hide();\n};\n\nCTextInputSuggest.prototype.OnSuggestionSelected = function( $Suggestion )\n{\n\tthis.m_$Input.val( $Suggestion.text() );\n\n\tthis.m_bHaveSuggestions = false;\n\tthis.m_$Focus = $J();\n\tthis.HideSuggestions();\n\n\tthis.m_fnOnSuggest( $Suggestion.text() );\n};\n\nCTextInputSuggest.prototype.SetSuggestions = function( rgSuggestions )\n{\n\tvar strLastFocus = this.m_strLastFocusVal;\n\n\tthis.m_$Suggestions.empty();\n\n\tthis.m_$Focus = $J();\n\tthis.m_strLastFocus = null;\n\n\tif ( rgSuggestions && rgSuggestions.length )\n\t{\n\t\tvar _this = this;\n\t\tfor ( var i = 0; i < rgSuggestions.length; i++ )\n\t\t{\n\t\t\tvar $Suggestion = $J('<div/>', {'class': 'suggestion_item popup_menu_item' } );\n\t\t\t$Suggestion.text( rgSuggestions[i] );\n\t\t\t$Suggestion.click( $J.proxy( this.OnSuggestionSelected, this, $Suggestion ) );\n\t\t\t$Suggestion.mouseenter( $J.proxy( this.SetFocus, this, $Suggestion ) );\n\n\t\t\tthis.m_$Suggestions.append( $Suggestion );\n\n\t\t\tif ( rgSuggestions[i] == strLastFocus )\n\t\t\t\tthis.SetFocus( $Suggestion );\n\t\t}\n\t\tthis.m_bHaveSuggestions = true;\n\t\tthis.ShowSuggestions();\n\t}\n\telse\n\t{\n\t\tthis.m_bHaveSuggestions = false;\n\t\tthis.HideSuggestions();\n\t}\n};\n\nCTextInputSuggest.prototype.OnTextChanged = function( event )\n{\n\tif ( event && ( event.which == 13 || event.which == 27 ) )\n\t\treturn;\n\n\tvar value = this.m_$Input.val();\n\tif ( value != this.m_strLastVal )\n\t{\n\t\tvar _this = this;\n\t\tvar nRequestID = this.m_nNextRequestID++;\n\t\tthis.m_fnSuggestForTerm( value, function( rgSuggestions ) {\n\t\t\t// we've already recieved a more recent response, this is out-of-order\n\t\t\tif ( _this.m_nRequestIDRecvd > nRequestID )\n\t\t\t\treturn;\n\n\t\t\t_this.m_nRequestIDRecvd = nRequestID;\n\t\t\t_this.SetSuggestions( rgSuggestions );\n\t\t} );\n\n\t\tthis.m_strLastVal = value;\n\t}\n};\n\nCTextInputSuggest.prototype.OnKeyDown = function( event )\n{\n\tif ( event.which == 27 )\n\t{\n\t\tthis.HideSuggestions();\n\t}\n\telse if ( this.m_bHaveSuggestions )\n\t{\n\t\tvar $NewSuggestion = null;\n\t\tif ( event.which == 13 )\n\t\t{\n\t\t\tif ( this.m_$Focus.length && this.m_bHaveSuggestions )\n\t\t\t{\n\t\t\t\tthis.OnSuggestionSelected( this.m_$Focus );\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\t\telse if ( event.which == 38 /* up arrow */ )\n\t\t{\n\t\t\tevent.preventDefault();\n\t\t\tif ( this.m_$Focus.length )\n\t\t\t\t$NewSuggestion = this.m_$Focus.prev();\n\t\t\tif ( !$NewSuggestion )\n\t\t\t\t$NewSuggestion = this.m_$Suggestions.children().last();\n\t\t}\n\t\telse if ( event.which == 40 /* down arrow */ )\n\t\t\t{\n\t\t\t\tevent.preventDefault();\n\t\t\t\tif ( this.m_$Focus.length )\n\t\t\t\t\t$NewSuggestion = this.m_$Focus.next();\n\t\t\t\tif ( !$NewSuggestion )\n\t\t\t\t\t$NewSuggestion = this.m_$Suggestions.children().first();\n\t\t\t}\n\n\t\tif ( $NewSuggestion )\n\t\t\tthis.SetFocus( $NewSuggestion );\n\t}\n};\n\nCTextInputSuggest.prototype.SetFocus = function( $Suggestion )\n{\n\tthis.m_$Focus.removeClass( 'focus' );\n\tthis.m_$Focus = $Suggestion;\n\tthis.m_$Focus.addClass( 'focus' );\n\tthis.m_strLastFocusVal = $Suggestion.text();\n};\n\nCTextInputSuggest.prototype.Destroy = function()\n{\n\tthis.m_$SuggestionsCtn.remove();\n\tthis.m_$Input.off( '.CTextInputSuggest' );\n};\n\n/**\n * Similar to CTextInputSuggest, but uses associative arrays instead of just text; useful for when we may have more than one\n * item with the same text name, or when you want to use HTML in the item name instead of just plaintext\n *\n * Each suggestion should include a 'key', and one of the following:\n * text - Suggestion text (escaped, sets textContents)\n * html - Raw suggestion html (NOT ESCAPED, sets innerHTML)\n *\n * @param $InputElement\n * @param fnSuggestForTerm\n * @param fnOnSuggest\n * @constructor\n */\nfunction CIndexedInputSuggest( $InputElement, fnSuggestForTerm, fnOnSuggest, strCssClass )\n{\n\tthis.Init( $InputElement, fnSuggestForTerm, fnOnSuggest, strCssClass );\n}\n\nCIndexedInputSuggest.prototype = Object.create(CTextInputSuggest.prototype);;\n\nCIndexedInputSuggest.prototype.OnSuggestionSelected = function( $Suggestion )\n{\n\tthis.m_$Input.val( $Suggestion.text() );\n\n\tthis.m_bHaveSuggestions = false;\n\tthis.m_$Focus = $J();\n\tthis.HideSuggestions();\n\n\tthis.m_fnOnSuggest( $Suggestion.data('suggest-key'), $Suggestion.text() );\n};\n\nCIndexedInputSuggest.prototype.SetSuggestions = function( rgSuggestions )\n{\n\tvar strLastFocus = this.m_strLastFocusVal;\n\n\tthis.m_$Suggestions.empty();\n\n\tthis.m_$Focus = $J();\n\tthis.m_strLastFocus = null;\n\n\tif ( rgSuggestions && rgSuggestions.length )\n\t{\n\t\tvar _this = this;\n\t\tfor ( var i = 0; i < rgSuggestions.length; i++ )\n\t\t{\n\n\t\t\tvar $Suggestion = $J('<div/>', {'class': 'suggestion_item popup_menu_item' } );\n\t\t\tif( rgSuggestions[i].text )\n\t\t\t\t$Suggestion.text( rgSuggestions[i].text );\n\t\t\telse if( rgSuggestions[i].html )\n\t\t\t\t$Suggestion.html( rgSuggestions[i].html );\n\n\t\t\t$Suggestion.data('suggest-key', rgSuggestions[i].key )\n\n\t\t\t$Suggestion.click( $J.proxy( this.OnSuggestionSelected, this, $Suggestion ) );\n\t\t\t$Suggestion.mouseenter( $J.proxy( this.SetFocus, this, $Suggestion ) );\n\n\t\t\tthis.m_$Suggestions.append( $Suggestion );\n\n\t\t\tif ( rgSuggestions[i] == strLastFocus )\n\t\t\t\tthis.SetFocus( $Suggestion );\n\t\t}\n\t\tthis.m_bHaveSuggestions = true;\n\t\tthis.ShowSuggestions();\n\t}\n\telse\n\t{\n\t\tthis.m_bHaveSuggestions = false;\n\t\tthis.HideSuggestions();\n\t}\n};\n\n\n/**\n * Similar to CTextInputSuggest, but applies styling using the app_type value of each suggestion\n *\n * Each suggestion should include the suggestion text, and the app_type\n *\n * @param $InputElement\n * @param fnSuggestForTerm\n * @param fnOnSuggest\n * @constructor\n */\nfunction CAppTypeInputSuggest( $InputElement, fnSuggestForTerm, fnOnSuggest, strCssClass )\n{\n\tthis.Init( $InputElement, fnSuggestForTerm, fnOnSuggest, strCssClass );\n}\n\nCAppTypeInputSuggest.prototype = Object.create( CTextInputSuggest.prototype );\n\nCAppTypeInputSuggest.prototype.SetSuggestions = function( rgSuggestions )\n{\n\tvar strLastFocus = this.m_strLastFocusVal;\n\n\tthis.m_$Suggestions.empty();\n\n\tthis.m_$Focus = $J();\n\tthis.m_strLastFocus = null;\n\n\tif ( rgSuggestions && rgSuggestions.length )\n\t{\n\t\tvar _this = this;\n\t\tfor ( var i = 0; i < rgSuggestions.length; i++ )\n\t\t{\n\t\t\tvar $class = 'suggestion_item popup_menu_item';\n\t\t\tvar $suggestionText = rgSuggestions[i][0];\n\n\t\t\tif ( typeof rgSuggestions[i][1] !== 'undefined' )\n\t\t\t{\n\t\t\t\tswitch ( parseInt( rgSuggestions[i][1] ) )\n\t\t\t\t{\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t$class += ' app_Game';\n\t\t\t\t\t\t$suggestionText = '[Game] ' + $suggestionText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t$suggestionText = '[App] ' + $suggestionText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\t$suggestionText = '[Tool] ' + $suggestionText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\t$class += ' app_Demo';\n\t\t\t\t\t\t$suggestionText = '[Demo] ' + $suggestionText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\t$suggestionText = '[Media] ' + $suggestionText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\t$class += ' app_DLC';\n\t\t\t\t\t\t$suggestionText = '[DLC] ' + $suggestionText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 256:\n\t\t\t\t\t\t$suggestionText = '[Config] ' + $suggestionText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2048:\n\t\t\t\t\t\t$class += ' app_Movie';\n\t\t\t\t\t\t$suggestionText = '[Video] ' + $suggestionText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8192:\n\t\t\t\t\t\t$class += ' app_Music';\n\t\t\t\t\t\t$suggestionText = '[Music] ' + $suggestionText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 65536:\n\t\t\t\t\t\t$class += ' app_Beta';\n\t\t\t\t\t\t$suggestionText = '[Beta] ' + $suggestionText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar $Suggestion = $J('<div/>', {'class': $class } );\n\t\t\t$Suggestion.text( $suggestionText );\n\n\t\t\t$Suggestion.click( $J.proxy( this.OnSuggestionSelected, this, $Suggestion ) );\n\t\t\t$Suggestion.mouseenter( $J.proxy( this.SetFocus, this, $Suggestion ) );\n\n\t\t\tthis.m_$Suggestions.append( $Suggestion );\n\n\t\t\tif ( rgSuggestions[i] == strLastFocus )\n\t\t\t\tthis.SetFocus( $Suggestion );\n\t\t}\n\t\tthis.m_bHaveSuggestions = true;\n\t\tthis.ShowSuggestions();\n\t}\n\telse\n\t{\n\t\tthis.m_bHaveSuggestions = false;\n\t\tthis.HideSuggestions();\n\t}\n};\n\n\nfunction InitBBCodeVideos( bAllowAutoPlay )\n{\n\tvar videos = $J( \"video\" );\n\tif ( videos.length != 0 )\n\t{\n\t\tfor ( var i = 0; i < videos.length; ++i )\n\t\t{\n\t\t\tvar video = videos[i];\n\t\t\tvar $video = $J( video );\n\n\t\t\tif ( $video.hasClass(\"bb_video_loop\") )\n\t\t\t{\n\t\t\t\tvideo.setAttribute('loop', 'loop');\n\t\t\t}\n\n\t\t\tif ( $video.hasClass(\"bb_video_controls\") )\n\t\t\t{\n\t\t\t\tvideo.setAttribute( 'controls', 'controls' );\n\t\t\t}\n\n\t\t\tif ( bAllowAutoPlay )\n\t\t\t{\n\t\t\t\t$video.unbind('mouseenter mouseleave');\n\n\t\t\t\tvideo.preload = $video.hasClass(\"bb_video_preload\") ? 'auto' : 'metadata';\n\n\t\t\t\tif ( $video.hasClass(\"bb_video_autoplay\") )\n\t\t\t\t{\n\t\t\t\t\tvideo.autoplay = 'autoplay';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvideo.preload = 'metadata';\n\t\t\t\t$video.hover( function toggleControls() {\n\t\t\t\t\tif ( this.hasAttribute(\"controls\") ) {\n\t\t\t\t\t\tthis.removeAttribute(\"controls\")\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.setAttribute(\"controls\", \"controls\")\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/**\n * Generic interface for handling ajax-driven sub-pages.\n *\n * @param elTarget Element to dump content into\n * @param strBaseURL Base URL to attach nav params\n * @param strInstanceId Unique flag to look for when scanning for state change events. also determines our data selector\n * \t\t\t\t\t\tOnly needed if you're using more than one CAjaxSubPageController on the same page.\n * @param strDefaultLocation Used when no navid is provided\n * @constructor\n */\nvar CAjaxSubPageController = function( elTarget, strBaseURL, strInstanceId, strDefaultLocation )\n{\n\tthis.elTarget = elTarget;\n\tthis.strBaseURL = strBaseURL;\n\tthis.strStateID = strInstanceId || 'navid';\n\tthis.strDefaultLocation = strDefaultLocation || '';\n\n\tthis.rgOriginalEvent = {'html':this.elTarget.innerHTML,'title':document.title, 'id': this.strStateID};\n\n\twindow.addEventListener('popstate', this.OnWindowPopState.bind(this));\n\n\tthis.InstrumentLinks( document );\n\n\tvar _this = this;\n\tsetTimeout( function(){ $J(_this.elTarget).children().trigger('load'); }, 1);\n\n\tvar strLocation =  window.location.href.substring(strBaseURL.length);\n\tthis.PaintLinks(strLocation || this.strDefaultLocation);\n\n\n};\n\n/**\n * Register click handlers. This also sets the href for browser link preview and fallback for non-click navigation\n * events, such as opening in a new tab/window via middle click.\n * @param elTarget Element to query from.\n * @constructor\n */\nCAjaxSubPageController.prototype.InstrumentLinks = function( elTarget )\n{\n\t//var rgLinks = elTarget.querySelectorAll('[data-'+this.strStateID+']');\n\tvar rgLinks = $J('[data-'+this.strStateID+']', elTarget);\n\tfor( var i=0; i<rgLinks.length; i++)\n\t{\n\t\trgLinks[i].addEventListener('click', this.Navigate.bind(this, rgLinks[i].dataset[ this.strStateID ], rgLinks[i].dataset[ 'title' ] ) );\n\t\trgLinks[i].href = this.strBaseURL + rgLinks[i].dataset[ this.strStateID ];\n\t}\n};\n\n/**\n * Adds 'active' class to link that was clicked or is currently active.\n * @constructor\n */\nCAjaxSubPageController.prototype.PaintLinks = function( strLocation )\n{\n\t// Figure out which link we clicked and paint it with the correct class\n\tvar rgLinks = document.querySelectorAll('[data-'+this.strStateID+']');\n\tfor( var i=0; i<rgLinks.length; i++)\n\t{\n\t\tif( rgLinks[i].dataset[ this.strStateID ] == strLocation || rgLinks[i].dataset[ this.strStateID ] + '/' == strLocation )\n\t\t\trgLinks[i].classList.add('active');\n\t\telse\n\t\t\trgLinks[i].classList.remove('active');\n\t}\n};\n\n/**\n * Call to navigate the sub-frame.\n *\n * @param strLocation Assumed to be strBaseURL + strLocation. Trailing slash should be on strBaseURL already.\n * @param strpageTitle Optional: Replace page title with this new value.\n * @constructor\n */\nCAjaxSubPageController.prototype.Navigate = function( strLocation, strPageTitle, event )\n{\n\tvar _this = this;\n\tvar strURL = this.strBaseURL + strLocation;\n\n\tthis.elTarget.classList.add('loading');\n\n\tthis.PaintLinks( strLocation );\n\n\t// Trigger the \"saveform\" event which we may have bound to do things.\n\t$J( 'form', this.elTarget ).trigger('saveform');\n\n\t$J.ajax({\n\t\turl: strURL,\n\t\tdataType: \"html\",\n\t\tcache: true, /* Let the browser decide caching rules */\n\t\tdata: { 'ajax': 1 }\n\t}).done(function( result ) {\n\n\t\tvar elNewContents = $J( result );\n\n\t\t$J(_this.elTarget).empty();\n\t\t$J(_this.elTarget).append( elNewContents );\n\n\n\t\t_this.elTarget.classList.remove('loading');\n\n\t\t$J( elNewContents ).trigger('load');\n\n\t\t_this.InstrumentLinks( _this.elTarget );\n\t\tif( strPageTitle )\n\t\t\tdocument.title = strPageTitle;\n\n\t\t$J('.tooltip', _this.elTarget).v_tooltip();\n\n\t\twindow.history.pushState({'html':result,'title':strPageTitle, 'id': _this.strStateID}, '', strURL );\n\t});\n\n\tif( event )\n\t\tevent.preventDefault();\n\n};\n\n/**\n * Internal event handler for the \"back\" button.\n * @param Event event\n * @constructor\n */\nCAjaxSubPageController.prototype.OnWindowPopState = function( event )\n{\n\t// Revert to our original state if there's nothing in the stack.\n\n\tif(event.state == null)\n\t{\n\t\tevent.state = 5;\n\t}\n\n\tvar state = event.state || this.rgOriginalEvent;\n\n\tif( state && state.id == this.strStateID)\n\t{\n\t\tvar strLocation =  window.location.href.substring(this.strBaseURL.length);\n\t\tthis.PaintLinks( strLocation );\n\n\t\tvar elNewContents = $J(state.html);\n\t\t$J(this.elTarget).empty();\n\t\t$J(this.elTarget).append(elNewContents);\n\t\tif( state.title )\n\t\t\tdocument.title = state.title;\n\n\t\t$J( elNewContents ).trigger('load');\n\t\tthis.InstrumentLinks( elNewContents );\n\t}\n};\n\nfunction SetupAnimateOnHoverImages()\n{\n\tvar $Images = $J( '[data-animate-on-hover-src]', document );\n\tif ( $Images.length )\n\t{\n\t\tfor ( var i = 0; i < $Images.length; ++i )\n\t\t{\n\t\t\tvar img = $J( $Images[i] );\n\t\t\timg.data( 'static-src', img.attr( 'src') );\n\t\t\timg.hover(\n\t\t\t\tfunction() {\n\t\t\t\t\tvar thisImage = $J( this );\n\t\t\t\t\tthisImage.attr( 'src', thisImage.data( 'animate-on-hover-src' ) );\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\tvar thisImage = $J( this );\n\t\t\t\t\tthisImage.attr( 'src', thisImage.data( 'static-src' ) );\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n}\n\nfunction BindTooltips(selector, rgOptions)\n{\n\t// Standard tooltips\n\tvar $TextTooltips = $J( '[data-tooltip-text]', selector);\n\tif ( $TextTooltips.length )\n\t\t$TextTooltips.v_tooltip( { 'tooltipClass': rgOptions.tooltipCSSClass, 'dataName': 'tooltipText', 'defaultType': 'text', 'replaceExisting': false, 'responsiveMode': window.UseSmallScreenMode && window.UseSmallScreenMode() } );\n\n\tvar $HTMLTooltips = $J( '[data-tooltip-html]', selector);\n\tif ( $HTMLTooltips.length )\n\t\t$HTMLTooltips.v_tooltip( { 'tooltipClass': rgOptions.tooltipCSSClass, 'dataName': 'tooltipHtml', 'defaultType': 'html', 'replaceExisting': false, 'responsiveMode': window.UseSmallScreenMode && window.UseSmallScreenMode() } );\n}\n\nfunction ShowTooltipMenuAsPopup( toolDiv )\n{\n\tvar $Popup = $J( toolDiv );\n\t// detach this element and when the dialog closes re-attach to the document body\n\t$Popup.detach();\n\tvar originalPopupPosition = $Popup.css( 'position' );\n\t$Popup.css( 'position', 'static' ); // clear possible absolute positioning\n\t$Popup.show();\n\n\tvar dialog = ShowDialog( '', $Popup ).always(\n\t\tfunction() {\n\t\t\t// save it away again for later\n\t\t\t$Popup.hide();\n\t\t\t$Popup.css( 'position', originalPopupPosition ); // restore positioning\n\t\t\t$J( document.body ).append( $Popup );\n\t\t}\n\t);\n\treturn dialog;\n}\n\n/**\n * Binds standard tooltips for the current site. This function also binds a mutationobserver to bind any future elements without additional work\n * @param strCSSClass\n * @constructor\n */\nvar g_TooltipMutationObserver;\nvar g_bTooltipMutationObserverDisabled = false;\nfunction SetupTooltips( rgOptions )\n{\n\tfunction InnerSetupTooltips() {\n\n        BindTooltips(document, rgOptions);\n\n        if (g_TooltipMutationObserver || g_bTooltipMutationObserverDisabled)\n            return;\n\n        try\n\t\t{\n            var config = {\n                attributes: true,\t// not clear if we actually support this, as we only look at addedNodes\n                childList: true,\n                subtree: true,\n                attributeFilter: [\"data-tooltip-html\", \"data-tooltip-text\"]\n            };\n\n            var callback = function (mutationsList)\n\t\t\t{\n                for (var i = 0; i < mutationsList.length; i++)\n                {\n                    var mutation = mutationsList[i];\n                    if (mutation.addedNodes && mutation.addedNodes.length)\n                        BindTooltips(mutation.addedNodes, rgOptions);\n                }\n            };\n\n            // Create an observer instance linked to the callback function\n            g_TooltipMutationObserver = new MutationObserver(callback);\n\n            // Start observing the target node for configured mutations\n            g_TooltipMutationObserver.observe(document, config);\n        }\n        catch (e)\n\t\t{\n            // Swallow exceptions for browsers that don't support mutationobservers\n        }\n    }\n\n    InnerSetupTooltips();\n    $J( window ).on( 'Responsive_SmallScreenModeToggled', InnerSetupTooltips );\n}\n\n// for perf sensitive pages\nfunction DisableTooltipMutationObserver()\n{\n\tg_bTooltipMutationObserverDisabled = true;\n\n\tif ( g_TooltipMutationObserver )\n\t{\n\t\tg_TooltipMutationObserver.disconnect();\n\t\tg_TooltipMutationObserver = null;\n\t}\n}\n\nfunction ViewTitlesWithDescriptors( descid )\n{\n\tvar waitDialog = ShowBlockingWaitDialog( 'Примеры продуктов', 'Мы ищем примеры продуктов. Пожалуйста, подождите.' );\n\n\t$J.get( 'https://store.steampowered.com/search/results/',\n\t\t{\n\t\t\t'filter' : 'examplesforcontentdescriptors',\n\t\t\t'ignore_preferences' : 1,\n\t\t\t'category1' : '992,994,998', \t\t\t'descids[]' : descid,\n\t\t\t'json' : 1,\n\t\t}\n\t).done( function( response ) {\n\t\twaitDialog.Dismiss();\n\n\t\tvar content = $J( \"<div>\" );\n\t\tcontent.append( $J( \"<div>\", { class: 'content_descriptors_examples_desc', text: response.desc } ) );\n\n\t\tif ( response.items.length != 0 )\n\t\t{\n\t\t\tfor ( var i = 0; i < response.items.length && i < 10; ++i )\n\t\t\t{\n\t\t\t\tvar item = response.items[i];\n\t\t\t\tvar elem = $J( \"<div>\", { class: 'content_descriptors_example_app' } );\n\t\t\t\telem.append( $J( \"<img>\", {  class: 'app_logo', src: item.logo } ) );\n\t\t\t\telem.append( $J( \"<div>\", { class: 'app_name', text: item.name } ) );\n\t\t\t\tcontent.append( elem );\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcontent.append( $J( \"<div>\", { class: \"no_items\", text: 'Продукты не найдены' } ) );\n\t\t}\n\n\t\tvar dialog = ShowAlertDialog( 'Примеры продуктов', content );\n\t} );\n}\n\n\n\n// Element appearance montior. Designed to replace jQuery.appear\n\nvar CAppearMonitor = function( fnOnAppear, bCheckAnyIntersection ){\n\tthis.rgMonitoredElements = [];\n\tthis.bRunning = false;\n\tthis.unTimerFrequency = 500;\n\tthis.bRegisteredWindowEvent = false;\n\tthis.fnOnAppear = fnOnAppear;\n\tthis.bCheckAnyIntersection = bCheckAnyIntersection || false;\n};\n\nCAppearMonitor.prototype.RegisterScrollEvent = function( elTarget )\n{\n\tvar instance = this;\n\n\t$J(elTarget).on('scroll', function()\n\t{\n\t\tif( instance.bRunning || instance.rgMonitoredElements.length == 0 )\n\t\t\treturn;\n\n\t\tinstance.bRunning = true;\n\t\tsetTimeout( instance.CheckVisibilityInternal.bind(instance), instance.unTimerFrequency );\n\n\t});\n}\n\nCAppearMonitor.prototype.CheckVisibility = function()\n{\n\t// when items are added they will schedule an immediate check.  Delay for a bit\n\tif ( this.m_iCheckVisibilityRequestInterval )\n\t{\n\t\twindow.clearTimeout( this.m_iCheckVisibilityRequestInterval );\n\t}\n\n\tthis.m_iCheckVisibilityRequestInterval = setTimeout( this.CheckVisibilityInternal.bind(this), this.unTimerFrequency );\n};\n\nCAppearMonitor.prototype.CheckVisibilityInternal = function()\n{\n\t// Walk backwards so we can slice while we iterate\n\tfor( var i=this.rgMonitoredElements.length-1; i>=0; i--)\n\t{\n\t\tvar rgMonitored = this.rgMonitoredElements[i];\n\t\tif( this.bIsElementVisible( rgMonitored.element ) )\n\t\t{\n\t\t\tthis.rgMonitoredElements.splice(i,1);\n\t\t\tthis.fnOnAppear( rgMonitored.element );\n\t\t} else if( !document.body.contains( rgMonitored.element ) )\n\t\t{\n\t\t\tthis.rgMonitoredElements.splice(i,1);\n\t\t}\n\t}\n\n\tthis.bRunning = false;\n\tthis.m_iCheckVisibilityRequestInterval = undefined;\n};\n\nCAppearMonitor.prototype.bIsElementVisible = function( elElement )\n{\n\tif( !elElement )\n\t\treturn;\n\n\t// Check physical position vs viewport. This is likely the fastest early-out.\n\tvar rectElement = elElement.getBoundingClientRect();\n\n\tif ( this.bCheckAnyIntersection )\n\t{\n\t\tif ( rectElement.left > window.innerWidth || rectElement.right < 0 )\n\t\t\treturn false;\n\n\t\tif ( rectElement.top > window.innerHeight || rectElement.bottom < 0 )\n\t\t\treturn false;\n\t}\n\telse\n\t{\n\t\tif ( !( rectElement.top >= 0 && rectElement.left >= 0\n\t\t\t\t&& rectElement.bottom <= window.innerHeight && rectElement.right <= window.innerWidth ) )\n\t\t\treturn false;\n\t}\n\n\t// Ask jQuery to compute visibility, since it knows all the edge cases.\n\tif( !$J(elElement).is(':visible'))\n\t\treturn false;\n\n\treturn true;\n\n};\n\nCAppearMonitor.prototype.RegisterElement = function( elTarget )\n{\n\tif( $J(elTarget).data('manual-tracking' ) )\n\t\treturn;\n\n\tthis.rgMonitoredElements.push({\n\t\telement: elTarget\n\t});\n\n\t// Register the window scroll event ONLY after we have something to monitor\n\tif( !this.bRegisteredWindowEvent)\n\t\tthis.RegisterScrollEvent( window );\n};\n\nCAppearMonitor.prototype.TrackAppearanceIfVisible = function( elTarget )\n{\n\tvar _this = this;\n\twindow.setTimeout( function() {\n\t\t// Ensure we're actually in the viewport (Carousel may be scrolling out of view and calling this)\n\t\t// this triggers layout, so we delay this check a little bit to give the page time to settle whatever\n\t\t// change may currently be in-flight\n\t\tif( !_this.bIsElementVisible( elTarget ) )\n\t\t\treturn;\n\n\t\t_this.TrackAppearance( elTarget );\n\t}, 10);\n};\n\nCAppearMonitor.prototype.TrackAppearance = function( elTarget )\n{\n\t// Find our element, splice it out if we were tracking it\n\tfor( var i=this.rgMonitoredElements.length-1; i>=0; i--)\n\t{\n\t\tvar rgMonitored = this.rgMonitoredElements[i];\n\t\tif(  rgMonitored.element === elTarget )\n\t\t{\n\t\t\tthis.rgMonitoredElements.splice(i,1);\n\t\t}\n\t}\n\t// Trigger it, even if we weren't actually tracking it\n\tthis.fnOnAppear( elTarget );\n};\n\nCAppearMonitor.prototype.ClearElements = function()\n{\n\tthis.rgMonitoredElements = [];\n}\n\n// gamepad navigation wrappers, the implementations of these are stored in legacy_web.\n// once legacy web initializes, these functions will be replaced by the real thing.  In the mean time,\n// we will queue any commands and send them when ready.\nvar g_rgQueuedGamepadCommands = [];\nvar g_rgOnReadyCallbacks = [];\nvar g_bGamepadNavReady = false;\nfunction RunWhenGamepadNavReady( callback )\n{\n\tif ( g_bGamepadNavReady )\n\t\tcallback();\n\telse\n\t\tg_rgOnReadyCallbacks.push( callback );\n}\nwindow.addEventListener( 'vgp_gamepadnavready', function() {\n\t\tg_rgQueuedGamepadCommands.forEach( function( command ) { window[command.name].apply( window, command.args ); } );\n\tg_rgQueuedGamepadCommands = [];\n\n\tg_rgOnReadyCallbacks.forEach( function( fn ) { fn(); } );\n\tg_rgOnReadyCallbacks = [];\n});\n\nfunction InstrumentFocusElements( element )\n{\n\tg_rgQueuedGamepadCommands.push( { name: 'InstrumentFocusElements', args: arguments } );\n}\nfunction ForceUpdateFocusElements( element )\n{\n\tg_rgQueuedGamepadCommands.push( { name: 'ForceUpdateFocusElements', args: arguments } );\n}\nfunction GPNavFocusChild( element )\n{\n\tg_rgQueuedGamepadCommands.push( { name: 'GPNavFocusChild', args: arguments } );\n}\nfunction GPOnShowingModalWindow( element )\n{\n\tg_rgQueuedGamepadCommands.push( { name: 'GPOnShowingModalWindow', args: arguments } );\n}\nfunction GPShowVirtualKeyboard( bShowKeyboard )\n{\n\tg_rgQueuedGamepadCommands.push( { name: 'GPShowVirtualKeyboard', args: arguments } );\n}\nfunction GPNavUpdateActionDescriptions( element, actionDescriptions )\n{\n\tg_rgQueuedGamepadCommands.push( { name: 'GPNavUpdateActionDescriptions', args: arguments } );\n}\n\nvar SetGPFocusRestoreTimeout = function(){}; // no op unless InitializeGPFocusRestoreTimeout is called\nvar nGPFocusRestoreTimeoutID = -1;\nfunction InitializeGPFocusRestoreTimeout( bUseWindowOnload = true )\n{\n\twindow.history.replaceState( $J.extend( {}, window.history.state, { notify_focus_restore_ready: true } ), \"\" );\n\tSetGPFocusRestoreTimeout = function( delay = 200 )\n\t{\n\t\tif ( nGPFocusRestoreTimeoutID == 0 || ( !window.UseTabletScreenMode || !window.UseTabletScreenMode() ) )\n\t\t\treturn;\n\n\t\tif ( nGPFocusRestoreTimeoutID !== -1 )\n\t\t\twindow.clearTimeout( nGPFocusRestoreTimeoutID );\n\n\t\tthis.nGPFocusRestoreTimeoutID = window.setTimeout( function(){\n\t\t\tnGPFocusRestoreTimeoutID = 0;\n\t\t\tdispatchEvent( new Event( 'focus_restore_ready' ) );\n\t\t}, delay );\n\t}\n\n\tif ( bUseWindowOnload )\n\t\twindow.addEventListener( \"load\", function(){ SetGPFocusRestoreTimeout(); } );\n}\n\nfunction HandleOverlayWindowPinnedView( bPinned, bShowPinnedView )\n{\n\t$J( 'body' ).toggleClass( 'OverlayWindowPinned', bPinned );\n\t$J( 'body' ).toggleClass( 'OverlayWindowPinnedView', bShowPinnedView );\n}\n\nvar g_oReactNativeSetHeader;\nfunction InitReactNativeSetHeaderData( rgInitialReactNativeHeaderData, fnPostData )\n{\n\tg_oReactNativeSetHeader = {\n\t\trgData: rgInitialReactNativeHeaderData,\n\t\tfnPostData: fnPostData\n\t};\n\tUpdateReactNativeClientHeaderData();\n}\n\nfunction SetReactNativeHeaderCartItemCount( nCartItemCount )\n{\n\tif ( !g_oReactNativeSetHeader )\n\t\treturn;\t// not in react native client\n\n\t\tif ( nCartItemCount == g_oReactNativeSetHeader.rgData['cart_item_count'] )\n\t\treturn;\n\n\tif ( nCartItemCount )\n\t\tg_oReactNativeSetHeader.rgData['cart_item_count'] = nCartItemCount;\n\telse\n\t\tdelete g_oReactNativeSetHeader.rgData['cart_item_count'];\n\n\tUpdateReactNativeClientHeaderData();\n}\n\nfunction UpdateReactNativeClientHeaderData()\n{\n\tif ( g_oReactNativeSetHeader )\n\t{\n\t\tg_oReactNativeSetHeader.fnPostData( g_oReactNativeSetHeader.rgData );\n\t}\n}\n\n"
          },
          "redirectURL": "",
          "headersSize": 587,
          "bodySize": 43825
        },
        "cache": {},
        "timings": {
          "blocked": -1,
          "dns": 0,
          "connect": 0,
          "ssl": 0,
          "send": 0,
          "wait": 541,
          "receive": 261
        },
        "time": 802,
        "_securityState": "secure",
        "serverIPAddress": "104.18.42.105",
        "connection": "443",
        "pageref": "page_2"
      },
      {
        "startedDateTime": "2025-01-07T15:17:36.983+07:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "https://store.cloudflare.steamstatic.com/public/javascript/main.js?v=wZOkh5CBgIrx&l=russian&_cdn=cloudflare",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "Host",
              "value": "store.cloudflare.steamstatic.com"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (X11; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "DNT",
              "value": "1"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "no-cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "cross-site"
            },
            {
              "name": "If-Modified-Since",
              "value": "Mon, 20 Apr 1970 06:43:19 GMT"
            },
            {
              "name": "If-None-Match",
              "value": "\"M-Z87xERQLto\""
            },
            {
              "name": "Priority",
              "value": "u=2"
            },
            {
              "name": "TE",
              "value": "trailers"
            }
          ],
          "cookies": [],
          "queryString": [
            {
              "name": "v",
              "value": "wZOkh5CBgIrx"
            },
            {
              "name": "l",
              "value": "russian"
            },
            {
              "name": "_cdn",
              "value": "cloudflare"
            }
          ],
          "headersSize": 513
        },
        "response": {
          "status": 200,
          "statusText": "",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "date",
              "value": "Tue, 07 Jan 2025 08:17:37 GMT"
            },
            {
              "name": "content-type",
              "value": "text/javascript;charset=UTF-8"
            },
            {
              "name": "content-length",
              "value": "23487"
            },
            {
              "name": "cache-control",
              "value": "public,max-age=0,must-revalidate"
            },
            {
              "name": "expires",
              "value": "Sun, 09 Sep 2001 01:46:40 GMT"
            },
            {
              "name": "etag",
              "value": "\"M-Z87xERQLto\""
            },
            {
              "name": "x-integrity",
              "value": "\"sha384-NaoDHbQF5FkzuDAcx8L1tvuC4q+GDvDjwXsgQbuHsOAN1OKn5boC8YhtJALy4DW0\""
            },
            {
              "name": "last-modified",
              "value": "Mon, 20 Apr 1970 06:43:19 GMT"
            },
            {
              "name": "content-encoding",
              "value": "gzip"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=10368000"
            },
            {
              "name": "x-cache",
              "value": "MISS"
            },
            {
              "name": "cf-cache-status",
              "value": "MISS"
            },
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "vary",
              "value": "Accept-Encoding"
            },
            {
              "name": "server",
              "value": "cloudflare"
            },
            {
              "name": "cf-ray",
              "value": "8fe2832e4dee095d-HKG"
            },
            {
              "name": "X-Firefox-Spdy",
              "value": "h2"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "text/javascript; charset=UTF-8",
            "size": 88364,
            "text": "\n//\n// Page-able tabs\n//\nvar tabStart = { };\nvar tabMax = { };\nvar tabTransition = { };\nfunction PageTab( tab, delta, max, params )\n{\n\tif ( tabTransition[tab] )\n\t\treturn;\n\n\tif ( !tabStart[tab] )\n\t\ttabStart[tab] = 0;\n\tif ( !tabMax[tab] )\n\t\ttabMax[tab] = 0;\n\n\tif ( tabStart[tab] + delta >= max )\n\t\treturn;\n\n\ttabStart[tab] += delta;\n\ttabTransition[tab] = true;\n\tif ( tabStart[tab] > tabMax[tab] )\n\t{\n\t\tif ( !params )\n\t\t\tparams = {};\n\t\tparams.tab = tab;\n\t\tparams.start = tabStart[tab];\n\t\tparams.count = delta;\n\t\tnew Ajax.Updater(\n\t\t\t\t'tab_' + tab + '_items',\n\t\t\t\t'https://store.steampowered.com/search/tab',\n\t\t\t\t{ parameters: params, method: 'get', insertion: 'bottom', onComplete: TabCompletionClosure( tab, delta, max ) } );\n\t\ttabMax[tab] = tabStart[tab];\n\t}\n\telse\n\t{\n\t\tRollTab( tab, delta );\n\t\tTabUpdateCounts( tab, delta, max );\n\t}\n\n}\n\nfunction TabCompletionClosure( tab, delta, max )\n{\n\tvar tab_closure = tab;\n\tvar delta_closure = delta;\n\tvar max_closure = max;\n\treturn function() {\n\t\tRollTab( tab_closure, delta_closure );\n\t\tTabUpdateCounts( tab_closure, delta_closure, max_closure );\n\t};\n\n}\n\nfunction RollTab( tab, delta )\n{\n\tif ( $('tab_' + tab + '_items' ).hasClassName( 'twenty_smallcap_page_items' ) )\n\t{\n\t\tvar xdiff = 950;\n\t\tif ( delta > 0 )\n\t\t\txdiff = -xdiff;\n\t\tnew Effect.Move( $('tab_' + tab + '_items'), {x: xdiff, afterFinish: TabScrollFinishClosure( tab, delta ) } );\n\t}\n\telse\n\t{\n\t\t//standard tab\n\t\tvar ydiff = -RowHeightForTab( tab ) * delta;\n\t\tnew Effect.Move( $('tab_' + tab + '_items'), {y: ydiff, afterFinish: TabScrollFinishClosure( tab, delta ) } );\n\t}\n\tvar elTabArea = $('tab_' + tab + '_items').up('.tabarea' );\n\tif ( elTabArea )\n\t\tEffect.ScrollTo( elTabArea, { afterFinish: TabScrollFinishClosure( tab, delta ) } );\n}\n\nfunction TabScrollFinishClosure( tab, delta )\n{\n\tvar tab_closure = tab;\n\tvar delta_closure = delta;\n\treturn function() {\n\t\ttabTransition[tab_closure] = false;\n\t};\n}\n\nfunction TabUpdateCounts( tab, delta, max )\n{\n\tif ( $('tab_' + tab + '_count_start') )\n\t{\n\t\t$('tab_' + tab + '_count_start').update( tabStart[tab] + 1 );\n\t\t$('tab_' + tab + '_count_end').update( Math.min( tabStart[tab] + Math.abs(delta), max ) );\n\t}\n\telse\n\t{\n\t\t$('tab_' + tab + '_count').update( (tabStart[tab] + 1) + '-' + Math.min( tabStart[tab] + Math.abs(delta), max ) );\n\t}\n\tif ( tabStart[tab] > 0 )\n\t\t$('tab_' + tab + '_prev').style.visibility='visible';\n\telse\n\t\t$('tab_' + tab + '_prev').style.visibility='hidden';\n\n\tif ( tabStart[tab] + delta >= max )\n\t\t$('tab_' + tab + '_next').style.visibility='hidden';\n\telse\n\t\t$('tab_' + tab + '_next').style.visibility='visible';\n}\n\nfunction RowHeightForTab( tab )\n{\n\tvar tabRow = $('tab_' + tab + '_items' ).down( '.tab_row' );\n\treturn tabRow.getHeight();\n}\n\nfunction TabSelect( elem, target )\n{\n\t$J('#last_tab').val(target);\n\tvar $Elem = $JFromIDOrElement( elem );\n\t$Elem.siblings().removeClass( 'active' );\n\t$Elem.addClass( 'active' );\n\n\tif( target == \"tab_1_content\" )\n\t\ttarget = GetDefaultTabSelection();\n\n\tvar $Content = $JFromIDOrElement(target);\n\t$Content.siblings().hide();\n\t$Content.show();\n\n\t// Re-compute impression tracking visibility\n\tif ( typeof GDynamicStore != 'undefined' )\n\t{\n\t\tGDynamicStore.s_ImpressionTracker.CheckVisibility();\n\t}\n}\n\nfunction TabSelectStealth( target )\n{\n\tvar tab_content = $(target);\n\ttab_content.siblings().invoke( 'hide' );\n\ttab_content.show();\n\n\tSetDefaultTabSelection( target );\n}\n\nfunction GetDefaultTabSelection()\n{\n\tvar value = WebStorage.GetLocal( 'store_newreleases_filter_dlc' );\n\n\tif( value == null )\n\t\treturn \"tab_filtered_dlc_content\";\n\treturn value;\n}\n\nfunction SetDefaultTabSelection( tab )\n{\n\tWebStorage.SetLocal( 'store_newreleases_filter_dlc', tab );\n}\n\nfunction InitTabDefaults()\n{\n\tTabSelectStealth( GetDefaultTabSelection() );\n}\n\nfunction ScrollSmallCaps( name, delta, pageSize, totalCount, params )\n{\n\tvar targetid = 'sm_cap_' + name + '_scroll';\n\tvar elem = $( targetid );\n\tif ( elem.effect )\n\t\treturn;\n\n\tif ( !elem.curPos )\n\t{\n\t\telem.curPos = 0;\n\t}\n\tif ( !elem.maxLoaded )\n\t{\n\t\telem.maxLoaded = 0;\n\t}\n\n\telem.curPos += delta;\n\n\tif ( elem.curPos > elem.maxLoaded )\n\t{\n\t\telem.effect = true;\n\t\telem.maxLoaded++;\n\t\telem.style.width = ( ( elem.maxLoaded + 2 ) * 614 ) + 'px';\n\n\t\tif ( !params )\n\t\t\tparams = {};\n\t\tparams.name = name;\n\t\tparams.start = elem.curPos * pageSize + pageSize; // we are always loading one page ahead\n\t\tparams.count = pageSize;\n\t\tnew Ajax.Updater(\n\t\t\t\ttargetid,\n\t\t\t\t'https://store.steampowered.com/search/smallcapscroll',\n\t\t\t\t{ parameters: params, method: 'get', insertion: 'bottom', onComplete: UpdateSmallCapControl.bind( window, targetid, delta, pageSize, totalCount ) } );\n\t}\n\telse\n\t{\n\t\tUpdateSmallCapControl( targetid, delta, pageSize, totalCount );\n\t}\n\n}\n\nfunction ScrollStaticSmallCaps( targetid, delta, pageSize, totalCount )\n{\n\tvar elem = $( targetid );\n\tif ( elem.effect )\n\t\treturn;\n\n\tif ( !elem.curPos )\n\t{\n\t\telem.curPos = 0;\n\t}\n\n\telem.curPos += delta;\n\n\tUpdateSmallCapControl( targetid, delta, pageSize, totalCount );\n}\n\nfunction ScrollCarouselSmallCaps( targetid, delta, pageSize, totalCount )\n{\n\tvar elem = $( targetid );\n\tif ( elem.effect )\n\t\treturn;\n\n\tif ( !elem.curPos )\n\t{\n\t\telem.curPos = 0;\n\t}\n\n\telem.curPos += delta;\n\n\tvar max = Math.ceil( totalCount / pageSize ) - 1;\n\n\tvar nextLink = targetid + '_next';\n\tvar prevLink = targetid + '_prev';\n\tif ( elem.curPos >= max )\n\t\t$(nextLink).addClassName('disabled');\n\telse\n\t\t$(nextLink).removeClassName('disabled');\n\n\tif ( elem.curPos <= 0 )\n\t\t$(prevLink).addClassName('disabled');\n\telse\n\t\t$(prevLink).removeClassName('disabled');\n\n\n\tvar cb = function( targetid ) {\n\t\tvar elem = $( targetid );\n\t\telem.effect = false;\n\t\tif ( typeof GDynamicStore != 'undefined' )\n\t\t{\n\t\t\tGDynamicStore.s_ImpressionTracker.CheckVisibility();\n\t\t\tGDynamicStore.HandleCarouselChange( targetid, elem.curPos, pageSize );\n\t\t}\n\t};\n\n\telem.effect = new Effect.Move( elem, {x: -808 * delta, afterFinish: cb.bind( this, targetid ), duration: 0.4 } );\n\n}\n\n\nfunction UpdateSmallCapControl( targetid, delta, pageSize, totalCount )\n{\n\tvar elem = $( targetid );\n\tvar max = Math.ceil( totalCount / pageSize ) - 1;\n\tvar width = $(elem.parentNode).getWidth();\n\n\tvar nextLink = targetid + '_next';\n\tvar prevLink = targetid + '_prev';\n\tif ( elem.curPos >= max )\n\t\t$(nextLink).hide();\n\telse\n\t\t$(nextLink).show();\n\n\tif ( elem.curPos <= 0 )\n\t\t$(prevLink).hide();\n\telse\n\t\t$(prevLink).show();\n\n\tvar pageStart = elem.curPos * pageSize + 1;\n\tvar pageEnd = pageStart + ( pageSize - 1 );\n\tif ( $( targetid + '_page_start' ) )\n\t\t$( targetid + '_page_start' ).update( pageStart );\n\tif ( $( targetid + '_page_end' ) )\n\t\t$( targetid + '_page_end' ).update( Math.min( pageEnd, totalCount ) );\n\n\n\telem.effect = new Effect.Move( elem, {x: -width * delta, afterFinish: function() { elem.effect = false; }, duration: 0.4 } );\n\n}\n\n\nvar g_HoverState = {\n\ttarget: null,\n\thiding: false\n};\n\nfunction GetHoverState( $Elem )\n{\n\tvar oElemState = $Elem.data( 'oHoverState' );\n\tif ( !oElemState )\n\t{\n\t\toElemState = {};\n\t\t$Elem.data( 'oHoverState', oElemState );\n\t}\n\treturn oElemState;\n}\n\nfunction GameHover( elem, event, divHover, rgHoverData )\n{\n\tif (!event) var event = window.event;\n\tvar $Elem = $JFromIDOrElement(elem);\n\tvar $Hover = $JFromIDOrElement(divHover);\n\tvar bNewHoverSpeed = typeof ( g_bNewHoverSpeed) != 'undefined' && g_bNewHoverSpeed;\n\n\tvar oElemState = GetHoverState( $Elem );\n\n\tif ( !$Hover.length )\n\t{\n\t\t\t\t$Hover = $J(\"\\t\\t<div class=\\\"hover game_hover\\\" id=\\\"global_hover\\\" style=\\\"display: none; left: 0; top: 0;\\\">\\n\\t\\t\\t<div class=\\\"game_hover_box hover_box\\\">\\n\\t\\t\\t\\t<div class=\\\"content\\\" id=\\\"global_hover_content\\\">\\n\\t\\t\\t\\t<\\/div>\\n\\t\\t\\t<\\/div>\\n\\t\\t\\t<div class=\\\"hover_arrow_left\\\"><\\/div>\\n\\t\\t\\t<div class=\\\"hover_arrow_right\\\"><\\/div>\\n\\t\\t<\\/div>\");\n\t\t$J(document.body).append( $Hover );\n\t}\n\n\tif ( g_HoverState.hiding && $Hover.is(':visible') && g_HoverState.target == $Elem[0] )\n\t{\n\t\tShowWithFade( $Hover );\n\t}\n\telse if ( ( !$Hover.is(':visible') || g_HoverState.target != $Elem[0] ) && !oElemState.timer )\n\t{\n\t\toElemState.bWantsHover = true;\n\t\tvar accountId = ( typeof g_AccountID !== 'undefined' ) && !rgHoverData['public'] ? g_AccountID : 0;\n\t\tvar bPublic = rgHoverData['public'] || accountId == 0;\n\t\tvar strTargetPrefix = '';\n\t\tvar strUrlTarget = '';\n\t\tif ( rgHoverData['type'] == 'app' )\n\t\t{\n\t\t\tstrTargetPrefix = 'hover_app_';\n\t\t\tstrUrlTarget = ( bPublic ? 'apphoverpublic/' : 'apphover/' ) + rgHoverData['id'];\n\t\t}\n\t\telse if ( rgHoverData['type'] == 'sub' )\n\t\t{\n\t\t\tstrTargetPrefix = 'hover_sub_';\n\t\t\tstrUrlTarget = ( bPublic ? 'subhoverpublic/' : 'subhover/' ) + rgHoverData['id'];\n\t\t}\n\t\telse if ( rgHoverData['type'] == 'bundle' )\n\t\t{\n\t\t\tstrTargetPrefix = 'hover_bundle_';\n\t\t\tstrUrlTarget = 'bundle/' + rgHoverData['id'] + '/' + ( bPublic ? 'hover_public/' : 'hover/' );\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif ( typeof GDynamicStore != 'undefined' )\n\t\t{\n\t\t\tstrUrlTarget += '?review_score_preference=' + ( !GDynamicStore.s_preferences['review_score_preference'] ? 0 : GDynamicStore.s_preferences['review_score_preference'] );\n\t\t}\n\n\t\tvar targetId = strTargetPrefix + rgHoverData['id'];\n\t\tvar $HoverData = $JFromIDOrElement( targetId );\n\t\tvar params = rgHoverData['params'] || {};\n\t\tvar nStartHoverTime = new Date().getTime();\n\t\tvar fnComputeHoverDelay = bNewHoverSpeed ?\n\t\t\tfunction() { return Math.max( 400 - ( new Date().getTime() - nStartHoverTime ), 200 );} :\n\t\t\tfunction() { return 200; };\n\n\t\tif ( !$HoverData.length && !oElemState.bAjaxRequestMade )\n\t\t{\n\t\t\tvar rgAjaxParams = { u: accountId };\n\t\t\tif ( bPublic )\n\t\t\t{\n\t\t\t\t// is cc needed?\n\t\t\t\trgAjaxParams = {\n\t\t\t\t\t/*cc: rgHoverData['cc'],*/\n\t\t\t\t\tl: 'russian',\n\t\t\t\t\torigin: self.origin\n\t\t\t\t};\n\t\t\t}\n\t\t\tif ( rgHoverData['v6'] )\n\t\t\t{\n\t\t\t\trgAjaxParams['pagev6'] = true;\n\t\t\t}\n\t\t\tif ( $Elem.data('hoverDisableScreenshots') )\n\t\t\t{\n\t\t\t\trgAjaxParams['disableScreenshots'] = true;\n\t\t\t}\n\n\t\t\twindow.setTimeout( function() {\n\t\t\t\tif ( oElemState.bWantsHover && !oElemState.bAjaxRequestMade ) {\n\t\t\t\t\toElemState.bAjaxRequestMade = true;\n\t\t\t\t\t$J.get( 'https://store.steampowered.com/' + strUrlTarget, rgAjaxParams ).done( function( html )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar $Content = $J(html);\n\t\t\t\t\t\t$Content.hide();\n\t\t\t\t\t\t$Hover.find( '.content' ).append( $Content );\n\t\t\t\t\t\tShowGameHover( $Elem, $Hover, targetId, params, fnComputeHoverDelay()  );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}, bNewHoverSpeed ? 50 : 150 );\n\t\t}\n\t\tif ( !oElemState.timer )\n\t\t{\n\t\t\toElemState.timer = window.setTimeout(function () {\n\t\t\t\toElemState.timer = false;\n\t\t\t\toElemState.bReadyForHover = true;\n\t\t\t\tShowGameHover( $Elem, $Hover, targetId, params, fnComputeHoverDelay() );\n\t\t\t}, bNewHoverSpeed ? 100 : 300 );\n\t\t}\n\t}\n}\n\nfunction HideGameHover( elem, event, divHover )\n{\n\tvar $Elem = $JFromIDOrElement( elem );\n\tvar $Hover = $JFromIDOrElement( divHover );\n\n\tvar oElemState = GetHoverState( $Elem );\n\n\tif ( !$Hover.length )\n\t\treturn;\n\n\tif (!event) var event = window.event;\n\tvar reltarget = $J( (event.relatedTarget) ? event.relatedTarget : event.toElement );\n\tif ( reltarget.length && $J.contains( $Elem[0], reltarget[0] ) )\n\t\treturn;\n\n\tif ( oElemState.timer )\n\t{\n\t\twindow.clearTimeout( oElemState.timer );\n\t\toElemState.timer = false;\n\t}\n\toElemState.bWantsHover = false;\n\toElemState.bReadyForHover = false;\n\n\tHideWithFade( divHover, 200 );\n}\n\nfunction ShowGameHover( elem, divHover, targetContent, params, speed )\n{\n\tvar $Elem = $JFromIDOrElement( elem );\n\tvar $Hover = $JFromIDOrElement( divHover );\n\tvar $Target = $JFromIDOrElement( targetContent );\n\n\tvar oElemState = GetHoverState( $Elem );\n\n\tif ( !$Target.length || !oElemState.bWantsHover || !oElemState.bReadyForHover || !$J.contains( document, $Elem[0] ) )\n\t\treturn;\n\n\t$Target.siblings().hide();\n\t$Target.show();\n\n\tg_HoverState.target = $Elem[0];\n\n\tvar $Toparea = $Target.find( '.hover_top_area' );\n\tif ( params && params.top_area_content )\n\t{\n\t\t$Toparea.html( params.top_area_content );\n\t\t$Toparea.show();\n\t}\n\telse if ( $Toparea.length )\n\t{\n\t\t$Toparea.hide();\n\t}\n\n\t// \"show\" the hover, but not \"visible\", letting us do some positioning\n\t$Hover.css( 'visibility', 'hidden' ).show();\n\n\tvar $HoverBox = $Hover.find( '.hover_box' );\n\tvar $HoverArrowLeft = $Hover.find( '.hover_arrow_left' );\n\tvar $HoverArrowRight = $Hover.find( '.hover_arrow_right' );\n\n\tvar offset = $Elem.offset();\n\tvar nWindowScrollTop = $J(window).scrollTop();\n\tvar nWindowScrollLeft = $J(window).scrollLeft();\n\tvar nViewportWidth = $J(window).width();\n\tvar nViewportHeight = $J(window).height();\n\n\tvar nHoverPositionLeft, nHoverPositionTop;\n\n\t\tvar $HoverArrow = $HoverArrowLeft;\n\tvar boxRightViewport = ( offset.left - nWindowScrollLeft ) + $Elem.outerWidth() + $HoverBox.width() + 14;\n\tvar nSpaceRight = nViewportWidth - boxRightViewport;\n\tvar nSpaceLeft = offset.left - $Hover.width();\n\tif( nSpaceLeft < -10 && nSpaceRight < -10 )\n\t{\n\t\t//no room at all\n\t\t$Hover.hide().css('visibility','');\n\t\treturn;\t//skip showing the hover\n\t}\n\telse if ( nSpaceRight < 14 && nSpaceLeft > nSpaceRight )\n\t{\n\t\t\t\tnHoverPositionLeft = offset.left - $Hover.outerWidth() + 8;\n\t\t$HoverArrow = $HoverArrowRight;\n\t\t$HoverArrowLeft.hide();\n\t\t$HoverArrowRight.show();\n\t}\n\telse\n\t{\n\t\t\t\tnHoverPositionLeft = offset.left + $Elem.outerWidth() - 8;\n\t\t$HoverArrowLeft.show();\n\t\t$HoverArrowRight.hide();\n\t}\n\n\tvar nTopAdjustment = -13;\t\n\t\t\t\tif ( $Elem.height() < 63 )\n\t\tnTopAdjustment =  Math.floor( $Elem.height() ) / 2 - 56;\n\tnHoverPositionTop = offset.top + nTopAdjustment;\n\t$Hover.offset( {top: nHoverPositionTop, left: nHoverPositionLeft} );\n\n\tvar nTargetTopViewport = ( offset.top - nWindowScrollTop ) + nTopAdjustment;\n\tif ( nTargetTopViewport + $HoverBox.height() + 8 > nViewportHeight )\n\t{\n\t\tvar nViewportAdjustment = ( $HoverBox.height() + 8 ) - ( nViewportHeight - nTargetTopViewport );\n\n\t\t\t\tnViewportAdjustment = Math.min( $HoverBox.height() - 74, nViewportAdjustment );\n\t\tvar nViewportAdjustedHoverTop = offset.top - nViewportAdjustment;\n\t\t$Hover.css( 'top', nViewportAdjustedHoverTop + 'px' );\n\n\t\t$HoverArrow.css( 'top', ( 48 + nHoverPositionTop - nViewportAdjustedHoverTop ) + 'px' );\n\t}\n\telse\n\t{\n\t\t$HoverArrow.css( 'top', '' );\n\t}\n\n\t$Hover.hide();\n\t$Hover.css( 'visibility', '' );\n\n\tShowWithFade( $Hover, speed );\n}\n\nfunction UpdateWishlistCount( nCount )\n{\n\tif ( nCount == 0 )\n\t\t$JFromIDOrElement('wishlist_link').text( 'Список желаемого' );\n\telse\n\t\t$JFromIDOrElement('wishlist_link').html( 'Список желаемого (<span id=\"wishlist_item_count_value\">' + nCount.toString() + '</span>)' );\n}\n\nfunction AddToWishlist( appid, divToHide, divToShowSuccess, divToShowError, navref, divToHide2 )\n{\n\tif ( !g_AccountID )\n\t{\n\t\tShowAlertDialog( \"\\u041f\\u043e\\u0436\\u0430\\u043b\\u0443\\u0439\\u0441\\u0442\\u0430, \\u0432\\u043e\\u0439\\u0434\\u0438\\u0442\\u0435 \\u0432 \\u0430\\u043a\\u043a\\u0430\\u0443\\u043d\\u0442.\", \"\\u0412\\u044b \\u0434\\u043e\\u043b\\u0436\\u043d\\u044b \\u0432\\u043e\\u0439\\u0442\\u0438 \\u0432 \\u0430\\u043a\\u043a\\u0430\\u0443\\u043d\\u0442, \\u0447\\u0442\\u043e\\u0431\\u044b \\u0434\\u043e\\u0431\\u0430\\u0432\\u0438\\u0442\\u044c \\u043f\\u0440\\u043e\\u0434\\u0443\\u043a\\u0442 \\u0432 \\u0441\\u043f\\u0438\\u0441\\u043e\\u043a \\u0436\\u0435\\u043b\\u0430\\u0435\\u043c\\u043e\\u0433\\u043e.\" )\n\t\t.done( function() {\n\t\t\twindow.location.href = 'https://store.steampowered.com//login?redir=app/' + appid;\n\t\t} );\n\t\treturn;\n\t}\n\n\tvar url = 'https://store.steampowered.com/api/addtowishlist';\n\tif ( navref )\n\t{\n\t\tMakeNavCookie( navref, url );\n\t}\n\n\t$J.post( url, {sessionid: g_sessionID, appid: appid} )\n\t\t.done( function( data ) {\n\t\t\t$JFromIDOrElement(divToHide).hide();\n\n\t\t\tif ( divToHide2 )\n\t\t\t\t$JFromIDOrElement(divToHide2).hide();\n\n\t\t\tif ( data && data.success ) {\n\t\t\t\t$JFromIDOrElement(divToShowSuccess).show();\n\t\t\t\tif ( data.saleTaskCompleted ) {\n\t\t\t\t\tNewStickerPackModal( 'Пополните список желаемого' );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n                $JFromIDOrElement(divToShowError).show();\n            }\n\n\t\t\tUpdateWishlistCount( data.wishlistCount );\n\n\t\t\tif ( typeof GDynamicStore != 'undefined' )\n\t\t\t\tGDynamicStore.InvalidateCache();\n\t\t}).fail( function() {\n\t\t\t$JFromIDOrElement(divToShowError).show();\n\t\t});\n}\n\nfunction RemoveFromWishlist( appid, divToHide, divToShowSuccess, divToShowError, navref, divToHide2 )\n{\n\tvar url = 'https://store.steampowered.com/api/removefromwishlist';\n\tif ( navref )\n\t{\n\t\tMakeNavCookie( navref, url );\n\t}\n\n\t$J.post( url, {sessionid: g_sessionID, appid: appid} )\n\t\t.done( function( data ) {\n\t\t\t$JFromIDOrElement(divToHide).hide();\n\n\t\t\tif ( divToHide2 )\n\t\t\t\t$JFromIDOrElement(divToHide2).hide();\n\n\t\t\tif ( data && data.success ) {\n\t\t\t\t$JFromIDOrElement(divToShowSuccess).show();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$JFromIDOrElement(divToShowError).show();\n\t\t\t}\n\n\t\t\tUpdateWishlistCount( data.wishlistCount );\n\n\t\t\tif ( typeof GDynamicStore != 'undefined' )\n\t\t\t\tGDynamicStore.InvalidateCache();\n\t\t}).fail( function() {\n\t\t\t$JFromIDOrElement(divToShowError).show();\n\t\t});\n}\n\nfunction AddToWishlistButton( button, appid, navref )\n{\n\tvar url = 'https://store.steampowered.com/api/addtowishlist';\n\tif ( navref )\n\t{\n\t\tMakeNavCookie( navref, url );\n\t}\n\n\t$J.post( url, {sessionid: g_sessionID, appid: appid} )\n\t\t.done( function( data ) {\n\t\t\tif ( data && data.success )\n\t\t\t{\n\t\t\t\t$J(button).addClass('btn_disabled');\n\t\t\t\t$J('span',button).text(\"\\u0412 \\u0441\\u043f\\u0438\\u0441\\u043a\\u0435 \\u0436\\u0435\\u043b\\u0430\\u0435\\u043c\\u043e\\u0433\\u043e\");\n\t\t\t\tUpdateWishlistCount( data.wishlistCount );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$J('span',button).text( \"\\u041e\\u0439, \\u0438\\u0437\\u0432\\u0438\\u043d\\u0438\\u0442\\u0435!\" );\n\t\t\t}\n\n\t\t\tif ( typeof GDynamicStore != 'undefined' )\n\t\t\t\tGDynamicStore.InvalidateCache();\n\t\t} );\n}\n\nfunction IgnoreButton( button, appid )\n{\n\t$J.post( 'https://store.steampowered.com/recommended/ignorerecommendation/', {\n\t\tsessionid: g_sessionID,\n\t\tappid: appid\n\t}).done( function() {\n\t\t$J(button).addClass('btn_disabled');\n\t\tGDynamicStore.InvalidateCache();\n\t}).fail( function() {\n\t\tShowAlertDialog( 'Скрыть приложение', 'Произошла ошибка во время сохранения сделанных изменений. Пожалуйста, повторите попытку позже.' );\n\t});\n}\n\n// unlike wishlists, the \"divToHide\" is only hidden on success\nfunction RecommendGame( appid, steamworksappid, comment, rated_up, is_public, language, received_compensation, divBtn, onSuccessFunc, divToShowError, navref, bDisableComments )\n{\n\t$JFromIDOrElement(divBtn).hide();\n\tvar url = 'https://store.steampowered.com/friends/recommendgame';\n\tif ( navref )\n\t\tMakeNavCookie( navref, url );\n\n\tvar params = {\n\t\tappid: appid,\n\t\tsteamworksappid: steamworksappid,\n\t\tcomment: comment,\n\t\trated_up: rated_up,\n\t\tis_public: is_public,\n\t\tlanguage: language,\n\t\treceived_compensation:\n\t\treceived_compensation,\n\t\tdisable_comments: bDisableComments,\n\t\t\t\tsessionid: g_sessionID\n\t};\n\n\t$J.post( url, params )\n\t\t.done( function( data ) {\n\t\t\tif ( data && data.success )\n\t\t\t{\n\t\t\t\t$JFromIDOrElement(divToShowError).hide();\n\t\t\t\tonSuccessFunc();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$JFromIDOrElement(divBtn).show();\n\t\t\t\tvar $Error = $JFromIDOrElement(divToShowError);\n\t\t\t\tif ( data && data.strError )\n\t\t\t\t{\n\t\t\t\t\tif ( !$Error.data( 'strOrigMessage' ) )\n\t\t\t\t\t\t$Error.data( 'strOrigMessage', $Error.html() );\n\t\t\t\t\t$Error.html( data.strError );\n\t\t\t\t}\n\t\t\t\telse if ( $Error.data( 'strOrigMessage' ) )\n\t\t\t\t\t$Error.html( $Error.data( 'strOrigMessage' ) );\n\t\t\t\t$Error.show();\n\t\t\t}\n\t\t} );\n}\n\n//hide a game from being recommended\nfunction HideRecommendation( type, itemid, divBtn, elemContainer )\n{\n\tvar parameters = { sessionid: g_sessionID };\n\n\tif ( type == 'app' )\n\t\tparameters.appid = itemid;\n\telse if ( type == 'sub' )\n\t\tparameters.subid = itemid;\n\telse\n\t{\n\t\t// invalid arguments\n\t\treturn false;\n\t}\n\n\t$(divBtn).hide();\n\n\tnew Ajax.Request( 'https://store.steampowered.com/recommended/ignorerecommendation/', {\n\t\tmethod: 'post',\n\t\tparameters: parameters,\n\t\tonSuccess: function( transport ) {\n\t\t\tif ( transport.responseJSON )\n\t\t\t{\n\t\t\t\tif ( $(elemContainer) )\n\t\t\t\t\t$(elemContainer).update( '<div class=\"recommendation_ignored\">Хорошо, в следующий раз мы порекомендуем вам что-нибудь другое</div>' );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$(divBtn).show();\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction RegisterSteamOnWebPanelShownHandler( f )\n{\n\t$J(document).on( 'visibilitychange', function() {\n\t\tif ( document.visibilityState === \"visible\" )\n\t\t\tf();\n\t});\n}\n\nfunction RegisterSteamOnWebPanelHiddenHandler( f )\n{\n\t$J(document).on( 'visibilitychange', function() {\n\t\tif ( document.visibilityState === \"hidden\" )\n\t\t\tf();\n\t});\n}\n\nfunction InitVideoFocusWatcher()\n{\n\tconst k_strVideoSelector = 'video[data-video-pause-on-blur],video.fullscreen-bg__video';\n\tconst k_nBlurTimeout = 20000;\n\n\tlet nBlurTimeoutId = undefined;\n\tconst onWindowBlur = function()\n\t{\n\t\tif ( !nBlurTimeoutId )\n\t\t{\n\t\t\tnBlurTimeoutId = window.setTimeout( () =>\n\t\t\t{\n\t\t\t\t\n\t\t\t\t$J( k_strVideoSelector ).trigger( 'pause' );\n\t\t\t}, k_nBlurTimeout );\n\t\t}\n\t}\n\n\tconst onWindowFocus = function()\n\t{\n\t\tif ( nBlurTimeoutId )\n\t\t{\n\t\t\twindow.clearTimeout( nBlurTimeoutId );\n\t\t}\n\n\t\tnBlurTimeoutId = undefined;\n\t\t$J( k_strVideoSelector ).trigger( 'play' );\n\t}\n\n\t$J( window ).on( 'blur' , onWindowBlur );\n\t$J( window ).on( 'focus' , onWindowFocus );\n\n\t// Start the blur timer now if the document initially doesn't have focus\n\tif ( !document.hasFocus() )\n\t\tonWindowBlur();\n}\n\n$J( function() {\n\tInstrumentLinks();\n\n\t// add a jquery extension to handle our SNR stuff (we do this on load because jquery is included after this file)\n\tjQuery.fn.InstrumentLinks = function()\n\t{\n\t\tif ( this.is('a') )\n\t\t\tthis.each( function() { InstrumentLink( this ); } );\n\t\telse\n\t\t\tthis.find( 'a' ).each( function() { InstrumentLink( this ); } );\n\n\t\treturn this;\n\t};\n} );\n\nfunction ExtractSNR( href )\n{\n\tvar match = href.match( /[\\?&]snr=([^&]*)/ );\n\treturn match && match[1];\n}\n\nfunction ReplaceSNR( href, snr )\n{\n\treturn href.replace( /([\\?&]snr=)[^&]*/, '$1' + snr );\n}\n\n/**\n *\n * @param $Link\n * @param fnCallback\ttakes an SNR code, should return the new SNR code\n * @constructor\n */\nfunction ModifyLinkSNR( $Link, fnCallback )\n{\n\tvar href = $Link.attr('href');\n\tvar snr = href && ExtractSNR( href );\n\tif ( snr )\n\t{\n\t\t$Link.attr( 'href', ReplaceSNR( href, fnCallback( snr ) ) );\n\t}\n}\n\nfunction InstrumentLinks()\n{\n\t$J('A').each( function() { InstrumentLink( this ); } );\n}\n\nfunction InstrumentLink( link )\n{\n\tif ( link.bIsInstrumented )\n\t\treturn;\n\n\tvar bIsInstrumented = false;\n\t//  if the anchor uses javascript, then we don't want to monkey with any embedded URL's\n\tif ( !link.href.match( /^javascript/ ) )\n\t{\n\t\tvar navinfo = link.href.match( /[\\?&]snr=[^&]*(&|$)/ );\n\t\tif ( navinfo  )\n\t\t{\n\t\t\tbIsInstrumented = true;\n\t\t\t$J(link).click( function( event ) { InstrumentedLinkOnClick( event, link ); } );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar outcinfo = link.href.match(/[\\?&]outc=([^&]*)(&|$)/);\n\t\t\tif ( outcinfo )\n\t\t\t{\n\t\t\t\tbIsInstrumented = true;\n\t\t\t\t$J(link).click( function (event) { InstrumentedLinkOnClick(event, link); } );\n\t\t\t}\n\t\t}\n\t\tif ( bIsInstrumented )\n\t\t{\n\t\t\tlink.bIsInstrumented = bIsInstrumented;\n\t\t}\n\t}\n}\n\nfunction InstrumentedLinkOnClick( event, link )\n{\n\tvar navinfo = link.href.match( /[\\?&]snr=([^&#]*)(&|$|#)/ );\n\tif ( navinfo )\n\t{\n\t\t\t}\n    var exprinfo = link.href.match( /[\\?&]outc=([^&#]*)(&|#|$)/ );\n    if ( exprinfo )\n    {\n        replacement = '';\n        if ( exprinfo[2] == '&' )\n            replacement = exprinfo[0][0];\n\t\telse\n\t\t\treplacement = navinfo[2];\n        link.href = link.href.replace( /[\\?&]outc=[^&#]*(&|#|$)/, replacement );\n        MakeOutcomeCookie( exprinfo[1], link.href );\n    }\n\n\treturn true;\n}\n\nfunction MakeNavCookie( snr, url )\n{\n\tvar dateExpires = new Date();\n\tdateExpires.setTime( dateExpires.getTime() + 1000 * 60 );\n\tdocument.cookie = 'snr=' + snr + '|' + encodeURIComponent( url ) +'; expires=' + dateExpires.toGMTString() + ';path=/';\n}\n\nfunction MakeOutcomeCookie( outc, url )\n{\n    var dateExpires = new Date();\n    dateExpires.setTime( dateExpires.getTime() + 1000 * 60 );\n    document.cookie = 'outc=' + outc +'; expires=' + dateExpires.toGMTString() + ';path=/';\n}\n\nfunction GetNavCookie()\n{\n    // get back the cookie that MakeNavCookie creates !\n    var ref = document.cookie.match( /\\ssnr=([^;]*);/ );\n    if ( ref )\n        return  ref[1];\n}\n\nvar g_iActiveSpotlight = 0;\n\nfunction AnimateSpotlightTransition( iCurSpotlight, iNextSpotlight )\n{\n\tvar $elSpotlights = $J('#spotlight_scroll').children();\n\tvar $Spotlight = $J( $elSpotlights[iCurSpotlight] );\n\tvar $NextSpotlight = $J( $elSpotlights[iNextSpotlight] );\n\n\tvar $Scroll = $JFromIDOrElement('spotlight_scroll');\n\t$Scroll.stop();\n\tvar curHeight = $Scroll.height();\n\n\t$Scroll.css( 'height', curHeight + 'px' );\n\n\t$Spotlight.css( 'position', 'absolute' );\n\t$NextSpotlight.css( 'position', 'absolute' );\n\n\tvar targetHeight = $NextSpotlight.height();\n\tif ( targetHeight != curHeight )\n\t\t$Scroll.animate( {height: targetHeight }, 250 );\n\n\t$Spotlight.stop();\n\t$Spotlight.fadeOut( 250 );\n\n\t$NextSpotlight.stop();\n\t$NextSpotlight.fadeTo( 200, 1.0 );\t//fadeTo rather than fadeIn in case it was already in a fade\n}\n\nfunction NextSpotlight( cMaxSpotlights )\n{\n\tif ( g_iActiveSpotlight + 1 >= cMaxSpotlights )\n\t\treturn;\n\tAnimateSpotlightTransition( g_iActiveSpotlight, ++g_iActiveSpotlight );\n\tUpdateSpotlightControls( cMaxSpotlights );\n}\n\nfunction expandTXItem( item )\n{\n\tvar blurb = $( item ).down( '.tx_record_row_blurb' );\n\n\tif ( !blurb )\n\t\treturn;\n\n\tif ( blurb.visible() )\n\t\tEffect.BlindUp( blurb, { duration: 0.25 } );\n\telse\n\t\tEffect.BlindDown( blurb, { duration: 0.25 } )\n}\n\nfunction PrevSpotlight( cMaxSpotlights )\n{\n\tif ( g_iActiveSpotlight <= 0 )\n\t\treturn;\n\tAnimateSpotlightTransition( g_iActiveSpotlight, --g_iActiveSpotlight );\n\tUpdateSpotlightControls( cMaxSpotlights );\n}\n\nfunction UpdateSpotlightControls( cMaxSpotlights )\n{\n\tif ( g_iActiveSpotlight < cMaxSpotlights - 1 )\n\t\t$JFromIDOrElement('spotlight_scroll_next').removeClass( 'disabled' );\n\telse\n\t\t$JFromIDOrElement('spotlight_scroll_next').addClass( 'disabled' );\n\n\tif ( g_iActiveSpotlight > 0 )\n\t\t$JFromIDOrElement('spotlight_scroll_prev').removeClass( 'disabled' );\n\telse\n\t\t$JFromIDOrElement('spotlight_scroll_prev').addClass( 'disabled' );\n\n\t$J('#spotlight_scroll_count_cur').text( g_iActiveSpotlight + 1 );\n}\n\nfunction InitDailyDealTimer( elTimer, nServerEndTime )\n{\n\tvar nTimeRemaining = nServerEndTime - g_ServerTime;\n\tif ( nTimeRemaining > 0 )\n\t{\n\t\tvar nEndTimeLocal = Math.round( new Date().getTime() / 1000 ) + nTimeRemaining;\n\t\tnew Countdown( elTimer, nEndTimeLocal );\n\t}\n}\n\nvar CCountdownManager = {\n\trgCountdowns: [],\n\tnIntervalId: null,\n\tbRefreshOnTimerEnd: false,\n\n\ttsInit: 0,\n\tbReadyForRefresh: false,\n\tbTriggeredRefresh: false,\n\n\tregisterCountdown: function( countdown )\n\t{\n\t\tthis.rgCountdowns.push( countdown );\n\t\tif ( !this.nIntervalId )\n\t\t{\n\t\t\tthis.nIntervalId = window.setInterval( this.refreshClocks.bind( this ), 1000 );\n\t\t\tthis.tsInit = Math.round( new Date().getTime() / 1000 );\n\t\t}\n\t},\n\n\trefreshClocks: function()\n\t{\n\t\tfor ( var i = 0; i < this.rgCountdowns.length; i++ )\n\t\t{\n\t\t\tvar countdown = this.rgCountdowns[i];\n\t\t\tif ( countdown.bEnded )\n\t\t\t\tcontinue;\n\n\t\t\tthis.rgCountdowns[i].refreshClock();\n\t\t\tif ( countdown.bEnded && this.bRefreshOnTimerEnd )\n\t\t\t\tthis.refreshOnUserAction();\n\t\t}\n\t},\n\n\trefreshOnUserAction: function()\n\t{\n\t\t// if a few seconds have passed, we'll refresh\n\t\tif ( !this.bReadyForRefresh && Math.round( new Date().getTime() / 1000 ) - this.tsInit >= 5 )\n\t\t{\n\t\t\tvar _this = this;\n\t\t\t$J(document).on( 'focus mousemove', function() { _this.doRefresh(); } );\n\t\t\tthis.bReadyForRefresh = true;\n\t\t}\n\t},\n\n\tdoRefresh: function()\n\t{\n\t\tif ( !this.bTriggeredRefresh )\n\t\t{\n\t\t\tthis.bTriggeredRefresh = true;\n\t\t\twindow.location.reload();\n\t\t}\n\t}\n};\n\nfunction Countdown( elClock, nEndTimeLocalTime )\n{\n\tthis.$Clock = $JFromIDOrElement( elClock );\n\tthis.nEndTime = nEndTimeLocalTime;\n\tthis.bEnded = false;\n\tthis.cbkExpired = null;\n\n\tif ( this.$Clock.length && nEndTimeLocalTime )\n\t{\n\t\tthis.refreshClock();\n\t\tCCountdownManager.registerCountdown(this);\n\t}\n}\n\nCountdown.prototype.setCallback = function( cbkExpired )\n{\n\tthis.cbkExpired = cbkExpired;\n};\n\nCountdown.prototype.refreshClock = function()\n{\n\tif ( this.bEnded )\n\t\treturn;\n\n\tvar timeCur = Math.round( new Date().getTime() / 1000 );\n\tvar secsRemaining = this.nEndTime - timeCur;\n\n\tif ( secsRemaining < 0 )\n\t{\n\t\tthis.bEnded = true;\n\t\tsecsRemaining = 0;\n\t}\n\n\tvar remainDays = Math.floor( secsRemaining / 86400 );\n\tvar remainHours = Math.floor( ( secsRemaining % 86400 ) / 3600 );\n\tvar remainMinutes = Math.floor( ( secsRemaining % 3600 ) / 60 );\n\tvar remainSeconds = secsRemaining % 60;\n\n\tif ( this.cbkExpired && secsRemaining < 1 )\n\t{\n\t\tthis.cbkExpired();\n\t\tthis.cbkExpired = null;\n\t}\n\n\tthis.render( remainDays, remainHours, remainMinutes, remainSeconds );\n};\n\nCountdown.prototype.render = function( remainDays, remainHours, remainMinutes, remainSeconds )\n{\n\tvar str = '';\n\tif ( remainDays < 3 )\n\t{\n\t\tremainHours += remainDays * 24;\n\t}\n\telse\n\t{\n\t\tstr += remainDays + ' дн. ';\n\t}\n\tstr += (remainHours < 10 ? '0' : '') + remainHours + ':';\n\tstr += (remainMinutes < 10 ? '0' : '') + remainMinutes + ':';\n\tstr += (remainSeconds < 10 ? '0' : '') + remainSeconds;\n\tthis.$Clock.text( str );\n};\n\nfunction GraphicalCountdown( nEndTimeLocalTime, strImagePath, strElPrefix )\n{\n\tthis.strImagePath = strImagePath;\n\tthis.strElPrefix = strElPrefix;\n\tthis.strExtension = '.png';\n\tthis.rgLastVals = {};\n\tCountdown.apply( this, [ null, nEndtimeLocalTime ] );\n}\nGraphicalCountdown.prototype = new Countdown;\nGraphicalCountdown.prototype.constructor = GraphicalCountdown;\n\nGraphicalCountdown.prototype.render = function( remainDays, remainHours, remainMinutes, remainSeconds )\n{\n\tremainHours += remainDays * 24;\n\tthis.setImage( 'hours_tens', Math.floor( remainHours / 10 ) );\n\tthis.setImage( 'hours_units', remainHours % 10 );\n\tthis.setImage( 'minutes_tens', Math.floor( remainMinutes / 10 ) );\n\tthis.setImage( 'minutes_units', remainMinutes % 10 );\n\tthis.setImage( 'seconds_tens', Math.floor( remainSeconds / 10 ) );\n\tthis.setImage( 'seconds_units', remainSeconds % 10 );\n};\n\nGraphicalCountdown.prototype.setImage = function( idSuffix, val )\n{\n\tif ( this.rgLastVals[idSuffix] != val )\n\t{\n\t\t$(this.strElPrefix + idSuffix).src = this.strImagePath + val + this.strExtension;\n\t\tthis.rgLastVals[idSuffix] = val;\n\t}\n};\n\n\n// SEARCH.JS\n\nvar g_oSuggestParams;\n\nvar g_nMobileSearchTermTimer = 0;\n\n// how long we wait after the first keypress after a search or page load\nvar k_nStartSearchTimeoutMS = 350;\n\n// how long we extend the wait after each keypress.  We always time out at 3x the base search timeout ms\nvar k_nSearchKeypressTimeoutExtensionMS = 125;\n\n// TODO: only reason for having this here is to support the SNR.  If the mobile app can identify it, or it's not important to include the SNR then\n// we'll have the mobile app navigate to the search page without having to post a message to the webview\nfunction MobileApp_ShowSearchResults( $SNR, $Term )\n{\n\tconst snr = $SNR ? '&snr=' + $SNR : '';\n\twindow.location = 'https://store.steampowered.com/search/?term=' + encodeURIComponent( $Term ) + snr;\n}\n\nfunction MobileApp_UpdateSearchSuggestions( $Term )\n{\n\tvar $SuggestionsCtn = $J('#searchterm_options');\n\tvar $Suggestions = $J('#search_suggestion_contents');\n\n\tvar msDelayBeforeTimeout = k_nStartSearchTimeoutMS;\n\tif ( g_nMobileSearchTermTimer !== 0 )\n\t{\n\t\twindow.clearTimeout( g_nMobileSearchTermTimer );\n\t\tg_nMobileSearchTermTimer = 0;\n\t\tmsDelayBeforeTimeout = k_nSearchKeypressTimeoutExtensionMS;\n\t}\n\n\tg_nMobileSearchTermTimer = window.setTimeout( function() {\n\t\t\tg_nMobileSearchTermTimer = 0;\n\t\t\tsLastVal = $Term;\n\t\t\tSearchTimeout( $Term, v_trim( sLastVal ), $SuggestionsCtn, $Suggestions, true /* bUseResponsivePopupOverlay */ );\n\t\t}, msDelayBeforeTimeout );\n}\n\nfunction InitializeSearchSuggestionParams( cc, realm, l, rgUserPreferences, strPackageXMLVersion )\n{\n\tg_oSuggestParams = $J.extend( {\n\t\tcc: cc,\n\t\trealm: realm,\n\t\tl:l,\n\t\tv: strPackageXMLVersion\n\t}, rgUserPreferences );\n}\n\n// Enable search where the search text input is part of the web page\nfunction EnableSearchSuggestions( elemTerm, navcontext, cc, realm, l, rgUserPreferences, strPackageXMLVersion, elemSuggestionCtn, elemSuggestions )\n{\n\tvar $Term = $JFromIDOrElement(elemTerm);\n\tvar $SuggestionsCtn = elemSuggestionCtn ? $JFromIDOrElement(elemSuggestionCtn) : $J('#searchterm_options');\n\tvar $Suggestions = elemSuggestions ? $JFromIDOrElement(elemSuggestions) : $J('#search_suggestion_contents');\n\n\t$Term.parents('div.searchbox').click( function( event ) {\n\t\tif ( event.target && event.target.tagName != 'INPUT' )\n\t\t\t$J(elemTerm).focus();\n\t});\n\n\tvar sLastVal = $Term.val();\n\tvar nTermTimer = 0;\n\tvar tsScheduledTimer = 0;\n\tvar tsLastSearch = 0;\n\t$Term.on( 'keyup paste', function( event ) {\n\t\tvar sNewVal = $Term.val();\n\t\tif ( sNewVal != sLastVal )\n\t\t{\n\t\t\tvar tsChange = $J.now();\n\t\t\tvar msDelayBeforeTimeout = k_nStartSearchTimeoutMS;\n\t\t\tif ( !tsLastSearch )\n\t\t\t\ttsLastSearch = tsChange;\n\n\t\t\tif ( nTermTimer && tsScheduledTimer - tsChange < k_nSearchKeypressTimeoutExtensionMS && tsChange - tsLastSearch < 3 * k_nStartSearchTimeoutMS )\n\t\t\t{\n\t\t\t\t// we have one scheduled within 50ms, just bump it out a little\n\t\t\t\tmsDelayBeforeTimeout = k_nSearchKeypressTimeoutExtensionMS;\n\t\t\t\twindow.clearTimeout( nTermTimer );\n\t\t\t\tnTermTimer = 0;\n\t\t\t}\n\n\t\t\tif ( !nTermTimer )\n\t\t\t{\n\t\t\t\ttsScheduledTimer = $J.now() + msDelayBeforeTimeout;\n\t\t\t\tnTermTimer = window.setTimeout( function() {\n\t\t\t\t\tnTermTimer = 0;\n\t\t\t\t\ttsLastSearch = 0;\n\t\t\t\t\tsLastVal = $Term.val();\n\t\t\t\t\tSearchTimeout( $Term, v_trim( sLastVal ), $SuggestionsCtn, $Suggestions );\n\t\t\t\t}, msDelayBeforeTimeout);\n\t\t\t}\n\t\t}\n\t});\n\n\t$Term.on( 'keydown', function( event ) { SearchSuggestOnKeyDown( event, $Term, $SuggestionsCtn, $Suggestions ); } );\n\t$Term.on( 'click focus', function( event ) { SearchSuggestClearDefaultSearchText( $Term, $SuggestionsCtn, $Suggestions ); } );\n\t$Term.add( $SuggestionsCtn ).on( 'focusout', function( event ) {\n\t\tif ( event.relatedTarget && ( $J.contains( $Term[0], event.relatedTarget ) || $Term.is( event.relatedTarget ) || $J.contains( $SuggestionsCtn[0], event.relatedTarget ) ) )\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSearchSuggestSetDefaultSearchText( $Term, $SuggestionsCtn, $Suggestions );\n\t} );\n\n\tInitializeSearchSuggestionParams( cc, realm, l, rgUserPreferences, strPackageXMLVersion );\n}\nfunction SearchTimeout( $Term, value, $SuggestionsCtn, $Suggestions, bUseResponsivePopupOverlay = false )\n{\n\tif ( value )\n\t{\n\t\tvar parameters = {term: value, f: 'games' };\n\t\t$J.extend( parameters, g_oSuggestParams );\n\t\t$J.get( 'https://store.steampowered.com/search/suggest', parameters).done( function( html ) {\n\t\t\t$Suggestions.html( html );\n\t\t\t$Suggestions.InstrumentLinks();\n\t\t\t$Suggestions.find('.match').attr('data-ds-options', 0);\n\t\t\tGDynamicStore.DecorateDynamicItems( $Suggestions );\n\t\t\t$Suggestions.find('a.match').each( function () {\n\t\t\t\tvar el = this;\n\t\t\t\t$J(el).on( 'mouseover', function( event ) { SearchSuggestOnMouseOver( event, $J(el) ); } );\n\t\t\t\t$J(el).on( 'mouseleave', function( event ) { SearchSuggestOnMouseLeave( event, $J(el) ); } );\n\t\t\t\t$J(el).on( 'mousemove', function( event ) { SearchSuggestOnMouseOver( event, $J(el) ); } );\n\t\t\t} );\n\t\t\tShowSuggestionsAsNecessary( false, $SuggestionsCtn, $Suggestions, bUseResponsivePopupOverlay );\n\t\t} );\n\t}\n\telse\n\t{\n\t\t$Suggestions.empty();\n\t\tShowSuggestionsAsNecessary( false, $SuggestionsCtn, $Suggestions, bUseResponsivePopupOverlay );\n\t}\n}\n\nfunction ShowSuggestionsAsNecessary( bForceHide, $SuggestionsCtn, $Suggestions, bUseResponsivePopupOverlay = false )\n{\n\tvar bShow = $Suggestions.children().length > 0 && !bForceHide;\n\tif ( bShow )\n\t{\n\t\tShowWithFade( $SuggestionsCtn );\n\t}\n\telse\n\t{\n\t\tHideWithFade( $SuggestionsCtn );\n\t}\n\n\tif ( bUseResponsivePopupOverlay )\n\t{\n\t\tUpdateResponsiveSearchOverlay( bShow );\n\t}\n}\n\nfunction UpdateResponsiveSearchOverlay( bShow )\n{\n\tvar $ResponsiveSearchOverlay = $J( '#responsive_store_search_overlay' );\n\tif ( bShow )\n\t{\n\t\t$ResponsiveSearchOverlay.show();\n\t\tdocument.body.classList.add( 'responsive_store_overlay_visible' );\n\t}\n\telse\n\t{\n\t\t$ResponsiveSearchOverlay.hide();\n\t\tdocument.body.classList.remove( 'responsive_store_overlay_visible' );\n\t}\n}\n\nfunction SearchSuggestOnKeyDown( event, $Term, $SuggestionsCtn, $Suggestions )\n{\n\tif ( event.keyCode == 27 /* Event.KEY_ESC */ )\n\t{\n\t\tShowSuggestionsAsNecessary( true, $SuggestionsCtn, $Suggestions );\n\t}\n\telse if ( event.keyCode == 13 /* Event.KEY_RETURN */\n\t\t|| event.keyCode == 38 /* Event.KEY_UP */\n\t\t|| event.keyCode == 40 /* Event.KEY_DOWN */ )\n\t{\n\t\tif ( !$SuggestionsCtn.is( ':visible' ) )\n\t\t\treturn;\n\n\t\tvar $CurSuggestion = $Suggestions.children('.focus');\n\t\tvar $NewSuggestion = $J();\n\n\t\tif ( event.keyCode == 13 /* Event.KEY_RETURN */ )\n\t\t{\n\t\t\tif ( $CurSuggestion.length )\n\t\t\t{\n\t\t\t\twindow.location = $CurSuggestion.attr( 'href' );\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ( !$CurSuggestion.length )\n\t\t\t\t$CurSuggestion = $Suggestions.children('.hover');\n\n\t\t\tif ( event.keyCode == 38 /* Event.KEY_UP */ )\n\t\t\t{\n\t\t\t\tif ( $CurSuggestion.length )\n\t\t\t\t\t$NewSuggestion = $CurSuggestion.prev();\n\t\t\t\tif ( !$NewSuggestion.length )\n\t\t\t\t\t$NewSuggestion = $Suggestions.children('a.match:last-child');\n\t\t\t}\n\t\t\telse if ( event.keyCode == 40 /* Event.KEY_DOWN */ )\n\t\t\t{\n\t\t\t\tif ( $CurSuggestion.length )\n\t\t\t\t\t$NewSuggestion = $CurSuggestion.next();\n\t\t\t\tif ( !$NewSuggestion.length )\n\t\t\t\t\t$NewSuggestion = $Suggestions.children('a.match:first-child');\n\t\t\t}\n\n\t\t\tif ( $NewSuggestion.length  )\n\t\t\t{\n\t\t\t\t$CurSuggestion.removeClass( 'focus' );\n\t\t\t\t$CurSuggestion.removeClass( 'hover' );\n\t\t\t\t$NewSuggestion.addClass('focus');\n\t\t\t}\n\n\t\t\t//client webkit will move cursor on up/down\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t}\n}\nfunction SearchSuggestOnMouseOver( event, $Suggestion )\n{\n\t$Suggestion.siblings().removeClass( 'focus' );\n\t$Suggestion.removeClass( 'focus' );\n\t$Suggestion.siblings().removeClass( 'hover' );\n\t$Suggestion.addClass( 'hover' );\n}\n\nfunction SearchSuggestOnMouseLeave( event, $Suggestion )\n{\n\t$Suggestion.removeClass( 'focus' );\n\t$Suggestion.removeClass( 'hover' );\n}\n\nfunction SearchSuggestClearDefaultSearchText( $Term, $SuggestionsCtn, $Suggestions )\n{\n\tShowSuggestionsAsNecessary( false, $SuggestionsCtn, $Suggestions );\n\tSearchSuggestClearFixStyles($Term);\n}\n\nfunction SearchSuggestClearFixStyles($Term)\n{\n\t$Term.removeClass( 'default' );\n}\n\nfunction SearchSuggestSetDefaultSearchText( $Term, $SuggestionsCtn, $Suggestions )\n{\n\tShowSuggestionsAsNecessary( true, $SuggestionsCtn, $Suggestions );\n\tSearchSuggestSetFixStyles($Term);\n}\n\nfunction SearchSuggestSetFixStyles($Term)\n{\n\tvar text = $Term.val();\n\tif (text == '')\n\t{\n\t\t$Term.addClass( 'default' );\n\t}\n}\n\nfunction SearchSuggestCheckTerm( theform )\n{\n\t// no longer need to check for #text_search_the_store, but leaving here\n\t// in case we have other things we want to block in the future.\n\treturn true;\n}\n\n// HEADER.JS\n\n// We always want to have the timezone cookie set for PHP to use\nsetTimezoneCookies();\n\n\n// tags in the menu\nfunction EnsureStoreMenuTagsLoaded( strId )\n{\n\t// dynamic store can handle this in v6\n\tif ( typeof GDynamicStore != 'undefined' )\n\t\treturn;\n\n\tvar $Element = $J(strId);\n\tif ( !$Element.data('tags-loaded') )\n\t{\n\t\t$Element.data('tags-loaded', true );\n\n\t\tvar url = 'https://store.steampowered.com/tagdata/recommendedtags';\n\n\t\t$J.get( url, {ll: 'russian'} ).done( function( data ) {\n\t\t\tvar rgYourPopularTags = data || [];\n\t\t\tif ( rgYourPopularTags.length > 0 )\n\t\t\t{\n\t\t\t\t$Element.empty();\n\t\t\t\t$Element.css( 'min-height', '' );\n\t\t\t\tfor( var i = 0; i < rgYourPopularTags.length && i < 5; i++ )\n\t\t\t\t{\n\t\t\t\t\tvar tag = rgYourPopularTags[i];\n\t\t\t\t\tvar $Link = $J('<a/>', {'class': 'popup_menu_item', 'href': 'https://store.steampowered.com/tag/ru/' + encodeURIComponent( tag.name ) });\n\t\t\t\t\t$Link.text( tag.name );\n\t\t\t\t\t$Element.append( $Link );\n\t\t\t\t}\n\t\t\t}\n\t\t}).fail( function() {\n\t\t}).always( function() {\n\t\t\t$Element.children( '.popup_menu_subarea').show();\n\t\t});\n\t}\n}\n\n\nfunction AddFreeLicense( subid, strDisplayName )\n{\n\tif ( window.g_bAddFreeLicenseInFlight )\n\t\treturn;\n\n\twindow.g_bAddFreeLicenseInFlight = true;\n\n\tvar posts = [];\n\tvar subids = ( typeof subid == \"number\" || typeof subid == \"string\" ? [ subid ] : subid );\n\n\tfor ( var i = 0; i < subids.length; i++ )\n\t{\n\t\tposts.push( CrossDomainPost( 'https://store.steampowered.com/freelicense/addfreelicense/' + subids[i], { ajax: true, sessionid: g_sessionID }) );\n\t}\n\n\t$J.when.apply( $J, posts ).done( function() {\n\t\tShowAlertDialog(\n\t\t\tstrDisplayName,\n\t\t\t'Этот продукт (%s) был добавлен на ваш аккаунт. Теперь он доступен в вашей библиотеке Steam.'.replace( /%s/, strDisplayName )\n\t\t).done( function() {\n\t\t\twindow.location.reload();\n\t\t});\n\t\tif ( typeof GDynamicStore != 'undefined' )\n\t\t\tGDynamicStore.InvalidateCache();\n\t}).fail( function( jqXHR ) {\n\t\tvar data = V_ParseJSON( jqXHR.responseText );\n\t\tif ( data && data.purchaseresultdetail == 9 )\n\t\t\tShowAlertDialog( strDisplayName, 'Данный продукт уже доступен в вашей библиотеке Steam.' );\n\t\telse if ( data && data.purchaseresultdetail == 24 )\n\t\t\tShowAlertDialog( strDisplayName, 'Вы можете добавить этот продукт в свой аккаунт Steam, только если у вас есть основной продукт.' );\n\t\telse\n\t\t\tShowAlertDialog( strDisplayName, 'Произошла ошибка при добавлении данного продукта на ваш аккаунт. Пожалуйста, повторите попытку позже.' );\n\t}).always( function () {\n\t\tdelete window.g_bAddFreeLicenseInFlight;\n\t});\n}\n\n\nfunction AddFreeBundle( bundleid, strDisplayName )\n{\n\tif ( window.g_bAddFreeLicenseInFlight )\n\t\treturn;\n\n\twindow.g_bAddFreeLicenseInFlight = true;\n\n\tvar posts = [];\n\tposts.push( CrossDomainPost( 'https://store.steampowered.com/freelicense/addfreebundle/' + bundleid, { ajax: true, sessionid: g_sessionID }) );\n\n\t$J.when.apply( $J, posts ).done( function() {\n\t\tShowAlertDialog(\n\t\t\tstrDisplayName,\n\t\t\t'Этот продукт (%s) был добавлен на ваш аккаунт. Теперь он доступен в вашей библиотеке Steam.'.replace( /%s/, strDisplayName )\n\t\t).done( function() {\n\t\t\twindow.location.reload();\n\t\t});\n\t\tif ( typeof GDynamicStore != 'undefined' )\n\t\t\tGDynamicStore.InvalidateCache();\n\t}).fail( function( jqXHR ) {\n\t\tvar data = V_ParseJSON( jqXHR.responseText );\n\t\tif ( data && data.purchaseresultdetail == 9 )\n\t\t\tShowAlertDialog( strDisplayName, 'Данный продукт уже доступен в вашей библиотеке Steam.' );\n\t\telse\n\t\t\tShowAlertDialog( strDisplayName, 'Произошла ошибка при добавлении данного продукта на ваш аккаунт. Пожалуйста, повторите попытку позже.' );\n\t}).always( function () {\n\t\tdelete window.g_bAddFreeLicenseInFlight;\n\t});\n}\n\n\nfunction ChangeLanguage( strTargetLanguage, bStayOnPage )\n{\n\tvar Modal = ShowBlockingWaitDialog( 'Изменить язык', '' );\n\t$J.post( 'https://store.steampowered.com/account/setlanguage/', {language: strTargetLanguage, sessionid: g_sessionID })\n\t.done( function() {\n\t\tif ( bStayOnPage )\n\t\t\tModal.Dismiss();\n\t\telse\n\t\t{\n\t\t\t\t\t\tif( typeof g_AccountID  != 'undefined' && g_AccountID > 0 )\n\t\t\t\twindow.location = 'https://store.steampowered.com/account/languagepreferences/';\n\t\t\telse if ( window.location.href.match( /[?&]l=/ ) )\n\t\t\t\twindow.location = window.location.href.replace( /([?&])l=[^&]*&?/, '$1' );\n\t\t\telse\n\t\t\t\twindow.location.reload();\n\t\t}\n\t}).fail( function() {\n\t\tModal.Dismiss();\n\t\tShowAlertDialog( 'Изменить язык', 'Произошла ошибка во время сохранения сделанных изменений. Пожалуйста, повторите попытку позже.' );\n\t});\n}\n\nfunction Logout()\n{\n\tvar $Form = $J('<form/>', {'action': 'https://store.steampowered.com/logout/', 'method': 'POST' } );\n\t$Form.append( $J('<input/>', {'type': 'hidden', 'name': 'sessionid', 'value': g_sessionID } ) );\n\t$Form.appendTo( 'body' );\n\t$Form.submit();\n}\n\nfunction getBestAvailNavData()\n{\n\tvar navData = jQuery.data( document, 'x_oldnav' );\n\tif ( navData == undefined )\n\t{\n\t\tnavData = jQuery.data( document, 'x_oldref' );\n\t}\n\tif ( navData === undefined )\n\t{\n\t\t// try to get what we need from the URL !\n\t\tvar rg = window.location.href.match( /[\\?&]snr=([^\\?&]*)($|&)/ );\n\t\tif ( rg )\n\t\t{\n\t\t\tnavData = rg[1];\n\t\t}\n\t}\n\treturn  navData;\n}\n\nfunction AddToAccountCart( subid )\n{\n\tlet fnAddToCart = function() { addToCart( subid ); };\n\tif ( typeof window.AddItemToCart !== 'undefined' )\n\t{\n\t\tfnAddToCart();\n\t}\n\telse\n\t{\n\t\twindow.rgOnAccountCartReadyCallbacks = ( window.rgOnAccountCartReadyCallbacks || [] ).concat( fnAddToCart );\n\t}\n}\n\n// Function to add a package to a cart, assumes form setup on the page\nfunction addToCart( subid, dedupe )\n{\n\ttry\n\t{\n\t\t// Find all of the add to cart buttons displayed on the page\n\t\tvar filterAllButtons='a.btn_addtocart_content';\n\t\t// the filterString can be used to find the element that invoked us, since the subid appears within it\n\t\t// note that href*= specifies that href contains the string\n\t\tvar filterString = 'a[href*=' + subid + ']';\n\t\t// within the set of all buttons, get the index of the one that we are dealing with!\n\t\t// To do that, we find the anchor that invoked us within the larger set of add to cart buttons!\n\t\tvar allButtons = jQuery( filterAllButtons );\n\n\t\t// Check for quantity\n\t\tvar idx = ( dedupe !== undefined ) ? dedupe : 0;\n\t\tvar filterStringForm = 'form[name=add_to_cart_'+subid+']';\n\t\tvar $Form = jQuery( filterStringForm );\n\n\t\tif ( !$Form.length || ( $Form[0].getAttribute( 'action' ) || '' ).indexOf( '/freelicense/' ) === -1 )\n\t\t{\n\t\t\tif ( typeof g_bUseNewCartAPI != 'undefined' && g_bUseNewCartAPI && typeof window.AddItemToCart !== 'undefined' )\n\t\t\t{\n\t\t\t\t// subid may represent an actual subid... or it might just be a way to get the right form. Figure that out here.\n\t\t\t\tvar actualSubID = subid;\n\t\t\t\tif ( $Form.length )\n\t\t\t\t{\n\t\t\t\t\tvar $Input = $Form.children( 'input[name=subid]' );\n\t\t\t\t\tif ( $Input.length )\n\t\t\t\t\t{\n\t\t\t\t\t\tactualSubID = JSON.parse( $Input[0].value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar navdata;\n\t\t\t\tif ( typeof GStoreItemData !== 'undefined' )\n\t\t\t\t\tnavdata = $Form.find('input[name=originating_snr]').length > 0 ? GStoreItemData.GetPreviousPageNavParamObj() : GStoreItemData.GetCurrentPageNavParamObj();\n\n\t\t\t\twindow.AddItemToCart( actualSubID, undefined /* bundleid */, navdata );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif ( !$Form.length )\n\t\t{\n\t\t\t$Form= $J('<form/>', { name: 'add_to_cart_' + subid, action: 'https://store.steampowered.com/cart/', method: 'POST', style: 'display: none;' } );\n\t\t\t$Form.append( $J('<input/>', { type: 'hidden', name: 'action', value: 'add_to_cart' } ) );\n\t\t\t$Form.append( $J('<input/>', { type: 'hidden', name: 'subid', value: subid } ) );\n\t\t\t$Form.append( $J('<input/>', { type: 'hidden', name: 'sessionid', value: g_sessionID } ) );\n\n\t\t\tif ( typeof GStoreItemData !== 'undefined' )\n\t\t\t\t$Form.append( $J('<input/>', { type: 'hidden', name: 'snr', value: GStoreItemData.GetCurrentPageNavParams() } ) );\n\n\t\t\t$J(document.body).append( $Form );\n\t\t}\n\n\t\tvar quantity = jQuery( '#quantity_update_'+subid+'_'+idx ).val();\n\t\tif ( quantity !== undefined )\n\t\t{\n\t\t\tjQuery('<input type=\"hidden\">').attr({name: 'quantity', 'value': quantity}).appendTo($Form);\n\t\t}\n\n\t\t// do we have anything to examine?\n\t\tif ( allButtons.length > 0 )\n\t\t{\n\n\t\t\tvar navData = getBestAvailNavData();\n\t\t\tvar button;\n\t\t\tvar buttonOffset = { top : 0, left : 0 };\n\t\t\tvar buttonIndex = allButtons.index( jQuery( filterString ) );\n\t\t\t//\n\t\t\t//  Subscription pages have ambiguous add to cart buttons - we will try to 'dedupe' it !\n\t\t\t//\n\t\t\tif ( buttonIndex === -1 )\n\t\t\t{\n\t\t\t\tif ( dedupe !== undefined )\n\t\t\t\t{\n\t\t\t\t\tbuttonIndex = dedupe;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//  There is a chance this we're mistaken if the .php generation of the page\n\t\t\t\t\t//  didn't generate the addToCart() calls as we expect !\n\t\t\t\t\tbuttonIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\tbutton = allButtons.eq(buttonIndex);\n\n\t\t\t//\n\t\t\t//  If we are certain we know what button was clicked, then we'll provide info on the form!\n\t\t\t//\n\t\t\tif ( button != null &&  button.length === 1 && typeof button.offset == 'function' )\n\t\t\t{\n\t\t\t\tbuttonOffset = button.offset();\n\t\t\t\tvar height = jQuery(window).height();\n\t\t\t\tvar width = jQuery(window).width();\n\t\t\t\t//\n\t\t\t\t//  We have all the components we want the standard button to submit to the server!\n\t\t\t\t//  we will now add input fields to the form we intend to submit.\n\t\t\t\t//\n\n\t\t\t\tvar begintime = jQuery.data(document, 'x_readytime');\n\n\t\t\t\tvar selecttime = 0.0;\n\t\t\t\tif ( begintime !== undefined )\n\t\t\t\t{\n\t\t\t\t\tselecttime = new Date().getTime() - begintime;\n\t\t\t\t}\n\t\t\t\tif ( $Form.length === 1 )\n\t\t\t\t{\n\t\t\t\t\t//  We include the 'hidden' attribute at this point, because of a believe compatibility issue with Internet Explorer!\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_selection', 'value' : buttonIndex } ).appendTo( $Form  );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_choices', 'value' : allButtons.length } ).appendTo( $Form );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_top', 'value' : buttonOffset.top } ).appendTo( $Form  );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_left', 'value' : buttonOffset.left } ).appendTo( $Form );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_window_height', 'value' : height } ).appendTo( $Form );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_window_width', 'value' : width } ).appendTo( $Form );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_select_time', 'value' : selecttime } ).appendTo( $Form );\n\t\t\t\t\tif ( navData )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar pipeSplit = new RegExp( /\\|/ );\n\t\t\t\t\t\tvar resultString = navData.split( pipeSplit )[0];\n\t\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_oldnav', 'value' : resultString } ).appendTo( $Form );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcatch( e )\n\t{\n\t\t//console.log( e );\n\t\t\t}\n\t// Regardless of instrumentation failures, try to submit the form for the user.\n\ttry\n\t{\n\t\t$Form.submit();\n\t}\n\tcatch( e )\n\t{\n\t\t// swallow exceptions !\n\t}\n}\n\n// Function to handle quantity box changes per keystroke, largely to show error style if above max quantity\nfunction qtyBoxInputChanged( sIdSuffix, sAddToCartID )\n{\n\tlet elField = jQuery( \"#quantity_update_\" + sIdSuffix );\n\tlet elCartButton = jQuery( \"#\" + sAddToCartID );\n\tlet elUpdateButton = jQuery( \"#btn_quantity_update_\" + sIdSuffix );\n\n\ttry\n\t{\n\t\tlet sQty = elField.val();\n\t\tlet sQtyMax = elField.attr( 'max' );\n\t\tlet nQty = parseInt( sQty );\n\t\tlet nQtyMax = parseInt( sQtyMax );\n\n\t\tconst sDisabledClass = 'btn_disabled';\n\t\tconst sInvalidClass = 'qty_invalid';\n\n\t\tif ( nQty !== undefined )\n\t\t{\n\t\t\tif ( ( nQtyMax === undefined || isNaN( nQtyMax ) ) || ( !isNaN( nQty ) && nQty > 0 && nQty <= nQtyMax ) )\n\t\t\t{\n\t\t\t\telField.removeClass( sInvalidClass );\n\t\t\t\telCartButton.removeClass( sDisabledClass );\n\t\t\t\telCartButton.prop( 'disabled', false );\n\t\t\t\telUpdateButton.prop( 'disabled', false );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\telField.addClass( sInvalidClass );\n\t\t\t\telCartButton.addClass( sDisabledClass );\n\t\t\t\telCartButton.prop( 'disabled', true );\n\t\t\t\telUpdateButton.prop( 'disabled', true );\n\t\t\t}\n\n\t\t\telUpdateButton.show();\n\t\t}\n\t}\n\tcatch( e )\n\t{\n\t\t// ignore\n\t}\n}\n\n// Function to add a package to a cart, assumes form setup on the page\nfunction updateQtyCart( formName, id )\n{\n\ttry\n\t{\n\t\t// Check for quantity\n\t\tvar quantity = jQuery( '#'+id ).val();\n\t\tif ( quantity !== undefined )\n\t\t{\n\t\t\tvar filterStringForm = 'form[name='+formName+']';\n\t\t\tvar formSelector = jQuery( filterStringForm );\n\t\t\tif ( formSelector.length === 1 )\n\t\t\t{\n\t\t\t\tjQuery('<input type=\"hidden\">').attr({name: 'quantity', 'value': quantity}).appendTo(formSelector);\n\t\t\t}\n\t\t}\n\t}\n\tcatch( e )\n\t{\n\t\t//console.log( e );\n\t\t}\n\t// Regardless of instrumentation failures, try to submit the form for the user.\n\ttry\n\t{\n\t\tdocument.forms[formName].submit();\n\t}\n\tcatch( e )\n\t{\n\t\t// swallow exceptions !\n\t}\n\n}\n\n// Function to add a bundle to a cart, assumes form setup on the page\nfunction addBundleToCart( bundleid, dedupe )\n{\n\ttry\n\t{\n\t\t// Find all of the add to cart buttons displayed on the page\n\t\tvar filterAllButtons='a.btn_addtocart_content';\n\t\t// the filterString can be used to find the element that invoked us, since the subid appears within it\n\t\t// note that href*= specifies that href contains the string\n\t\tvar filterString = 'a[href*=' + bundleid + ']';\n\t\t// within the set of all buttons, get the index of the one that we are dealing with!\n\t\t// To do that, we find the anchor that invoked us within the larger set of add to cart buttons!\n\t\tvar allButtons = jQuery( filterAllButtons );\n\n\n\t\tvar filterStringForm = 'form[name=add_bundle_to_cart_'+bundleid+']';\n\t\tvar $Form = jQuery( filterStringForm );\n\n\t\tif ( !$Form.length || ( $Form[0].getAttribute( 'action' ) || '' ).indexOf( '/freelicense/' ) === -1 )\n\t\t{\n\t\t\tif ( typeof g_bUseNewCartAPI != 'undefined' && g_bUseNewCartAPI && typeof window.AddItemToCart !== 'undefined' )\n\t\t\t{\n\t\t\t\tvar navdata;\n\t\t\t\tif ( typeof GStoreItemData !== 'undefined' )\n\t\t\t\t\tnavdata = $Form.find('input[name=originating_snr]').length > 0 ? GStoreItemData.GetPreviousPageNavParamObj() : GStoreItemData.GetCurrentPageNavParamObj();\n\n\t\t\t\twindow.AddItemToCart( null, bundleid, navdata );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif ( !$Form.length )\n\t\t{\n\t\t\t$Form= $J('<form/>', { name: 'add_bundle_to_cart_' + bundleid, action: 'https://store.steampowered.com/cart/', method: 'POST', style: 'display: none;' } );\n\t\t\t$Form.append( $J('<input/>', { type: 'hidden', name: 'action', value: 'add_to_cart' } ) );\n\t\t\t$Form.append( $J('<input/>', { type: 'hidden', name: 'bundleid', value: bundleid } ) );\n\t\t\t$Form.append( $J('<input/>', { type: 'hidden', name: 'sessionid', value: g_sessionID } ) );\n\n\t\t\t$J(document.body).append( $Form );\n\t\t}\n\n\t\t// Check for quantity\n\t\tvar idx = ( dedupe !== undefined ) ? dedupe : 0;\n\t\tvar quantity = jQuery( '#quantity_update_'+bundleid+'_'+idx ).val();\n\t\tif ( quantity !== undefined )\n\t\t{\n\t\t\tif ( $Form.length === 1 )\n\t\t\t{\n\t\t\t\tjQuery('<input type=\"hidden\">').attr({name: 'quantity', 'value': quantity}).appendTo($Form);\n\t\t\t}\n\t\t}\n\n\t\t// do we have anything to examine?\n\t\tif ( allButtons.length > 0 )\n\t\t{\n\n\t\t\tvar navData = getBestAvailNavData();\n\t\t\tvar button;\n\t\t\tvar buttonOffset = { top : 0, left : 0 };\n\t\t\tvar buttonIndex = allButtons.index( jQuery( filterString ) );\n\t\t\t//\n\t\t\t//  Subscription pages have ambiguous add to cart buttons - we will try to 'dedupe' it !\n\t\t\t//\n\t\t\tif ( buttonIndex === -1 )\n\t\t\t{\n\t\t\t\tif ( dedupe !== undefined )\n\t\t\t\t{\n\t\t\t\t\tbuttonIndex = dedupe;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//  There is a chance this we're mistaken if the .php generation of the page\n\t\t\t\t\t//  didn't generate the addToCart() calls as we expect !\n\t\t\t\t\tbuttonIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\tbutton = allButtons.eq(buttonIndex);\n\n\t\t\t//\n\t\t\t//  If we are certain we know what button was clicked, then we'll provide info on the form!\n\t\t\t//\n\t\t\tif ( button != null &&  button.length === 1 && typeof button.offset == 'function' )\n\t\t\t{\n\t\t\t\tbuttonOffset = button.offset();\n\t\t\t\tvar height = jQuery(window).height();\n\t\t\t\tvar width = jQuery(window).width();\n\t\t\t\t//\n\t\t\t\t//  We have all the components we want the standard button to submit to the server!\n\t\t\t\t//  we will now add input fields to the form we intend to submit.\n\t\t\t\t//\n\t\t\t\tvar begintime = jQuery.data(document, 'x_readytime');\n\t\t\t\tvar selecttime = 0.0;\n\t\t\t\tif ( begintime !== undefined )\n\t\t\t\t{\n\t\t\t\t\tselecttime = new Date().getTime() - begintime;\n\t\t\t\t}\n\t\t\t\tif ( $Form.length === 1 )\n\t\t\t\t{\n\t\t\t\t\t//  We include the 'hidden' attribute at this point, because of a believe compatibility issue with Internet Explorer!\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_selection', 'value' : buttonIndex } ).appendTo( $Form  );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_choices', 'value' : allButtons.length } ).appendTo( $Form );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_top', 'value' : buttonOffset.top } ).appendTo( $Form  );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_left', 'value' : buttonOffset.left } ).appendTo( $Form );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_window_height', 'value' : height } ).appendTo( $Form );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_window_width', 'value' : width } ).appendTo( $Form );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_select_time', 'value' : selecttime } ).appendTo( $Form );\n\t\t\t\t\tif ( navData )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar pipeSplit = new RegExp( /\\|/ );\n\t\t\t\t\t\tvar resultString = navData.split( pipeSplit )[0];\n\t\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_oldnav', 'value' : resultString } ).appendTo( $Form );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcatch( e )\n\t{\n\t\t//console.log( e );\n\t\t\t}\n\t// Regardless of instrumentation failures, try to submit the form for the user.\n\ttry\n\t{\n\t\t$Form.submit();\n\t}\n\tcatch( e )\n\t{\n\t\t// swallow exceptions !\n\t}\n}\n\nfunction addAllDlcToCart()\n{\n\ttry\n\t{\n\t\t// Find all of the add to cart buttons displayed on the page\n\t\tvar filterAllButtons='a.btn_addtocart_content';\n\t\t// the filterString can be used to find the element that invoked us, since the subid appears within it\n\t\t// note that href*= specifies that href contains the string\n\t\tvar filterString = 'a[href*=addAllDlcToCart]';\n\t\t// within the set of all buttons, get the index of the one that we are dealing with!\n\t\t// To do that, we find the anchor that invoked us within the larger set of add to cart buttons!\n\t\tvar allButtons = jQuery( filterAllButtons );\n\t\t// do we have anything to examine?\n\t\tif ( allButtons.length > 0 )\n\t\t{\n\n\t\t\tvar navData = getBestAvailNavData();\n\t\t\tvar button = null;\n\t\t\tvar buttonOffset = { top : 0, left : 0 };\n\t\t\tvar buttonIndex = allButtons.index( jQuery( filterString ) );\n\t\t\tif ( buttonIndex !== -1 )\n\t\t\t{\n\t\t\t\tbutton = allButtons.eq(buttonIndex);\n\t\t\t}\n\t\t\t//\n\t\t\t//  If we are certain we know what button was clicked, then we'll provide info on the form!\n\t\t\t//\n\t\t\tif ( button != null &&  button.length === 1 && typeof button.offset == 'function' )\n\t\t\t{\n\t\t\t\tbuttonOffset = button.offset();\n\t\t\t\tvar height = jQuery(window).height();\n\t\t\t\tvar width = jQuery(window).width();\n\t\t\t\t//\n\t\t\t\t//  We have all the components we want the standard button to submit to the server!\n\t\t\t\t//  we will now add input fields to the form we intend to submit.\n\t\t\t\t//\n\t\t\t\tvar filterStringForm = 'form[name=add_all_dlc_to_cart]';\n\t\t\t\tvar formSelector = jQuery( filterStringForm );\n\t\t\t\tvar begintime = jQuery.data(document, 'x_readytime');\n\t\t\t\tvar selecttime = 0.0;\n\t\t\t\tif ( begintime !== undefined )\n\t\t\t\t{\n\t\t\t\t\tselecttime = new Date().getTime() - begintime;\n\t\t\t\t}\n\t\t\t\tif ( formSelector.length === 1 )\n\t\t\t\t{\n\t\t\t\t\t//  We include the 'hidden' attribute at this point, because of a believe compatibility issue with Internet Explorer!\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_selection', 'value' : buttonIndex } ).appendTo( formSelector  );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_choices', 'value' : allButtons.length } ).appendTo( formSelector );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_top', 'value' : buttonOffset.top } ).appendTo( formSelector  );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_left', 'value' : buttonOffset.left } ).appendTo( formSelector );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_window_height', 'value' : height } ).appendTo( formSelector );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_window_width', 'value' : width } ).appendTo( formSelector );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_select_time', 'value' : selecttime } ).appendTo( formSelector );\n\t\t\t\t\tif ( navData )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar pipeSplit = new RegExp( /\\|/ );\n\t\t\t\t\t\tvar resultString = navData.split( pipeSplit )[0];\n\t\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_oldnav', 'value' : resultString } ).appendTo( formSelector );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcatch( e )\n\t{\n\t\t//console.log( e );\n\t\t\t}\n\n\ttry\n\t{\n\t\tif ( typeof g_bUseNewCartAPI != 'undefined' && g_bUseNewCartAPI && typeof window.AddItemToCart !== 'undefined' )\n\t\t{\n\t\t\tvar $Inputs = $J( 'form[name=add_all_dlc_to_cart' ).find( 'input' );\n\t\t\tvar rgSubIDs = [];\n\n\t\t\tfor ( var i = 0; i < $Inputs.length; i++ )\n\t\t\t{\n\t\t\t\tif ( $Inputs[i].name.startsWith( 'subid' ) )\n\t\t\t\t\trgSubIDs.push( JSON.parse( $Inputs[i].value ) );\n\t\t\t}\n\n\t\t\twindow.AddItemToCart( rgSubIDs.length === 1 ? rgSubIDs[0] : rgSubIDs );\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.forms['add_all_dlc_to_cart'].submit();\n\t\t}\n\n\t}\n\tcatch( e )\n\t{\n\t}\n}\n\nfunction removeFromCart( gid )\n{\n\ttry\n\t{\n\t\t// Find all of the add to cart buttons displayed on the page\n\t\tvar filterAllButtons='a.remove_link';\n\t\t// the filterString can be used to find the element that invoked us, since the subid appears within it\n\t\t// note that href*= specifies that href contains the string\n\t\tvar filterString = 'a[href*=' + gid + ']';\n\t\t// within the set of all buttons, get the index of the one that we are dealing with!\n\t\t// To do that, we find the anchor that invoked us within the larger set of add to cart buttons!\n\t\tvar allButtons = jQuery( filterAllButtons );\n\t\t// do we have anything to examine?\n\n\t\t// do we have anything to examine?\n\t\tif ( allButtons.length > 0 )\n\t\t{\n\t\t\tvar navData = getBestAvailNavData();\n\t\t\tvar buttonIndex = allButtons.index( jQuery( filterString ) );\n\t\t\t//\n\t\t\tvar button = allButtons.filter( jQuery( filterString ) );\n\t\t\tvar buttonOffset = { top : 0, left : 0 };\n\t\t\tif ( button != null &&  button.length === 1 && typeof button.offset == 'function' )\n\t\t\t{\n\t\t\t\tbuttonOffset = button.offset();\n\t\t\t\tvar height = jQuery(window).height();\n\t\t\t\tvar width = jQuery(window).width();\n\t\t\t\t//\n\t\t\t\t//  We have all the components we want the standard button to submit to the server!\n\t\t\t\t//  we will now add input fields to the form we intend to submit.\n\t\t\t\t//\n\t\t\t\tvar filterStringForm = 'form[name=remove_line_item]';\n\t\t\t\tvar formSelector = jQuery( filterStringForm );\n\t\t\t\tvar begintime = jQuery.data(document, 'x_readytime');\n\t\t\t\tvar selecttime = 0.0;\n\t\t\t\tif ( begintime !== undefined )\n\t\t\t\t{\n\t\t\t\t\tselecttime = new Date().getTime() - begintime;\n\t\t\t\t}\n\t\t\t\tif ( formSelector.length === 1 )\n\t\t\t\t{\n\t\t\t\t\t//  We include the 'hidden' attribute at this point, because of a believe compatibility issue with Internet Explorer!\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_selection', 'value' : buttonIndex } ).appendTo( formSelector  );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_choices', 'value' : allButtons.length } ).appendTo( formSelector );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_top', 'value' : buttonOffset.top } ).appendTo( formSelector  );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_left', 'value' : buttonOffset.left } ).appendTo( formSelector );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_window_height', 'value' : height } ).appendTo( formSelector );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_window_width', 'value' : width } ).appendTo( formSelector );\n\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_select_time', 'value' : selecttime } ).appendTo( formSelector );\n\t\t\t\t\tif ( navData )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar pipeSplit = new RegExp( /\\|/ );\n\t\t\t\t\t\tvar resultString = navData.split( pipeSplit )[0];\n\t\t\t\t\t\tjQuery( '<input type=\"hidden\">' ).attr( { name: 'x_oldnav', 'value' : resultString } ).appendTo( formSelector );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcatch( e )\n\t{\n\t\t\t}\n\ttry\n\t{\n\t\tdocument.getElementById('line_item_to_remove_gid').value = gid;\n\t\tdocument.forms['remove_line_item'].submit();\n\t}\n\tcatch( e )\n\t{\n\t\t\t}\n}\n\nfunction GamePurchaseDropdownSelectOption( dropdownName, subId, inCart )\n{\n\t\t$J('#add_to_cart_' + dropdownName + '_value').val( subId );\n\t$J('#add_to_cart_' + dropdownName + '_selected_text').html( $J('#add_to_cart_' + dropdownName + '_menu_option_' + subId).html() );\n\n\t$J('#add_to_cart_' + dropdownName + '_select_option').hide();\n\n\tvar $inCart = $J('#add_to_cart_' + dropdownName + '_in_cart_button');\n\tvar $addCart = $J('#add_to_cart_' + dropdownName + '_add_button');\n\tif ( inCart )\n\t{\n\t\t$addCart.hide();\n\t\t$inCart.show();\n\t\tif ( typeof GPNavFocusChild !== 'undefined' )\n\t\t{\n\t\t\tGPNavFocusChild( $inCart );\n\t\t}\n\t}\n\telse\n\t{\n\t\t$inCart.hide();\n\t\t$addCart.show();\n\t\tif ( typeof GPNavFocusChild !== 'undefined' )\n\t\t{\n\t\t\tGPNavFocusChild( $addCart );\n\t\t}\n\t}\n\n\tif ( window.UseTabletScreenMode && window.UseTabletScreenMode() )\n\t{\n\t\tCModal.DismissActiveModal();\n\t}\n\telse\n\t{\n\t\tHideMenu('game_purchase_dropdown_' + dropdownName + '_region', 'add_to_cart_' + dropdownName + '_menu');\n\t}\n}\n\nfunction GamePurchaseDropdownAddToCart( dropdownName )\n{\n\t\tif ( $J('#add_to_cart_' + dropdownName + '_value').val() == '')\n\t{\n\t\tShowGamePurchaseDropdown( 'game_purchase_dropdown_' + dropdownName + '_region', 'add_to_cart_' + dropdownName + '_menu' );\n\t}\n\telse\n\t{\n\t\taddToCart( dropdownName );\n\t}\n}\n\nfunction ShowGamePurchaseDropdown( elemLink, elemPopup )\n{\n\tvar $Link = $JFromIDOrElement(elemLink);\n\tvar $Popup = $JFromIDOrElement(elemPopup);\n\n\tvar nWidth = $Link.outerWidth();\n\t$Popup.css( 'min-width', nWidth );\n\n\tif ( window.UseTabletScreenMode && window.UseTabletScreenMode() )\n\t{\n\t\tvar $Content = $Popup.clone();\n\t\t$Content.attr('data-panel', '{\"maintainY\":true,\"autoFocus\":true}' );\n\t\t$Content.css( 'position', 'relative' );\n\t\tvar $Dialog = ShowDialog( 'Выберите способ покупки', $Content.show() );\n\t\t$Dialog.AdjustSizing();\n\t}\n\telse\n\t{\n\t\tShowMenu( elemLink, elemPopup, 'right', 'bottom' );\n\t}\n}\n\nfunction AgeGateClear()\n{\n\tWebStorage.SetCookie('birthtime', 0, -1);\n\twindow.location.reload();\n}\n\nfunction InitHorizontalAutoSliders()\n{\n\t$J('.store_horizontal_autoslider' ).each( function() {\n\t\tvar $Scroll = $J(this);\n\t\tvar $Wrapper = $Scroll.wrap( $J('<div/>', {'class': 'store_horizontal_autoslider_ctn' } ) ).parent();\n\t\tvar $SliderCtn = $J('<div/>', {'class': 'slider_ctn store_autoslider'} );\n\t\tvar $SliderLeft = $J('<div/>', {'class': 'slider_left'} ).append($J('<span/>'));\n\t\tvar $SliderRight = $J('<div/>', {'class': 'slider_right'} ).append($J('<span/>'));\n\t\tvar $Slider = $J('<div/>', {'class': 'slider' } );\n\t\t$SliderCtn.append(\n\t\t\t$SliderLeft, $SliderRight,\n\t\t\t$J('<div/>', {'class': 'slider_bg' } ),\n\t\t\t$Slider.append( $J('<div/>', {'class': 'handle'} ) )\n\t\t);\n\t\t$Wrapper.after( $SliderCtn );\n\t\tvar fnFixHeight = function() { $Wrapper.height( $Scroll[0].clientHeight ); };\n\n\t\tif ( $Scroll.data( 'usability' ) )\n\t\t\t$SliderCtn.attr( 'data-usability', $Scroll.data( 'usability' ) );\n\n\t\t$Wrapper.on('v_contentschanged.AutoSlider', function() {\n\t\t\tfnFixHeight();\n\t\t\t$Wrapper.find('img' ).one('load', fnFixHeight );\n\t\t} );\n\t\t$J(window ).on('resize.AutoSlider', fnFixHeight );\n\n\t\t$Scroll.attr( 'data-panel', '{\"maintainX\":true,\"bFocusRingRoot\":true,\"flow-children\":\"row\"}' );\n\n\t\twindow.setTimeout( function() {\n\t\t\t$Wrapper.trigger('v_contentschanged.AutoSlider');\n\n\t\t\tvar Slider = new CScrollSlider( $Scroll, $SliderCtn );\n\n\t\t\tvar fnGetScrollIncrement = function() {\n\t\t\t\tvar $TryChild = $Scroll;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\t$TryChild = $TryChild.children().first();\n\t\t\t\t\tif ( $TryChild.width() && $TryChild.outerWidth() < $Scroll.width() )\n\t\t\t\t\t{\n\t\t\t\t\t\t// optional param determines whether or not we include margin\n\t\t\t\t\t\t// As a note, if you use selective margin make sure you're using\n\t\t\t\t\t\t// :not(:last-child) as it'll peek the first and you want to ensure\n\t\t\t\t\t\t// that element has the expected margin.\n\t\t\t\t\t\treturn $TryChild.outerWidth( true );\n\t\t\t\t\t}\n\t\t\t\t} while ( $TryChild.length );\n\n\t\t\t\treturn $Wrapper.width() / 3;\n\t\t\t};\n\n\t\t\t$SliderLeft.click( function() {\n\t\t\t\tSlider.SetValue( Slider.GetValue() - fnGetScrollIncrement(), 250 );\n\t\t\t});\n\t\t\t$SliderRight.click( function() {\n\t\t\t\tSlider.SetValue( Slider.GetValue() + fnGetScrollIncrement(), 250 );\n\t\t\t});\n\n\t\t}, 1 );\n\t});\n\n\t$J('.store_horizontal_minislider' ).each( function() {\n\t\tvar $Scroll = $J(this);\n\t\tvar $Wrapper = $Scroll.wrap( $J('<div/>', {'class': 'store_horizontal_minislider_ctn' } ) ).parent();\n\t\tvar $SliderLeft = $J('<div/>', {'class': 'slider_left'} ).append($J('<span/>'));\n\t\tvar $SliderRight = $J('<div/>', {'class': 'slider_right'} ).append($J('<span/>'));\n\n\t\t$Wrapper.append( $SliderLeft, $SliderRight );\n\n\t\tvar fnShowHideButtons = function()\n\t\t{\n\t\t\tvar nTallestChild = 0;\n\t\t\t$Scroll.children().each( function() {\n\t\t\t\tnTallestChild = Math.max( nTallestChild, $J(this ).outerHeight() );\n\t\t\t});\n\t\t\t$Wrapper.css('height', nTallestChild );\n\n\t\t\tif ( $Scroll.scrollLeft() <= 1 )\n\t\t\t\t$SliderLeft.hide();\n\t\t\telse\n\t\t\t\t$SliderLeft.show();\n\n\t\t\tif ( $Scroll.scrollLeft() + $Scroll.width() < $Scroll[0].scrollWidth - 1 )\n\t\t\t\t$SliderRight.show();\n\t\t\telse\n\t\t\t\t$SliderRight.hide();\n\t\t};\n\n\t\t$Scroll.on( 'scroll.AutoSlider v_contentschagned.AutoSlider', fnShowHideButtons );\n\t\t$J(window ).on('resize.AutoSlider', fnShowHideButtons );\n\n\t\t$SliderLeft.click( function() {\n\t\t\t$Scroll.animate( {scrollLeft: Math.max( 0, $Scroll.scrollLeft() - $Wrapper.width() ) } );\n\t\t\tfnShowHideButtons();\n\t\t} );\n\t\t$SliderRight.click( function() {\n\t\t\t$Scroll.animate( {scrollLeft: Math.min( $Scroll[0].scrollWidth - $Scroll.width(), $Scroll.scrollLeft() + $Wrapper.width() ) } );\n\t\t\tfnShowHideButtons();\n\t\t} );\n\n\t\twindow.setTimeout( fnShowHideButtons, 1 );\n\t});\n}\n\nfunction PreloadImages( elElement )\n{\n\t$J(elElement).find(\"*[data-background-image-url]\").each(function(i, j){\n\t\tvar $elTarget = $J(j);\n\t\t$elTarget.css({'background-image': 'url(' + $elTarget.data('background-image-url') + ')' });\n\t});\n\n\t$J(elElement).find(\"img[data-image-url]\").each(function(i, j){\n\t\tvar $elTarget = $J(j);\n\t\t$elTarget.attr('src', $elTarget.data('image-url') );\n\t});\n\n}\n\n\n// Common glue logic for a carousel of some kind\nvar CGenericCarousel = function( $elContainer, nSpeed, fnOnFocus, fnOnBlur, fnClickThumb, bNoWrap )\n{\n\tthis.$elContainer = $elContainer;\n\tthis.nSpeed = nSpeed;\n\tthis.fnOnFocus = fnOnFocus;\n\tthis.fnOnBlur = fnOnBlur;\n\tthis.fnClickThumb = fnClickThumb;\n\tthis.bNoWrap = bNoWrap;\n\tthis.nIndex = 0;\n\n\tthis.$elArrowLeft = $J('.arrow.left', this.$elContainer);\n\tthis.$elArrowRight = $J('.arrow.right', this.$elContainer);\n\n\tthis.UpdateItems();\n\tPreloadImages( this.$elItems[ this.nIndex ] );\n\n\tif ( window.UseTabletScreenMode && window.UseTabletScreenMode() )\n\t{\n\t\tPreloadImages( $elContainer );\n\t}\n\n\t// get ready to preload images when we scroll.  Delay this a bit because these are low priority\n\t//\tand finding them forces layout via a slow jquery :visible call\n\tif ( this.nSpeed )\n\t\tsetTimeout( this.HintNearbyCapsules.bind(this), this.nSpeed * 750 );\n\n\tthis.fnOnFocus( this.nIndex );\n\n\tvar instance = this;\n\n\tthis.fnMouseOver = function(){\n\t\tclearInterval( instance.timerAdvance );\n\t};\n\n\tthis.fnMouseOut = function(){\n\n\t\tif( instance.timerAdvance )\n\t\t\tclearInterval( instance.timerAdvance );\n\n\t\tif( instance.nSpeed > 0 )\n\t\t{\n\t\t\tinstance.timerAdvance = setInterval ( function ()\n\t\t\t{\n\t\t\t\tif( !instance.bIsResponsive() )\n\t\t\t\t\tinstance.Advance ();\n\t\t\t}, nSpeed * 1000 );\n\t\t}\n\t};\n\n\tthis.fnMouseOut();\n\n\t$elContainer.bind('mouseover', function(e) { instance.fnMouseOver(); } );\n\t$elContainer.bind('mouseout', function(e) { instance.fnMouseOut(); }  );\n\t// If we get a scroll event, and we're in respondive, hint all remaining images\n\tvar $Parent = this.$elItems.parent();\n\t$Parent.bind('scroll', function(e) { if( instance.bIsResponsive() ) PreloadImages( $elContainer ); } );\n\n\t// add panel attributes, and force an update as this element is already on the page so legacyweb doesn't see this change\n\t$Parent.attr( 'data-panel', '{\"bFocusRingRoot\":true,\"flow-children\":\"row\"}' );\n\tif ( typeof ForceUpdateFocusElements != 'undefined' )\n\t\tForceUpdateFocusElements( $Parent );\n\n\t// Only bind a mouseover thumb event if we have one.\n\tif( fnClickThumb ) {\n\n\t\tthis.$elThumbs.each(function (i, j)\n\t\t{\n\n\t\t\t$J(j).bind('click touchstart', (function( index, ele ) {\n\t\t\t\treturn function() {\n\t\t\t\t\tinstance.fnClickThumb( index, ele );\n\t\t\t\t};}(i, j) )\n\t\t\t);\n\t\t});\n\t}\n\n\t// Bind arrows (if we have them)\n\tthis.$elArrowLeft.click( function(e){ instance.Advance(-1); e.preventDefault(); return true; });\n\tthis.$elArrowRight.click( function(e){ instance.Advance(); e.preventDefault(); return true; });\n\n\tthis.$elContainer.on('v_gamepadpress', function( e, button ) {\n\t\tif ( button.button == 'BUMPER_BACK' )\n\t\t{\n\t\t\tinstance.Advance( -1, true );\n\t\t\te.stopPropagation();\n\t\t}\n\t\telse if ( button.button == 'BUMPER_FORWARD' )\n\t\t{\n\t\t\t// -1 means go back 1, any other number means \"go to that index\".\n\t\t\tinstance.Advance( undefined, true );\n\t\t\te.stopPropagation();\n\t\t}\n\t}).on('focusin', function( e ) {\n\t\tif ( e.target != e.currentTarget )\n\t\t{\n\t\t\t// focus on a child element; make sure it's in view\n\t\t\tinstance.$elItems.each( function ( index ) {\n\t\t\t\t// $elItems are caps in main cluster, but pages in others\n\t\t\t\tif ( $J.contains( this, e.target ) || this == e.target )\n\t\t\t\t{\n\t\t\t\t\tif ( !$J(this).hasClass('focus') )\n\t\t\t\t\t\tinstance.Advance( index );\n\t\t\t\t\treturn false; // stop iterating\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tinstance.fnMouseOver();\n\t}).on('focusout', function() {\n\t\tinstance.fnMouseOut();\n\t});\n\n\tif( this.$elThumbs.length < 2 )\n\t{\n\t\tthis.$elThumbs.parent().css({'visibility':'hidden'})\n\t}\n\n\tthis.UpdateControls();\n\n};\n\n// Advances the carousel by one. Optionally pass in a specific index to advance to.\nCGenericCarousel.prototype.UpdateControls = function( )\n{\n\t// Only one item, so hide the arrows since they're not useful.\n\tif( this.nItems == 1 )\n\t{\n\t\tthis.$elArrowLeft.hide();\n\t\tthis.$elArrowRight.hide();\n\t\treturn;\n\t}\n\n\t// Our carousel does not wrap, so conditionally show/hider arrows\n\tif( this.bNoWrap )\n\t{\n\t\tif( this.nIndex == 0 )\n\t\t\tthis.$elArrowLeft.hide();\n\t\telse\n\t\t\tthis.$elArrowLeft.show();\n\n\t\tif( this.nIndex == this.nItems-1 )\n\t\t\tthis.$elArrowRight.hide();\n\t\telse\n\t\t\tthis.$elArrowRight.show();\n\n\t}\n\telse\n\t{\n\t\tthis.$elArrowLeft.show();\n\t\tthis.$elArrowRight.show();\n\t\treturn;\n\t}\n\n\n\n};\n\n// Start loading images further down the rotation.\nCGenericCarousel.prototype.HintNearbyCapsules = function( )\n{\n\tPreloadImages( this.$elItems[ this.nIndex ] );\n\n\t// If we're going to auto-scroll, hint the next item.\n\tif( this.nSpeed > 0 )\n\t{\n\t\tvar nNextIndex = this.GetNextValidIndex();\n\t\tvar elNextElement = this.$elItems[ nNextIndex ];\n\t\tPreloadImages( elNextElement );\n\t}\n};\n\n\nCGenericCarousel.prototype.UpdateItems = function()\n{\n\tthis.$elThumbs = $J('.carousel_thumbs', this.$elContainer).children();\n\tthis.$elItems = $J('.carousel_items', this.$elContainer).children();\n\tthis.nItems = this.$elItems.length;\n}\n\nCGenericCarousel.prototype.GetNextValidIndex = function( nNewIndex )\n{\n\tif( this.nItems == 0 )\n\t\treturn false;\n\n\tvar nIndex = this.nIndex;\n\n\tvar rgTargets = this.$elItems;\n\tvar nSearched = 0;\n\n\tif( nNewIndex < 0 ) // Allow index of -1 to go backwards.\n\t{\n\t\t// Skip hidden items\n\t\tdo\n\t\t{\n\t\t\tnIndex = ( nIndex + nNewIndex ) % this.nItems;\n\n\t\t\t// JS's % operator doesn't wrap, so we need to fix it...\n\t\t\tif( nIndex < 0 )\n\t\t\t\tnIndex += this.nItems;\n\n\t\t}\n\t\twhile( !$J( rgTargets[ nIndex ] ).is( \":visible\" ) && nSearched++ < this.nItems );\n\t}\n\telse if( nNewIndex !== undefined )\n\t{\n\t\tif( nIndex == nNewIndex )\n\t\t\treturn false\n\t\treturn nNewIndex;\n\t}\n\telse\n\t{\n\t\t// Skip hidden items\n\t\tdo\n\t\t{\n\t\t\tnIndex = ( nIndex + 1 ) % this.nItems;\n\t\t}\n\t\twhile( !$J( rgTargets[ nIndex ] ).is( \":visible\" ) && nSearched++ < this.nItems );\n\n\t}\n\n\treturn nIndex;\n}\n\nCGenericCarousel.prototype.bIsResponsive = function( )\n{\n\treturn window.UseSmallScreenMode && window.UseSmallScreenMode();\n}\n\nCGenericCarousel.prototype.Advance = function( nNewIndex, bApplyFocus )\n{\n\t\tif( this.bIsResponsive() && !window.UseTabletScreenMode() )\n\t{\n\t\treturn this.ResponsiveAdvance(nNewIndex );\n\t}\n\n\tif( this.nItems == 0 )\n\t\treturn;\n\n\tvar nNextIndex = this.GetNextValidIndex( nNewIndex );\n\tif( nNextIndex == this.nIndex || nNextIndex === false )\n\t\treturn;\n\n\tthis.fnOnBlur( this.nIndex );\n\tthis.fnOnFocus( nNextIndex );\n\tthis.nIndex = nNextIndex;\n\n\tif ( bApplyFocus && typeof GPNavFocusChild !== 'undefined' )\n\t\tGPNavFocusChild( this.$elItems[this.nIndex] );\n\n\tthis.UpdateControls();\n\tthis.HintNearbyCapsules();\n}\n\n// Advance function may be (totally is) different in responsive mode\nCGenericCarousel.prototype.ResponsiveAdvance = function( nNewIndex )\n{\n\tvar $elTarget = this.$elItems.parent();\n\tvar nMaxScroll = this.$elItems.outerWidth( true ) * this.nItems - $elTarget.innerWidth();\n\tvar nCurrentScroll = $elTarget.scrollLeft();\n\tvar nScrollRate = this.$elItems.outerWidth( true );\n\tif( nScrollRate > $elTarget.innerWidth() * 1.1 )\n\t\tnScrollRate = $elTarget.innerWidth();\n\n\tvar nTargetScroll = nCurrentScroll + ( nNewIndex < 0 ? -1 : 1 ) * nScrollRate;\n\n\tif( nCurrentScroll == nMaxScroll && nCurrentScroll > nCurrentScroll)\n\t\tnTargetScroll = 0;\n\n\tif( nTargetScroll > nMaxScroll )\n\t\tnTargetScroll = nMaxScroll;\n\n\tif( nTargetScroll < 0 )\n\t\tnTargetScroll = 0;\n\n\t// Hintload capsules we're about to show\n\tthis.$elItems.each( function(i, j) {\n\t\tvar $el = $J(j);\n\t\tvar rgOffset = $el.offset();\n\t\tif( rgOffset.left < nScrollRate * 2 )\n\t\t{\n\t\t\tPreloadImages( $el );\n\t\t}\n\t});\n\n\t$J( $elTarget ).stop().animate({scrollLeft: nTargetScroll}, 800);\n\n}\n\n// Carousel which adds the 'focus' class to the active element. Can be used for fading carousels\n// @todo: This needs to be detangled from CGenericCarousel a bit more to be useful in other applications.....\nfunction CreateFadingCarousel( $elContainer, nSpeed, bNoWrap, fnOnBlur )\n{\n\n\tvar fnOnFocus = function(  nIndex )\n\t{\n\t\tthis.$elThumbs.removeClass( 'focus' );\n\t\tthis.$elItems.removeClass( 'focus' );\n\t\tthis.$elItems.attr( 'aria-hidden', true );\n\n\t\t$J( this.$elThumbs[nIndex] ).addClass('focus');\n\t\t$J( this.$elItems[nIndex] ).addClass('focus');\n\t\t$J( this.$elItems[nIndex] ).attr( 'aria-hidden', false );\n\t\tif ( typeof GDynamicStore != 'undefined' && GDynamicStore.m_bLoadComplete ) {\n\t\t\tGDynamicStore.s_ImpressionTracker.TrackAppearanceIfVisible(this.$elItems[nIndex]);\n\t\t}\n\t}\n\n\tvar fnMouseOverThumb = function( index, element )\n\t{\n\t\tthis.Advance(index);\n\t};\n\tif( !fnOnBlur )\n\t\tfnOnBlur = function(){};\n\n\treturn new CGenericCarousel( $elContainer, nSpeed, fnOnFocus, fnOnBlur, fnMouseOverThumb, bNoWrap );\n\n}\n\n/**\n * Sets up a form to automagically save itself when edited.\n * Note: Ajax requests inside fnOnChange should bind their first param to async\n * @param elForm\n * @param fnOnChange\n * @constructor\n */\nfunction RegisterAutoSaveForm( elForm, fnOnChange )\n{\n\t// Time to wait before saving a changed element that hasn't explicitly lost focus\n\tvar nSaveDelay = 5000; // 5 seconds\n\n\t// Attempt to save if we're closing the tab in a dirty state\n\t$J( window ).on( 'unload', function(){\n\t\t$J( elForm ).trigger('saveform');\n\t} );\n\n\t$J( elForm ).on( 'saveform', function(){\n\n\t\tif (!$J.contains(document, elForm))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t$J( 'input[type=text],input[type=radio],input[type=checkbox],select,textarea', elForm ).trigger('save');\n\t});\n\n\t// Text elements\n\t$J( 'input[type=text],textarea', elForm ).each(function(index, element ){\n\t\tvar curVal = element.value;\n\t\tvar timer = null;\n\n\t\tvar fnUpdateIfChanged = function( bAsync ){\n\t\t\tif( element.value != curVal )\n\t\t\t{\n\t\t\t\tcurVal = element.value;\n\t\t\t\tfnOnChange ( bAsync );\n\t\t\t}\n\t\t};\n\n\t\t$J(element).on('save', fnUpdateIfChanged.bind(null, false ) );\n\n\t\t$J(element).on('keyup', function(){\n\t\t\tif( timer != null )\n\t\t\t\tclearTimeout( timer );\n\t\t\ttimer = setTimeout( fnUpdateIfChanged.bind(null, true ), nSaveDelay );\n\t\t});\n\t});\n\n\t// input types that use .checked\n\t$J( 'input[type=checkbox],input[type=radio]', elForm ).each(function(index, element ){\n\t\tvar curVal = element.checked;\n\t\tvar timer = null;\n\n\t\tvar fnUpdateIfChanged = function( bAsync ){\n\t\t\tif( element.checked != curVal )\n\t\t\t{\n\t\t\t\tcurVal = element.checked;\n\t\t\t\tfnOnChange ( bAsync );\n\t\t\t}\n\t\t};\n\n\t\t$J(element).on('save', fnUpdateIfChanged.bind(null, false ));\n\n\t\t$J(element).on('change', function(){\n\t\t\tif( timer != null )\n\t\t\t\tclearTimeout( timer );\n\t\t\ttimer = setTimeout( fnUpdateIfChanged.bind(null, true ), nSaveDelay );\n\t\t});\n\t});\n\n\t// select boxes\n\t$J( 'select', elForm ).each(function(index, element ){\n\t\tvar curVal = element.selectedIndex;\n\t\tvar timer = null;\n\t\tconsole.log(element);\n\n\t\tvar fnUpdateIfChanged = function( bAsync ){\n\t\t\tif( element.selectedIndex != curVal )\n\t\t\t{\n\t\t\t\tcurVal = element.selectedIndex;\n\t\t\t\tfnOnChange ( bAsync );\n\t\t\t}\n\t\t};\n\n\t\t$J(element).on('save', fnUpdateIfChanged.bind(null, false ));\n\n\t\t$J(element).on('change', function(){\n\t\t\tif( timer != null )\n\t\t\t\tclearTimeout( timer );\n\t\t\ttimer = setTimeout( fnUpdateIfChanged.bind(null, true ), nSaveDelay );\n\t\t});\n\t});\n}\n\nfunction RecordAJAXPageView( url )\n{\n\tif ( typeof ga != \"undefined\" && ga )\n\t{\n\t\tvar rgURLs = [ 'https://store.steampowered.com/', 'https://store.steampowered.com/' ];\n\t\tfor ( var i = 0; i < rgURLs.length; ++i )\n\t\t{\n\t\t\tvar baseURL = rgURLs[i];\n\t\t\tvar idx = url.indexOf( baseURL );\n\t\t\tif ( idx != -1 )\n\t\t\t{\n\t\t\t\turl = url.substring( idx + baseURL.length );\n\t\t\t}\n\t\t\tga( 'send', 'pageview', url );\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n\nfunction FollowCuratorWithCallback( clanID, bFollow, onComplete )\n{\n\tvar bHaveUser = ( g_AccountID != 0 );\n\tif ( !bHaveUser )\n\t{\n\t\tShowAlertDialog(\"\\u0412\\u043e\\u0439\\u0434\\u0438\\u0442\\u0435 \\u0432 \\u0441\\u0438\\u0441\\u0442\\u0435\\u043c\\u0443\", \"\\u0427\\u0442\\u043e\\u0431\\u044b \\u043f\\u043e\\u0434\\u043f\\u0438\\u0441\\u0430\\u0442\\u044c\\u0441\\u044f \\u043d\\u0430 \\u043a\\u0443\\u0440\\u0430\\u0442\\u043e\\u0440\\u0430, \\u0432\\u043e\\u0439\\u0434\\u0438\\u0442\\u0435 \\u0432 \\u0430\\u043a\\u043a\\u0430\\u0443\\u043d\\u0442\");\n\t\treturn;\n\t}\n\n\t$J.post(\n\t\t'https://store.steampowered.com/curators/ajaxfollow',\n\t\t{ 'clanid' : clanID, 'sessionid' : g_sessionID, 'follow' : bFollow ? 1 : 0 },\n\t\tfunction( data )\n\t\t{\n\t\t\tonComplete( bFollow );\n\t\t},\n\t\t'json'\n\t).fail( function()\n\t\t{\n\t\t\tShowAlertDialog( 'Ошибка', 'Не удалось подписаться на куратора Steam. Возможные причины:<ul><li>Нельзя подписаться на куратора, которого вы скрыли;</li><li>Нельзя подписаться более чем на 100 кураторов;</li><li>Права вашего аккаунта ограничены.</li></ul>' );\n\t\t}\n\t);\n\treturn false;\n}\n\nfunction IgnoreCuratorWithCallback( clanID, bIgnore, onComplete )\n{\n\tvar bHaveUser = ( g_AccountID != 0 );\n\tif ( !bHaveUser )\n\t{\n\t\tShowAlertDialog(\"\\u0412\\u043e\\u0439\\u0434\\u0438\\u0442\\u0435 \\u0432 \\u0430\\u043a\\u043a\\u0430\\u0443\\u043d\\u0442\", \"\\u0427\\u0442\\u043e\\u0431\\u044b \\u0441\\u043a\\u0440\\u044b\\u0442\\u044c \\u043a\\u0443\\u0440\\u0430\\u0442\\u043e\\u0440\\u0430 Steam, \\u043d\\u0443\\u0436\\u043d\\u043e \\u0432\\u043e\\u0439\\u0442\\u0438 \\u0432 \\u0430\\u043a\\u043a\\u0430\\u0443\\u043d\\u0442.\");\n\t\treturn;\n\t}\n\n\t$J.post(\n\t\t'https://store.steampowered.com/curators/ajaxignore',\n\t\t{ 'clanid' : clanID, 'sessionid' : g_sessionID, 'ignore' : bIgnore ? 1 : 0 },\n\t\tfunction( data )\n\t\t{\n\t\t\tonComplete( bIgnore );\n\t\t\tGDynamicStore.InvalidateCache();\n\t\t},\n\t\t'json'\n\t).fail( function()\n\t\t{\n\t\t\tShowAlertDialog( 'Ошибка', 'Не удалось скрыть куратора Steam.<br>\\nВы не можете скрыть кураторов, на которых подписались.' );\n\t\t}\n\t);\n\treturn false;\n}\n\n\nvar CUsabilityTracker = function()\n{\n\tthis.m_strEndpoint = '';\n\tthis.m_fnPostCallback = null;\n\tthis.m_schUpload = null;\n\tthis.m_tsLoaded = performance.now();\n\tthis.m_rgScrollToElements = null;\n\tthis.m_stats = {\n\t\tmaxScroll: 0,\n\t\twindowWidth: 0,\n\t\twindowHeight: 0,\n\t\tscrolledToSection: 0,\n\t\tevents: []\n\t}\n}\n\nCUsabilityTracker.prototype.Init = function( strEndpoint )\n{\n\tthis.m_strEndpoint = strEndpoint;\n\tthis.ResetStats();\n\n\tvar _this = this;\n\t$Window = $J( window );\n\t$Window.unload( function()\n\t{\n\t\t_this.OnWindowUnload();\n\t});\n\n\t$Window.on( 'scroll', function()\n\t{\n\t\t_this.SetScrollPosition();\n\t});\n\n\t$Window.on( 'click', function( e )\n\t{\n\t\t_this.HandleWindowClick( e );\n\t});\n}\n\nCUsabilityTracker.prototype.ResetStats = function()\n{\n\tthis.m_stats.windowWidth = window.innerWidth;\n\tthis.m_stats.windowHeight = window.innerHeight;\n\tthis.m_stats.events = [];\n\tthis.m_stats.maxScroll = this.GetScrollPosition();\n\tthis.m_stats.scrolledToSection = 0;\n}\n\nCUsabilityTracker.prototype.ScheduleUpload = function()\n{\n\tthis.CancelScheduledUpload();\n\n\tvar _this = this;\n\tthis.m_schUpload = setTimeout( function() { _this.PostStats() }, 3 * 60 * 1000 );\n}\n\nCUsabilityTracker.prototype.CancelScheduledUpload = function()\n{\n\tif ( this.m_schUpload === null )\n\t\treturn;\n\n\tclearTimeout( this.m_schUpload );\n\tthis.m_schUpload = null;\n}\n\nCUsabilityTracker.prototype.GetScrollPosition = function()\n{\n\tvar nCurrent = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n\treturn nCurrent + window.innerHeight;\n}\n\nCUsabilityTracker.prototype.SetScrollPosition = function()\n{\n\t// ignore scrolling for 1/2 second after page load\n\tif ( (performance.now() - this.m_tsLoaded) < 500.0 )\n\t\treturn;\n\n\tvar nCurrent = this.GetScrollPosition();\n\n\t// always skip updating and scheduling a new scroll if previous matches, including across page reloads that automatically scroll down\n\tif ( nCurrent <= this.m_stats.maxScroll )\n\t\treturn;\n\n\tthis.m_stats.maxScroll = nCurrent;\n\tthis.CheckScrollToElements();\n\tthis.ScheduleUpload();\n}\n\nCUsabilityTracker.prototype.OnWindowUnload = function ()\n{\n\tthis.PostStats();\n}\n\nCUsabilityTracker.prototype.HandleWindowClick = function( e )\n{\n\tvar $Target = $J( e.target );\n\tif ( !$Target )\n\t\treturn;\n\n\tvar $Tracked = $Target.closest( '[data-usability]');\n\tif ( !$Tracked || $Tracked.length == 0 )\n\t\treturn;\n\n\tthis.AddEvent( $Tracked.data( 'usability' ) );\n}\n\nCUsabilityTracker.prototype.AddEvent = function( eEvent )\n{\n\tfor ( var i = 0; i < this.m_stats.events.length; i++ )\n\t{\n\t\tif ( this.m_stats.events[i] == eEvent )\n\t\t\treturn;\n\t}\n\n\tthis.m_stats.events.push( eEvent );\n\tthis.ScheduleUpload();\n}\n\nCUsabilityTracker.prototype.IncrementStat = function( strStat, nValue )\n{\n\tif ( this.m_stats[strStat] === undefined )\n\t\tthis.m_stats[strStat] = 0;\n\n\tthis.m_stats[strStat] = this.m_stats[strStat] + nValue;\n}\n\nCUsabilityTracker.prototype.CheckScrollToElements = function()\n{\n\tif ( this.m_rgScrollToElements === null )\n\t\tthis.m_rgScrollToElements = $J( '[data-usability-scroll]' );\n\n\tvar nBottomOfScreen = this.GetScrollPosition();\n\tfor ( var i = this.m_rgScrollToElements.length - 1; i >= 0; i-- )\n\t{\n\t\tvar $element = $J( this.m_rgScrollToElements[i] );\n\t\tif ( !$element.is(':visible') )\n\t\t\tcontinue;\n\n\t\tvar nOffset = $element.offset().top;\n\t\tif ( nOffset > nBottomOfScreen )\n\t\t\tcontinue;\n\n\t\tthis.SetScrollToSection( $element.data( 'usability-scroll' ) );\n\t}\n}\n\nCUsabilityTracker.prototype.SetScrollToSection = function( eEvent )\n{\n\tif ( this.m_stats.scrolledToSection < eEvent )\n\t{\n\t\tthis.m_stats.scrolledToSection = eEvent;\n\t\tthis.ScheduleUpload();\n\t}\n}\n\nCUsabilityTracker.prototype.SetPostCallback = function( fnCallback )\n{\n\tthis.m_fnPostCallback = fnCallback;\n}\n\nCUsabilityTracker.prototype.PostStats = function()\n{\n\t// if no scheduled upload, stats aren't dirty\n\tif ( this.m_schUpload === null )\n\t\treturn;\n\n\tthis.CancelScheduledUpload();\n\n\t\tthis.m_stats.windowWidth = window.innerWidth;\n\tthis.m_stats.windowHeight = window.innerHeight;\n\n\t\tif ( this.m_fnPostCallback )\n\t\tthis.m_fnPostCallback( this.m_stats );\n\n\tvar strStats = JSON.stringify( this.m_stats );\n\tvar strURL = this.m_strEndpoint;\n\tvar bSupportsBeacon = typeof navigator.sendBeacon != 'undefined';\n\tif ( bSupportsBeacon )\n\t{\n\t\tvar fdParams = new FormData();\n\t\tfdParams.append( 'stats', strStats );\n\t\tnavigator.sendBeacon( strURL, fdParams );\n\t}\n\telse\n\t{\n\t\t$J.ajax(\n\t\t{\n\t\t\turl: strURL,\n\t\t\tdata: { stats: strStats },\n\t\t\tdataType: 'json',\n\t\t\ttype: 'POST'\n\t\t})\n\t\t.done( function( data )\n\t\t{\n\t\t});\n\n\t\t// if we couldn't send a beacon, we try to busy wait for a bit so the AJAX request has time\n\t\t// to reach the servers.\n\t\tvar iters = 0;\n\t\tvar start = new Date().getMilliseconds();\n\t\twhile ( iters < 10000000 && ( new Date().getMilliseconds() - start ) < 30 ) { iters++; }\n\t}\n\n\tthis.ResetStats();\n}\n\nvar g_usabilityTracker = null;\nfunction InitUsabilityTracker( strEndpoint )\n{\n\tif ( !g_usabilityTracker )\n\t{\n\t\tg_usabilityTracker = new CUsabilityTracker();\n\t\tg_usabilityTracker.Init( strEndpoint );\n\t}\n\n\treturn g_usabilityTracker;\n}\n\nfunction GetUsabilityTracker()\n{\n\treturn g_usabilityTracker;\n}\n\nfunction ScrollToTopStoreMobileAware()\n{\n\tvar bUseSmallScreenMode = window.UseSmallScreenMode && window.UseSmallScreenMode();\n\tvar bIsMobileClient = $J('html').is('.mobile_client:not(.legacy_mobile)')\n\tif ( bUseSmallScreenMode && !bIsMobileClient )\n\t{\n\t\tvar $Window = $J( window );\n\t\t$Window.scrollTop( $J( '#store_header' ).height() );\n\t}\n\telse\n\t{\n\t\twindow.scrollTo( 0, 0 );\n\t}\n}\n\n\n"
          },
          "redirectURL": "",
          "headersSize": 587,
          "bodySize": 24074
        },
        "cache": {},
        "timings": {
          "blocked": -1,
          "dns": 0,
          "connect": 0,
          "ssl": 0,
          "send": 0,
          "wait": 844,
          "receive": 6
        },
        "time": 850,
        "_securityState": "secure",
        "serverIPAddress": "104.18.42.105",
        "connection": "443",
        "pageref": "page_2"
      },
      {
        "startedDateTime": "2025-01-07T15:17:36.984+07:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "https://store.cloudflare.steamstatic.com/public/javascript/dynamicstore.js?v=OzwSXx1UJWs8&l=russian&_cdn=cloudflare",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "Host",
              "value": "store.cloudflare.steamstatic.com"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (X11; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "DNT",
              "value": "1"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "no-cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "cross-site"
            },
            {
              "name": "If-Modified-Since",
              "value": "Mon, 20 Apr 1970 06:43:19 GMT"
            },
            {
              "name": "If-None-Match",
              "value": "\"snM8UYxzKWTX\""
            },
            {
              "name": "Priority",
              "value": "u=2"
            },
            {
              "name": "TE",
              "value": "trailers"
            }
          ],
          "cookies": [],
          "queryString": [
            {
              "name": "v",
              "value": "OzwSXx1UJWs8"
            },
            {
              "name": "l",
              "value": "russian"
            },
            {
              "name": "_cdn",
              "value": "cloudflare"
            }
          ],
          "headersSize": 521
        },
        "response": {
          "status": 200,
          "statusText": "",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "date",
              "value": "Tue, 07 Jan 2025 08:17:37 GMT"
            },
            {
              "name": "content-type",
              "value": "text/javascript;charset=UTF-8"
            },
            {
              "name": "content-length",
              "value": "23663"
            },
            {
              "name": "cache-control",
              "value": "public,max-age=0,must-revalidate"
            },
            {
              "name": "expires",
              "value": "Sun, 09 Sep 2001 01:46:40 GMT"
            },
            {
              "name": "etag",
              "value": "\"snM8UYxzKWTX\""
            },
            {
              "name": "x-integrity",
              "value": "\"sha384-jti3NUdKRUUNbwzGNZqv9d4QtHg7TtuUgrsWdXo4Ph5SgHIAmBKk3N+H9JNK0SxB\""
            },
            {
              "name": "last-modified",
              "value": "Mon, 20 Apr 1970 06:43:19 GMT"
            },
            {
              "name": "content-encoding",
              "value": "gzip"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=10368000"
            },
            {
              "name": "x-cache",
              "value": "MISS"
            },
            {
              "name": "cf-cache-status",
              "value": "MISS"
            },
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "vary",
              "value": "Accept-Encoding"
            },
            {
              "name": "server",
              "value": "cloudflare"
            },
            {
              "name": "cf-ray",
              "value": "8fe2832e5df1095d-HKG"
            },
            {
              "name": "X-Firefox-Spdy",
              "value": "h2"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "text/javascript; charset=UTF-8",
            "size": 89751,
            "text": "\nfunction GetElemSNR( $Elem )\n{\n\tvar snr = $Elem.data( 'snr' );\n\tif ( typeof snr != 'undefined' )\n\t{\n\t\treturn snr;\n\t}\n\n\t// look for links with snr parameter\n\tvar links = $Elem.is( 'a' ) ? $Elem : $Elem.find( 'a' );\n\tsnr = null;\n\tfor ( var i = 0; i < links.length; ++i )\n\t{\n\t\tvar link = links[i];\n\t\tvar navinfo = link.href.match( /[\\?&]snr=([a-zA-Z0-9\\-\\_ ]+)/ );\n\t\tif ( navinfo )\n\t\t{\n\t\t\tsnr = navinfo[1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t$Elem.data( 'snr', snr );\n\treturn snr;\n}\n\n// given an array of impressions as strings, this will handle joining them all together into a singular string, but enforcing that it doesn't\n// go above the cookie size limit which can otherwise cause users to become stuck since the page requests will start failing\nfunction JoinImpressionsUpToLimit( rgImpressions )\n{\n\t//cookies generally can go up to 4k bytes, but we can have problems when we start getting that close, so cut it off earlier\n\tvar nRemainingLen = 3200;\n\tvar result = '';\n\tfor ( var i = 0; i < rgImpressions.length; i++ )\n\t{\n\t\tvar impression = String( rgImpressions[ i ] );\n\t\tvar nImpressionLen = encodeURIComponent( impression + '|' ).length;\n\n\t\t//did we run out of room in our list?\n\t\tif ( nRemainingLen < nImpressionLen )\n\t\t\tbreak;\n\n\t\t//add the separator if not the first entry\n\t\tif ( result !== '' )\n\t\t\tresult += '|';\n\n\t\t//add our impression and remove that space from what is available\n\t\tresult += impression;\n\t\tnRemainingLen -= nImpressionLen;\n\t}\n\n\treturn result;\n}\n\nGDynamicStore = {\n\n\tm_bLoadComplete: false,\n\ts_rgWishlist: {},\n\ts_rgOwnedPackages: {},\n\ts_rgOwnedApps: {},\n\ts_rgMasterSubApps: {},\n\ts_rgAutoGrantApps: {},\n\ts_rgPackagesInCart: {},\n\ts_rgAppsInCart: {},\n\ts_rgRecommendedTags: [],\n\n\ts_rgIgnoredApps: {},\n\ts_rgIgnoredPackages: {},\n\n\ts_rgCurators: {},\n\ts_rgCurations: {},\n\ts_rgCreatorsFollowed: {},\n\ts_rgCreatorsIgnored: {},\n\n\ts_preferences: {},\n\ts_rgExcludedTags: {},\n\ts_rgExcludedDescIDs: {},\n\n\ts_rgPersonalizedBundleData: {},\n\n\ts_rgfnOnReadyCallbacks: [],\n\n\ts_rgDisplayedApps: [],\n\ts_rgDisplayedBundles: [],\n\ts_rgDisplayedPackages: [],\n\n\ts_bUserOnMacOS: false,\n\ts_bUserOnLinux: false,\n\ts_bUserOnWindows: false,\n\n\ts_rgRecommendedApps: [],\n\n\n\ts_ImpressionTracker: false,\n\ts_bAllowAppImpressions: false,\n\n\tInit: function( accountid, bForceRefresh, strOS, preferences, strCC, optsIn )\n\t{\n\t\tvar opts = $J.extend( { bNoDefaultDescriptors: false }, optsIn || {} );\n\t\tvar rgDesiredOSTypes = strOS ? strOS.split(',') : 'any';\n\n\t\tfor( var i=0; i < rgDesiredOSTypes.length; i++ )\n\t\t{\n\t\t\tswitch( rgDesiredOSTypes[i] )\n\t\t\t{\n\t\t\t\tcase 'mac': GDynamicStore.s_bUserOnMacOS = true; break;\n\t\t\t\tcase 'linux': GDynamicStore.s_bUserOnLinux = true; break;\n\t\t\t\tdefault:\n\t\t\t\tcase 'win': GDynamicStore.s_bUserOnWindows = true; break;\n\t\t\t}\n\t\t}\n\n\t\tGDynamicStore.s_preferences = preferences || {};\n\n\t\tvar fnRunOnLoadCallbacks = function() {\n\t\t\tGDynamicStore.m_bLoadComplete = true;\n\t\t\tGDynamicStore.InitAppearHandler();\n\n\t\t\tfor ( var i = 0; i < GDynamicStore.s_rgfnOnReadyCallbacks.length; i++ )\n\t\t\t{\n\t\t\t\ttry {\n\t\t\t\t\tGDynamicStore.s_rgfnOnReadyCallbacks[i]();\n\t\t\t\t}\n\t\t\t\tcatch ( e )\n\t\t\t\t{\n\t\t\t\t\tconsole.error( e );\n\t\t\t\t}\n\t\t\t}\n\t\t\tGDynamicStore.s_rgfnOnReadyCallbacks = null;\n\n\t\t\tGDynamicStore.DecorateDynamicItems();\n\t\t\tGDynamicStore.PopulateRecommendedTagList();\n\t\t};\n\n\t\ttry {\n\t\t\tthis.RemoveSNRFromURL();\n\t\t\tthis.RemoveUTMFromURL();\n\t\t} catch ( e )\n\t\t{\n\t\t}\n\n\t\t// Create a new monitor to track impressions\n\t\tthis.s_ImpressionTracker = new CAppearMonitor(\n\t\t\tfunction( elElement ){\n\n\t\t\t\tvar fnTrack = function( el )\n\t\t\t\t{\n\n\t\t\t\t\tvar $Elem = $J(el);\n\n\t\t\t\t\tif ( $Elem.data( 'trackedForImpressions' ) )\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t$Elem.data( 'trackedForImpressions', true );\n\n\t\t\t\t\t// must have appids\n\t\t\t\t\tvar strAppIDs = $Elem.data('dsAppid');\n\t\t\t\t\tif ( !strAppIDs || strAppIDs.length == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar snr = GetElemSNR( $Elem );\n\t\t\t\t\tif ( !snr )\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tGDynamicStore.AddImpressionFromDynamicItem( $Elem );\n\t\t\t\t};\n\n\t\t\t\tfnTrack( elElement );\n\n\t\t\t\t// Also track sub-elements, which may exist inside our container. This is useful for nested clusters etc.\n\t\t\t\t$J(elElement).find(\"*[data-ds-appid]\").each(function(i, j){\n\t\t\t\t\tfnTrack(j);\n\n\t\t\t\t});\n\n\n\t\t\t}\n\t\t);\n\n\t\tif ( accountid )\n\t\t{\n\t\t\tif ( bForceRefresh )\n\t\t\t\tGDynamicStore.InvalidateCache();\n\n\t\t\tvar url = 'https://store.steampowered.com/dynamicstore/userdata/?id=' + accountid + '&cc=' + strCC;\n\n\t\t\tvar unUserdataVersion = WebStorage.GetLocal( 'unUserdataVersion' );\n\t\t\tif ( unUserdataVersion )\n\t\t\t\turl += '&v=' + parseInt( unUserdataVersion );\n\n\t\t\t$J.get( url ).done( function( data ) {\n\t\t\t\tvar fnEnsureObject = function ( rgMaybeArray ) {\n\t\t\t\t\treturn ( !rgMaybeArray || ( typeof rgMaybeArray.length != 'undefined' && rgMaybeArray.length == 0 ) ) ? {} : rgMaybeArray;\n\t\t\t\t};\n\t\t\t\tvar fnConvertToMap = function ( rgData ) {\n\t\t\t\t\tvar out = {};\n\t\t\t\t\tif ( rgData && rgData.length )\n\t\t\t\t\t{\n\t\t\t\t\t\tfor ( var i = 0; i < rgData.length; i++ )\n\t\t\t\t\t\t\tout[ rgData[i] ] = true;\n\t\t\t\t\t}\n\t\t\t\t\treturn out;\n\t\t\t\t};\n\t\t\t\tGDynamicStore.s_rgWishlist = fnConvertToMap( data.rgWishlist );\n\t\t\t\tGDynamicStore.s_rgOwnedPackages = fnConvertToMap( data.rgOwnedPackages );\n\t\t\t\tGDynamicStore.s_rgOwnedApps = fnConvertToMap( data.rgOwnedApps );\n\t\t\t\tGDynamicStore.s_rgMasterSubApps = fnConvertToMap( data.rgMasterSubApps );\n\t\t\t\tGDynamicStore.s_rgAutoGrantApps = fnConvertToMap( data.rgAutoGrantApps );\n\t\t\t\tGDynamicStore.s_rgPackagesInCart = fnConvertToMap( data.rgPackagesInCart );\n\t\t\t\tGDynamicStore.s_rgAppsInCart = fnConvertToMap( data.rgAppsInCart );\n\t\t\t\tGDynamicStore.s_rgRecommendedTags = data.rgRecommendedTags || [];\n\t\t\t\tGDynamicStore.s_rgIgnoredApps = data.rgIgnoredApps || {}\n\t\t\t\tGDynamicStore.s_rgIgnoredPackages = data.rgIgnoredPackages || {};\n\t\t\t\tGDynamicStore.s_rgCurators = data.rgCurators || {};\n\t\t\t\tGDynamicStore.s_rgCurations = data.rgCurations || {};\n\t\t\t\tGDynamicStore.s_rgCreatorsFollowed = fnConvertToMap( data.rgCreatorsFollowed );\n\t\t\t\tGDynamicStore.s_rgCreatorsIgnored = fnConvertToMap( data.rgCreatorsIgnored );\n\t\t\t\tGDynamicStore.s_bAllowAppImpressions = data.bAllowAppImpressions || false;\n\n\t\t\t\tif ( data.rgExcludedTags && data.rgExcludedTags.length > 0 )\n\t\t\t\t{\n\t\t\t\t\tfor ( var i = i = 0; i < data.rgExcludedTags.length; ++i )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tag = data.rgExcludedTags[i];\n\t\t\t\t\t\tGDynamicStore.s_rgExcludedTags[tag.tagid] = tag.name;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( data.rgExcludedContentDescriptorIDs && data.rgExcludedContentDescriptorIDs.length > 0 &&\n\t\t\t\t\t\t!V_GetCookie( 'wants_mature_content') )\n\t\t\t\t{\n\t\t\t\t\tfor ( var i = i = 0; i < data.rgExcludedContentDescriptorIDs.length; ++i )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar id = data.rgExcludedContentDescriptorIDs[i];\n\t\t\t\t\t\tGDynamicStore.s_rgExcludedDescIDs[id] = id;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tGDynamicStore.s_nRemainingCartDiscount = data.nRemainingCartDiscount ? data.nRemainingCartDiscount : 0;\n\t\t\t\tGDynamicStore.s_nTotalCartDiscount = data.nTotalCartDiscount ? data.nTotalCartDiscount : 0;\n\t\t\t\tGDynamicStore.s_rgRecommendedApps = data.rgRecommendedApps || [];\n\n\t\t\t\tGDynamicStore.s_nPromotionalDiscount = data.nPromotionalDiscount ? data.nPromotionalDiscount : 0;\n\t\t\t\tGDynamicStore.s_nPromotionalDiscountMinCartAmount = data.nPromotionalDiscountMinCartAmount ? data.nPromotionalDiscountMinCartAmount : 0;\n\t\t\t\tGDynamicStore.s_nPromotionalDiscountAvailableUseCount = data.nPromotionalDiscountAvailableUseCount ? data.nPromotionalDiscountAvailableUseCount : 0;\n\n\t\t\t}).always( function() { $J(fnRunOnLoadCallbacks); } );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ( !opts.bNoDefaultDescriptors )\n\t\t\t\tGDynamicStore.s_rgExcludedDescIDs[3] = 3;\n\n\t\t\tvar url = 'https://store.steampowered.com/dynamicstore/saledata/?cc=' + strCC;\n\n\t\t\t$J.get( url ).done( function( data ) {\n\t\t\t\tGDynamicStore.s_nPromotionalDiscount = data.nPromotionalDiscount ? data.nPromotionalDiscount : 0;\n\t\t\t\tGDynamicStore.s_nPromotionalDiscountMinCartAmount = data.nPromotionalDiscountMinCartAmount ? data.nPromotionalDiscountMinCartAmount : 0;\n\t\t\t\tGDynamicStore.s_nPromotionalDiscountAvailableUseCount = data.nPromotionalDiscountAvailableUseCount ? data.nPromotionalDiscountAvailableUseCount : 0;\n\t\t\t\tGDynamicStore.s_bAllowAppImpressions = data.bAllowAppImpressions || false;\n\n\t\t\t}).always( function() { $J(fnRunOnLoadCallbacks); } );\n\t\t}\n\t},\n\n\tRemoveSNRFromURL: function()\n\t{\n\t\tif ( !window.history || !window.history.replaceState || !window.location.search )\n\t\t\treturn;\n\n\t\tGDynamicStore.RemoveParamFromURL( 'snr' );\n\t\tGDynamicStore.RemoveParamFromURL( 'ser' );\n\t},\n\n\tRemoveParamFromURL: function( strParamName )\n\t{\n\t\t// find snr param\n\t\tvar strParamPrefix = '' + strParamName + '=';\n\t\tvar strSearch = window.location.search;\n\t\tif ( strSearch.indexOf( '?' ) == 0 )\n\t\t\tstrSearch = strSearch.slice( 1 );\n\n\t\tvar rgParams = strSearch.split( '&' );\n\t\tvar iParam = -1;\n\t\tfor ( var i = 0; i < rgParams.length; i++ )\n\t\t{\n\t\t\tvar strParam = rgParams[i];\n\t\t\tif (strParam.indexOf( strParamPrefix ) == 0)\n\t\t\t{\n\t\t\t\tiParam = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( iParam < 0 )\n\t\t\treturn;\n\n\t\tvar strRemove = '';\n\t\tif ( rgParams.length == 1 || (rgParams.length == 2 && rgParams[1].length == 0) )\n\t\t{\n\t\t\t// remove the entire search.. just SNR\n\t\t\tstrRemove = '?' + strSearch;\n\t\t}\n\t\telse if ( iParam == 0 )\n\t\t{\n\t\t\t// first param of multiple. Remove snr and trailing &\n\t\t\tstrRemove = rgParams[iParam] + '&';\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 2nd+ param of multiple. Remove snr and preceeding &\n\t\t\tstrRemove = '&' + rgParams[iParam];\n\t\t}\n\n\t\tif ( strRemove.length > 0 )\n\t\t{\n\t\t\tvar strNewURL = window.location.href.replace( strRemove, '' );\n\t\t\twindow.history.replaceState( history.state, null, strNewURL );\n\t\t}\n\t},\n\n\tRemoveUTMFromURL: function()\n\t{\n\t\tif ( !window.history || !window.history.replaceState || !window.location.search )\n\t\t\treturn;\n\n\t\tvar strSearch = window.location.search;\n\t\tif ( strSearch.indexOf( '?' ) == 0 )\n\t\t\tstrSearch = strSearch.slice( 1 );\n\n\t\tvar rgParams = strSearch.split( '&' );\n\t\tvar rgNewParams = [];\n\n\t\tfor ( var i = 0; i < rgParams.length; ++i )\n\t\t{\n\t\t\tvar strParam = rgParams[i];\n\t\t\tif ( strParam.indexOf( 'utm_') == -1 )\n\t\t\t{\n\t\t\t\trgNewParams.push( strParam );\n\t\t\t}\n\t\t}\n\n\t\tif ( rgParams.length != rgNewParams.length )\n\t\t{\n\t\t\tvar strNewURL = window.location.href.replace( window.location.search, '' );\n\t\t\tfor ( var i = 0; i < rgNewParams.length; ++i )\n\t\t\t{\n\t\t\t\tvar strParam = rgNewParams[i];\n\t\t\t\tstrNewURL += ( i == 0 ? '?' : '&' ) + strParam;\n\t\t\t}\n\t\t\twindow.history.replaceState( history.state, null, strNewURL );\n\t\t}\n\t},\n\n\t// Fixup name portion of URL via history API, if support and if name portion is incorrect\n\tFixupNamePortion: function() {\n\t\tvar rel = $J( \"link[rel='canonical']\" );\n\t\tif ( rel.length && window.history ) {\n\t\t\t// have rel=canonical URL and access to history API.\n\t\t\t// parse out href portion of navigated URL and see if it's OK\n\t\t\tvar detachedAnchor = document.createElement( 'a' );\n\t\t\tdetachedAnchor.href = rel.attr( \"href\" );\n\t\t\tif ( window.location.pathname != detachedAnchor.pathname ) {\n\t\t\t\t// URL portion does not match canonical URL; rewrite it, preserving query params and hash\n\t\t\t\twindow.history.replaceState( null, null, rel[0].href + window.location.search + window.location.hash );\n\t\t\t}\n\t\t}\n\t},\n\n\ts_strAppearSelector: '[data-ds-appid], [data-ds-packageid]',\n\n\tInitAppearHandler: function()\n\t{\n\t\t$J(GDynamicStore.s_strAppearSelector).each(function(i, elTarget ){\n\n\t\t\tvar $Elem = $J(elTarget);\n\t\t\t// these are handled manually, so don't add the impression here\n\t\t\tif ( $Elem.hasClass( 'cluster_capsule' ) || $Elem.hasClass( 'carousel_cap') )\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tGDynamicStore.s_ImpressionTracker.RegisterElement( elTarget )\n\t\t});\n\n\t\t// find our horizontal scrollers and add tracking to them\n\n\t\t$J('.store_horizontal_autoslider' ).each(function(i, elTarget ){\n\t\t\tGDynamicStore.s_ImpressionTracker.RegisterScrollEvent( elTarget );\n\t\t});\n\n\t\tGDynamicStore.s_ImpressionTracker.CheckVisibility();\n\n\t},\n\n\ts_oImpressionsTracked: {},\n\tAddImpressionFromDynamicItem: function( $Elem )\n\t{\n\t\tif ( !GDynamicStore.s_bAllowAppImpressions )\n\t\t{\n\t\t\t\t\t\treturn;\n\t\t}\n\n\t\t\n\t\tif ( $Elem.hasClass( 'app_impression_tracked' ) )\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t$Elem.addClass( 'app_impression_tracked' );\n\n\t\tvar strImpressions = V_GetDecodedCookie( \"app_impressions\" );\n\t\tvar rgImpressions = strImpressions && strImpressions.length != 0 ? strImpressions.split( \"|\" ) : [];\n\n\t\t// commas not allowed in cookie value\n\t\tvar strAppIDs = $Elem.data('dsAppid');\n\t\tif ( !strAppIDs )\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvar rgAppIds;\n\t\tif ( typeof strAppIDs == 'string' && ( strAppIDs.indexOf( ',' ) >= 0 || strAppIDs.indexOf( ':' ) >= 0 ))\n\t\t{\n\t\t\trgAppIds = strAppIDs.split( /[,:]/ );\n\t\t}\n\t\telse\n\t\t{\n\t\t\trgAppIds = [ parseInt( strAppIDs ) ];\n\t\t}\n\n\t\tvar snr = GetElemSNR( $Elem );\n\t\tif ( !snr )\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvar rgAppIDsToReport = [];\n\t\tfor ( var i = 0; i < rgAppIds.length; i++ )\n\t\t{\n\t\t\tvar nAppID = rgAppIds[i];\n\t\t\tvar strImpressionData = nAppID + '@' + snr;\n\n\t\t\tif ( !GDynamicStore.s_oImpressionsTracked[ strImpressionData ] )\n\t\t\t{\n\t\t\t\tGDynamicStore.s_oImpressionsTracked[ strImpressionData ] = true;\n\n\t\t\t\t\n\n\t\t\t\trgAppIDsToReport.push( nAppID );\n\t\t\t}\n\t\t}\n\n\t\tif ( !rgAppIDsToReport.length )\n\t\t\treturn;\n\n\t\trgImpressions.push( rgAppIDsToReport.join( ':' ) + '@' + snr );\n\t\tV_SetCookie( \"app_impressions\", JoinImpressionsUpToLimit( rgImpressions ) );\n\t},\n\n\tAddImpression: function( $Elem, appID, strLink )\n\t{\n\t\tif ( $Elem.hasClass( 'app_impression_tracked' ) )\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t$Elem.addClass( 'app_impression_tracked' );\n\n\t\tvar navinfo = strLink.match( /[\\?&]snr=([^&#]*)(&|$|#)/ );\n\t\tif ( navinfo )\n\t\t{\n\t\t\tvar snr = navinfo[1];\n\n\t\t\tvar strImpressions = V_GetCookie( \"app_impressions\" );\n\t\t\tvar rgImpressions = strImpressions && strImpressions.length != 0 ? strImpressions.split( \"|\" ) : [];\n\t\t\tvar strImpressionData = appID + '@' + snr;\n\t\t\trgImpressions.push( strImpressionData );\n\t\t\tV_SetCookie( \"app_impressions\", JoinImpressionsUpToLimit( rgImpressions ) );\n\t\t}\n\t},\n\n\tMarkAppDisplayed: function( rgDisplayList, cItemsToMark )\n\t{\n\t\t// jquery map takes care of arrays as well as array-ish\n\t\tGDynamicStore.MarkAppIDsAsDisplayed( $J.map( rgDisplayList, function ( item ) { return item.appid; } ), cItemsToMark );\n\t},\n\n\tMarkItemsAsDisplayed: function( rgItems, cItemsToMark )\n\t{\n\t\tfor ( var i = 0; i < rgItems.length; i++ )\n\t\t{\n\t\t\tconst item = rgItems[i];\n\t\t\tif ( item.appid )\n\t\t\t{\n\t\t\t\tGDynamicStore.s_rgDisplayedApps.push( item.appid );\n\n\t\t\t\t// if this appid is a demo, also mark the parent app as displayed\n\t\t\t\tvar rgAppData = GStoreItemData.rgAppData[ item.appid ];\n\t\t\t\tif ( rgAppData && rgAppData.demo_for_app )\n\t\t\t\t\tGDynamicStore.s_rgDisplayedApps.push( rgAppData.demo_for_app );\n\t\t\t}\n\t\t\telse if ( item.bundleid )\n\t\t\t{\n\t\t\t\tGDynamicStore.s_rgDisplayedBundles.push( item.bundleid );\n\t\t\t}\n\t\t\telse if ( item.packageid )\n\t\t\t{\n\t\t\t\tGDynamicStore.s_rgDisplayedPackages.push( item.packageid );\n\t\t\t}\n\n\t\t\tif ( cItemsToMark !== undefined && --cItemsToMark == 0 )\n\t\t\t\tbreak;\n\t\t}\n\t},\n\n\tMarkAppIDsAsDisplayed: function( rgAppIDs, cItemsToMark )\n\t{\n\t\tfor ( var i = 0; i < rgAppIDs.length; i++ )\n\t\t{\n\t\t\tif ( rgAppIDs[i] )\n\t\t\t{\n\t\t\t\tGDynamicStore.s_rgDisplayedApps.push( rgAppIDs[i] );\n\n\t\t\t\t// if this appid is a demo, also mark the parent app as displayed\n\t\t\t\tvar rgAppData = GStoreItemData.rgAppData[ rgAppIDs[i] ];\n\t\t\t\tif ( rgAppData && rgAppData.demo_for_app )\n\t\t\t\t\tGDynamicStore.s_rgDisplayedApps.push( rgAppData.demo_for_app );\n\n\t\t\t\tif ( cItemsToMark !== undefined && --cItemsToMark == 0 )\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t},\n\n\tHandleClusterChange: function( cluster ) {\n\t\tGDynamicStore.s_ImpressionTracker.CheckVisibility();\n\t\tvar $ScrollingContainer = $J( cluster.elScrollArea );\n\t\tvar capsules = $ScrollingContainer.find( '.cluster_capsule' );\n\t\tGDynamicStore.s_ImpressionTracker.TrackAppearanceIfVisible( capsules[cluster.nCurCap] );\n\t},\n\n\tHandleCarouselChange: function( targetid, curPos, pageSize ) {\n\t\tvar $ScrollingContainer = $J( \"#\" + targetid );\n\t\tvar capsules = $ScrollingContainer.find( '.recommendation_carousel_item' );\n\t\tvar idx = (curPos * pageSize);\n\t\tif ( capsules.length != 0 && idx < capsules.length )\n\t\t{\n\t\t\tGDynamicStore.s_ImpressionTracker.TrackAppearanceIfVisible( capsules[idx] );\n\t\t}\n\t},\n\n\tOnReady: function( fnCallback )\n\t{\n\t\tif ( GDynamicStore.m_bLoadComplete )\n\t\t\tfnCallback();\n\t\telse\n\t\t\tGDynamicStore.s_rgfnOnReadyCallbacks.push( fnCallback );\n\t},\n\n\tDecorateDynamicItems: function( $Selector, bForceRecalculate ) {\n\n\t\tif ( !GDynamicStore.m_bLoadComplete )\n\t\t{\n\t\t\tGDynamicStore.OnReady( function() { GDynamicStore.DecorateDynamicItems( $Selector ) } );\n\t\t\treturn;\n\t\t}\n\n\t\t// locate elements with dynamic store data\n\t\tvar strSelector = '[data-ds-appid], [data-ds-packageid], [data-ds-bundleid]';\n\n\t\t// update prices for cart\n\t\tif ( GDynamicStore.s_nRemainingCartDiscount != 'undefined ')\n\t\t{\n\t\t\tUpdatePricesForAdditionalCartDiscount($Selector, GDynamicStore.s_nRemainingCartDiscount);\n\t\t}\n\n\t\tvar bBannerShown = false;\n\t\tif ( GDynamicStore.s_nTotalCartDiscount != 'undefined ')\n\t\t{\n\t\t\tbBannerShown = UpdateStoreBannerForAdditionalCartDiscount( GDynamicStore.s_nTotalCartDiscount );\n\t\t}\n\n\t\tif ( !bBannerShown && GDynamicStore.s_nPromotionalDiscount != 'undefined' )\n\t\t{\n\t\t\tbBannerShown = UpdateStoreBannerForPromotionalDiscount( GDynamicStore.s_nPromotionalDiscount, GDynamicStore.s_nPromotionalDiscountMinCartAmount, GDynamicStore.s_nPromotionalDiscountAvailableUseCount );\n\t\t}\n\n\t\tvar $DynamicElements;\n\t\tif ( $Selector )\n\t\t{\n\t\t\tif ( $Selector.is( strSelector ) )\n\t\t\t{\n\t\t\t\t$DynamicElements = $Selector;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$DynamicElements = $Selector.find( strSelector );\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$DynamicElements = $J(strSelector);\n\t\t}\n\n\t\t$DynamicElements.each( function() {\n\t\t\tvar $El = $J(this);\n\n\t\t\tif ( bForceRecalculate )\n\t\t\t{\n\t\t\t\t$El.removeClass( 'ds_flagged ds_owned ds_wishlist ds_incart' ).children( '.ds_flag' ).remove();\n\t\t\t}\n\t\t\telse if ( $El.data('dsInstrumented') )\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$El.data('dsInstrumented', true);\n\n\t\t\tvar bOwned = false;\n\t\t\tvar bWanted = false;\n\t\t\tvar bInCart = false;\n\t\t\tvar bIgnored = false;\n\n\t\t\tvar unBundleID = $El.data('dsBundleid');\n\t\t\tvar unPackageID = $El.data('dsPackageid');\n\t\t\tvar strAppIDs = $El.data('dsAppid');\n\t\t\tvar eSteamDeckCompatCategory = $El.data('dsSteamDeckCompatCategory');\n\n\t\t\tif ( eSteamDeckCompatCategory !== undefined && !$El.data( 'dsSteamDeckCompatHandled' ) )\n\t\t\t{\n\t\t\t\t$El.data('dsSteamDeckCompatHandled', true);\n\n\t\t\t\tvar strClasses = 'ds_steam_deck_compat ';\n\t\t\t\tswitch( eSteamDeckCompatCategory )\n\t\t\t\t{\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tstrClasses += 'verified';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tstrClasses += 'playable';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tstrClasses += 'unsupported';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstrClasses += 'unknown';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvar elSteamDeckCompatCategory = $J( '<div/>', { class: strClasses } );\n\t\t\t\t$El.append( elSteamDeckCompatCategory );\n\t\t\t}\n\n\t\t\tif ( unBundleID )\n\t\t\t{\n\t\t\t\tvar Bundle = GDynamicStore.GetPersonalizedBundleData( unBundleID, $El.data('dsBundleData') );\n\t\t\t\tif ( !Bundle )\t// no data available\n\t\t\t\t\treturn;\n\n\t\t\t\tif ( Bundle.m_cUserItemsInBundle == 0 )\n\t\t\t\t{\n\t\t\t\t\tbOwned = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// pull out all the appids and let the strAppIDs code below handle it\n\t\t\t\t\tvar rgAllAppIDsInBundle = [];\n\t\t\t\t\tfor( var iBundleItem = 0; iBundleItem < Bundle.m_rgBundleItems.length; iBundleItem++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar BundleItem = Bundle.m_rgBundleItems[iBundleItem];\n\t\t\t\t\t\tfor ( var iApp = 0; iApp < BundleItem.m_rgIncludedAppIDs.length; iApp++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trgAllAppIDsInBundle.push( BundleItem.m_rgIncludedAppIDs[iApp] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstrAppIDs = rgAllAppIDsInBundle.join(',');\n\t\t\t\t}\n\n\t\t\t\tGDynamicStore.UpdateDynamicBundleElements( Bundle, $El );\n\t\t\t}\n\t\t\telse if ( unPackageID )\n\t\t\t{\n\t\t\t\tif ( GDynamicStore.s_rgPackagesInCart[unPackageID] )\n\t\t\t\t\tbInCart = true;\n\t\t\t\telse if ( GDynamicStore.s_rgOwnedPackages[unPackageID] )\n\t\t\t\t\tbOwned = true;\n\t\t\t\telse if ( unPackageID in GDynamicStore.s_rgIgnoredPackages )\n\t\t\t\t\tbIgnored = true;\n\t\t\t}\n\n\t\t\tif ( strAppIDs && typeof strAppIDs == 'string' && strAppIDs.indexOf( ',' ) >= 0 )\n\t\t\t{\n\t\t\t\tvar rgAppIDs = strAppIDs.split( ',' );\n\t\t\t\tvar bValid = false;\n\t\t\t\tvar bAllOwned = true, bAllWanted = true, bAllInCart = true;\n\t\t\t\tfor ( var i = 0; i < rgAppIDs.length; i++ )\n\t\t\t\t{\n\t\t\t\t\tvar unAppID = parseInt( rgAppIDs[i] );\n\t\t\t\t\tif ( !unAppID )\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tbValid = true;\n\t\t\t\t\tif ( !GDynamicStore.s_rgOwnedApps[unAppID] )\n\t\t\t\t\t\tbAllOwned = false;\n\t\t\t\t\tif ( !GDynamicStore.s_rgWishlist[unAppID] )\n\t\t\t\t\t\tbAllWanted = false;\n\t\t\t\t\tif ( !GDynamicStore.s_rgAppsInCart[unAppID] )\n\t\t\t\t\t\tbAllInCart = false;\n\t\t\t\t}\n\n\t\t\t\tif ( bValid )\n\t\t\t\t{\n\t\t\t\t\tif ( bAllInCart )\n\t\t\t\t\t\tbInCart = bAllInCart;\n\t\t\t\t\telse if ( bAllOwned )\n\t\t\t\t\t\tbOwned = bAllOwned;\n\t\t\t\t\telse if ( bAllWanted )\n\t\t\t\t\t\tbWanted = bAllWanted;\n\n\t\t\t\t\tGDynamicStore.s_ImpressionTracker.RegisterElement( this );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( parseInt( strAppIDs ) )\n\t\t\t{\n\t\t\t\t// simple case of single appid\n\t\t\t\tvar unAppID = parseInt( strAppIDs );\n\t\t\t\tif ( GDynamicStore.s_rgAppsInCart[unAppID] )\n\t\t\t\t\tbInCart = true;\n\t\t\t\telse if ( GDynamicStore.s_rgOwnedApps[unAppID] )\n\t\t\t\t\tbOwned = true;\n\t\t\t\telse if ( GDynamicStore.s_rgWishlist[unAppID] )\n\t\t\t\t\tbWanted = true;\n\t\t\t\telse if ( unAppID in GDynamicStore.s_rgIgnoredApps )\n\t\t\t\t\tbIgnored = true;\n\n\t\t\t\tGDynamicStore.s_ImpressionTracker.RegisterElement( this );\n\t\t\t}\n\n\t\t\tvar rgExcludedTagNames = GDynamicStore.GetExcludedTagsOverlap( $El );\n\t\t\tvar rgExcludedContentDescriptorIDs = GDynamicStore.GetExcludedContentDescriptorOverlap( $El );\n\t\t\tvar rgExcludedCreatorIDs = GDynamicStore.GetExcludedCreatorOverlap( $El );\n\n\t\t\tif ( !$El.hasClass('ds_no_flags') )\n\t\t\t{\n\t\t\t\t// owned and wishlist are mutually exclusive\n\t\t\t\tif ( bOwned )\n\t\t\t\t{\n\t\t\t\t\t$El.addClass( 'ds_flagged ds_owned' );\n\t\t\t\t\t$El.append( '<div class=\"ds_flag ds_owned_flag\">В БИБЛИОТЕКЕ&nbsp;&nbsp;</div>');\n\t\t\t\t}\n\t\t\t\telse if ( bWanted )\n\t\t\t\t{\n\t\t\t\t\t$El.addClass( 'ds_flagged ds_wishlist' );\n\t\t\t\t\t$El.append( '<div class=\"ds_flag ds_wishlist_flag\">В ЖЕЛАЕМОМ&nbsp;&nbsp;</div>');\n\t\t\t\t}\n\t\t\t\telse if ( bIgnored )\n\t\t\t\t{\n\t\t\t\t\t$El.addClass( 'ds_flagged ds_ignored' );\n\t\t\t\t\t$El.append( '<div class=\"ds_flag ds_ignored_flag\">СКРЫТО&nbsp;&nbsp;</div>');\n\t\t\t\t}\n\n\t\t\t\tif ( bInCart )\n\t\t\t\t{\n\t\t\t\t\t$El.addClass( 'ds_flagged ds_incart' );\n\t\t\t\t\t$El.append( '<div class=\"ds_flag ds_incart_flag\">В КОРЗИНЕ&nbsp;&nbsp;</div>');\n\t\t\t\t}\n\n\t\t\t\tif ( $El.hasClass( 'ds_excluded_blur' ) )\n\t\t\t\t{\n\t\t\t\t\t$El.addClass( 'ds_flagged' );\n                \t$El.append( '<div class=\"ds_flag ds_excluded_by_preferences_flag\">ИСКЛЮЧЕНО ИСХОДЯ ИЗ НАСТРОЕК&nbsp;&nbsp;</div>' );\n\t\t\t\t}\n\t\t\t\telse if ( rgExcludedContentDescriptorIDs.length != 0 )\n\t\t\t\t{\n\t\t\t\t\t$El.addClass( 'ds_flagged ds_excluded_by_preferences' );\n\t\t\t\t\t$El.append( '<div class=\"ds_flag ds_excluded_by_preferences_flag\">ИСКЛЮЧЕНО ИСХОДЯ ИЗ НАСТРОЕК&nbsp;&nbsp;</div>' );\n\t\t\t\t}\n\t\t\t\telse if ( rgExcludedTagNames.length != 0 )\n\t\t\t\t{\n\t\t\t\t\t$El.addClass( 'ds_flagged ds_excluded_by_preferences' );\n\t\t\t\t\t$El.append( '<div class=\"ds_flag ds_excluded_by_preferences_flag\">ИСКЛЮЧЁННЫЕ МЕТКИ:&nbsp;' + rgExcludedTagNames.join(\", \" ) + '</div>' );\n\t\t\t\t}\n\t\t\t\telse if ( rgExcludedCreatorIDs.length != 0 )\n\t\t\t\t{\n\t\t\t\t\t$El.addClass( 'ds_flagged ds_excluded_by_preferences' );\n\t\t\t\t\t$El.append( '<div class=\"ds_flag ds_excluded_by_preferences_flag\">ИСКЛЮЧЕНО, ПОСКОЛЬКУ ЭТО ИГНОРИРУЕМЫЙ РАЗРАБОТЧИК, ИЗДАТЕЛЬ ИЛИ СЕРИЯ ИГР&nbsp;&nbsp;</div>' );\n\t\t\t\t}\n\n\t\t\t\tif( g_AccountID && unAppID && $El.data('ds-options') !== 0 ) // Only add if we have an appid\n\t\t\t\t{\n\t\t\t\t\tvar $elMenu = $J ( '<div></div>', { 'class': 'ds_options' } ).append($J('<div>'));\n\t\t\t\t\t$El.append ( $elMenu );\n\n\t\t\t\t\t$El.one( 'mouseenter', function() {\n\t\t\t\t\t\t$elMenu.v_tooltip ( {\n\t\t\t\t\t\t\t'tooltipClass': 'ds_options_tooltip',\n\t\t\t\t\t\t\t'location': 'bottom left',\n\t\t\t\t\t\t\t'offsetY': -20,\n\t\t\t\t\t\t\t'useClickEvent': true,\n\t\t\t\t\t\t\t'useMouseEnterEvent': false,\n\t\t\t\t\t\t\tfunc: GDynamicStore.CapsuleSettingsMenu\n\t\t\t\t\t\t} );\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t}\n\t\t});\n\n\n\t\t// make sure that the elements are registered as \"appearing\" if necessary\n\t\tGDynamicStore.s_ImpressionTracker.CheckVisibility();\n\t},\n\n\tCapsuleSettingsMenu: function( elSource )\n\t{\n\t\tvar $El = $J(this);\n\t\tvar $elSource = $J(elSource.parentNode);\n\t\t$El.empty();\n\n\t\tvar strAppIDs = $elSource.data('dsAppid');\n\n\t\t// AppID specific controls\n\t\tif( strAppIDs )\n\t\t{\n\n\t\t\tvar rgAppIds = [];\n\n\t\t\tif (strAppIDs && typeof strAppIDs == 'string' && strAppIDs.indexOf(',') >= 0) {\n\t\t\t\trgAppIds = strAppIDs.split(',');\n\t\t\t}\n\t\t\telse if (parseInt(strAppIDs)) {\n\t\t\t\trgAppIds = [parseInt(strAppIDs)];\n\t\t\t}\n\n\t\t\tvar bIgnored = false;\n\t\t\tvar bOnWishlist = false;\n\t\t\tvar bFilteredByContentPreferences = false;\n\n\t\t\tfor( var i = 0; i < rgAppIds.length; i++ )\n\t\t\t{\n\t\t\t\tbIgnored |= GDynamicStore.BIsAppIgnored( rgAppIds[i] );\n\t\t\t\tbOnWishlist |= GDynamicStore.BIsAppOnWishlist( rgAppIds[i] );\n\t\t\t}\n\n\n\t\t\tif (!bOnWishlist)\n\t\t\t{\n\t\t\t\tvar fnClick = function ( event )\n\t\t\t\t{\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\t$elSource.addClass( 'ds_flagged ds_wishlist' );\n\t\t\t\t\t$elSource.append( '<div class=\"ds_flag ds_wishlist_flag\">В ЖЕЛАЕМОМ&nbsp;&nbsp;</div>');\n\n\t\t\t\t\tfor( var i=0; i<rgAppIds.length; i++ )\n\t\t\t\t\t\tGDynamicStore.ModifyWishlist ( $elSource, rgAppIds[ i ], false, false, function(){\n\t\t\t\t\t\t\t// Remove the flag if we failed.\n\t\t\t\t\t\t\t$elSource.removeClass( 'ds_wishlist ds_flagged' );\n\t\t\t\t\t\t\t$J('.ds_flag.ds_wishlist_flag', $elSource).remove();\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t$El.trigger('mouseleave');\n\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t\tvar strText = \"\\u0412 \\u0436\\u0435\\u043b\\u0430\\u0435\\u043c\\u043e\\u0435\";\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar fnClick = function ( event )\n\t\t\t\t{\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\t$elSource.removeClass( 'ds_wishlist ds_flagged' );\n\t\t\t\t\t$J('.ds_flag.ds_wishlist_flag', $elSource).remove();\n\n\t\t\t\t\tfor( var i=0; i<rgAppIds.length; i++ )\n\t\t\t\t\t\tGDynamicStore.ModifyWishlist ( $elSource, rgAppIds[ i ], true, false, function(){\n\t\t\t\t\t\t\t// Add the flag back if we failed for some reason\n\t\t\t\t\t\t\t$elSource.addClass( 'ds_flagged ds_wishlist' );\n\t\t\t\t\t\t\t$elSource.append( '<div class=\"ds_flag ds_wishlist_flag\">В ЖЕЛАЕМОМ&nbsp;&nbsp;</div>');\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t$El.trigger('mouseleave');\n\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t\tvar strText = \"\\u0412 \\u0441\\u043f\\u0438\\u0441\\u043a\\u0435 \\u0436\\u0435\\u043b\\u0430\\u0435\\u043c\\u043e\\u0433\\u043e\";\n\n\n\t\t\t}\n\n\t\t\tvar $elAddToWishlist = $J ( '<div/>' ).click ( fnClick ).text ( strText ).addClass( 'option' );\n\t\t\t$El.append($elAddToWishlist);\n\n\t\t\tif (!bIgnored)\n\t\t\t{\n\t\t\t\tvar fnClick = function ()\n\t\t\t\t{\n\t\t\t\t\t$elSource.addClass('ds_ignored ds_flagged');\n\t\t\t\t\t$elSource.append( '<div class=\"ds_flag ds_ignored_flag\">СКРЫТО&nbsp;&nbsp;</div>');\n\t\t\t\t\tfor( var i=0; i<rgAppIds.length; i++ )\n\t\t\t\t\t\tGDynamicStore.ModifyIgnoredApp ( $elSource, rgAppIds[ i ], false );\n\n\t\t\t\t\t$El.trigger('mouseleave');\n\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t\tvar strText = \"\\u0421\\u043a\\u0440\\u044b\\u0442\\u044c\";\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\n\t\t\t\tvar fnClick = function ()\n\t\t\t\t{\n\t\t\t\t\t$elSource.removeClass('ds_flagged ds_ignored');\n\t\t\t\t\t$J('.ds_flag.ds_ignored_flag', $elSource).remove();\n\t\t\t\t\tfor( var i=0; i<rgAppIds.length; i++ )\n\t\t\t\t\t\tGDynamicStore.ModifyIgnoredApp ( $elSource, rgAppIds[ i ], true );\n\n\t\t\t\t\t$El.trigger('mouseleave');\n\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t\tvar strText = \"\\u0421\\u043a\\u0440\\u044b\\u0442\\u043e\";\n\t\t\t}\n\n\n\t\t\tvar $elNotInterested = $J ( '<div/>' ).click ( fnClick ).text ( strText ).addClass( 'option' );\n\t\t\t$El.append($elNotInterested);\n\n\n\t\t\tvar $elPreferences = $J ( '<a/>' ).attr('href', 'https://store.steampowered.com/account/preferences' ).text ( \"\\u041d\\u0430\\u0441\\u0442\\u0440\\u043e\\u0439\\u043a\\u0438 \\u043c\\u0430\\u0433\\u0430\\u0437\\u0438\\u043d\\u0430\" ).addClass( 'option' );\n\t\t\t$El.append($elPreferences);\n\n\n\t\t}\n\t},\n\n\tModifyWishlist: function( $elSource, appid, bRemove, fnOnSuccess, fnOnFail )\n\t{\n\t\tvar url = 'https://store.steampowered.com/api/addtowishlist';\n\t\tGDynamicStore.s_rgWishlist[appid] = !bRemove;\n\n\t\tif( bRemove )\n\t\t\turl = 'https://store.steampowered.com/api/removefromwishlist';\n\n\n\t\t$J.post( url, {\n\t\t\tsessionid: g_sessionID,\n\t\t\tappid: appid,\n\t\t\tsnr: $elSource.data( 'snr' )\n\t\t}).done( function( data ) {\n\t\t\tif( fnOnSuccess )\n\t\t\t\tfnOnSuccess( appid );\n\t\t\tGDynamicStore.InvalidateCache();\n\t\t}).fail( function() {\n\t\t\tif( fnOnFail )\n\t\t\t\tfnOnFail( appid );\n\t\t\tGDynamicStore.s_rgWishlist[appid] = false;\n\t\t});\n\t},\n\n\n\tToggleClientsideFilter: function( elControl, strToggleClass, elResults, strFilterClass )\n\t{\n\t\t$Control = $J(elControl);\n\t\t$Results = $J(elResults);\n\n\t\t$Control.toggleClass( strToggleClass );\n\n\t\tif ( $Control.hasClass( strToggleClass ) )\n\t\t{\n\t\t\t$Results.addClass( strFilterClass );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$Results.removeClass( strFilterClass );\n\t\t}\n\t},\n\n\tModifyIgnoredApp: function( $elSource, appid, bRemove, fnOnSuccess, fnOnFail )\n\t{\n\t\tif ( bRemove )\n\t\t{\n\t\t\tdelete GDynamicStore.s_rgIgnoredApps[appid];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tGDynamicStore.s_rgIgnoredApps[appid] = 0;\n\t\t}\n\n\n\t\t$J.post( 'https://store.steampowered.com/recommended/ignorerecommendation/', {\n\t\t\tsessionid: g_sessionID,\n\t\t\tappid: appid,\n\t\t\tremove: bRemove ? 1 : 0,\n\t\t\tsnr: $elSource.data( 'snr' )\n\t\t}).done( function() {\n\t\t\tif( fnOnSuccess )\n\t\t\t\tfnOnSuccess( appid );\n\t\t\tGDynamicStore.InvalidateCache();\n\t\t}).fail( function( jqXHR ) {\n\t\t\tif( fnOnFail )\n\t\t\t\tfnOnFail( appid );\n\t\t\tdelete GDynamicStore.s_rgIgnoredApps[appid];\n\t\t});\n\t},\n\n\tModifyIgnoredPackage: function( packageid, bRemove, fnOnSuccess, fnOnFail )\n\t{\n\t\t\t\tif ( bRemove )\n\t\t{\n\t\t\tdelete GDynamicStore.s_rgIgnoredPackages[packageid];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tGDynamicStore.s_rgIgnoredPackages[packageid] = 0;\n\t\t}\n\n\t\t$J.post( 'https://store.steampowered.com/recommended/ignorerecommendation/', {\n\t\t\tsessionid: g_sessionID,\n\t\t\tsubid: packageid,\n\t\t\tremove: bRemove\n\t\t}).done( function() {\n\t\t\tif( fnOnSuccess )\n\t\t\t\tfnOnSuccess( packageid );\n\t\t\tGDynamicStore.InvalidateCache();\n\t\t}).fail( function() {\n\t\t\tif( fnOnFail )\n\t\t\t\tfnOnFail( packageid );\n\t\t\tdelete GDynamicStore.s_rgIgnoredPackages[packageid];\n\t\t});\n\t},\n\n\tGetPersonalizedBundleData: function( unBundleID, rgPageBundleData )\n\t{\n\t\tif ( !GDynamicStore.s_rgPersonalizedBundleData[unBundleID] )\n\t\t{\n\t\t\tif ( !GStoreItemData.rgPersonalizedBundleData[ unBundleID ] && rgPageBundleData && rgPageBundleData.m_rgItems )\n\t\t\t{\n\t\t\t\tGStoreItemData.rgPersonalizedBundleData[ unBundleID ] = rgPageBundleData;\n\t\t\t}\n\n\t\t\tvar Bundle = GStoreItemData.rgPersonalizedBundleData[ unBundleID ];\n\t\t\tif ( !Bundle )\n\t\t\t\treturn null;\n\n\t\t\tvar BundleForUser = {\n\t\t\t\tm_nDiscountPct: Bundle.m_nDiscountPct,\n\t\t\t\tm_bMustPurchaseAsSet: Bundle.m_bMustPurchaseAsSet,\n\t\t\t\tm_cTotalItemsInBundle: Bundle.m_rgItems.length,\n\t\t\t\tm_bContainsDiscountedPackage: false,\n\t\t\t\tm_cUserItemsInBundle: 0,\n\t\t\t\tm_nPackageBasePriceInCents: 0,\n\t\t\t\tm_nFinalPriceInCents: 0,\n\t\t\t\tm_nFinalPriceInCentsWithBundleDiscount: 0,\n\t\t\t\tm_rgBundleItems: [],\n\t\t\t\tm_bIsCommercial: Bundle.m_bIsCommercial,\n\t\t\t\tm_bRestrictGifting: Bundle.m_bRestrictGifting\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < Bundle.m_rgItems.length; i++ )\n\t\t\t{\n\t\t\t\tvar BundleItem = Bundle.m_rgItems[i];\n\t\t\t\tif ( !BundleItem.m_nPackageID || GDynamicStore.s_rgOwnedPackages[ BundleItem.m_nPackageID ] )\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ( BundleItem.m_rgIncludedAppIDs.length )\n\t\t\t\t{\n\t\t\t\t\tif ( GDynamicStore.BAreAllAppsOwned( BundleItem.m_rgIncludedAppIDs, { bExcludeMasterSub: true } ) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tBundleForUser.m_bContainsDiscountedPackage |= BundleItem.m_bPackageDiscounted;\n\t\t\t\tBundleForUser.m_cUserItemsInBundle++;\n\t\t\t\tBundleForUser.m_nPackageBasePriceInCents += BundleItem.m_nBasePriceInCents;\n\t\t\t\tBundleForUser.m_nFinalPriceInCents += BundleItem.m_nFinalPriceInCents;\n\t\t\t\tBundleForUser.m_nFinalPriceInCentsWithBundleDiscount += BundleItem.m_nFinalPriceWithBundleDiscount;\n\t\t\t\tBundleForUser.m_rgBundleItems.push( BundleItem );\n\t\t\t}\n\n\t\t\t// fix the price\n\t\t\tBundleForUser.m_nFinalPriceInCentsWithBundleDiscount = GStoreItemData.CalculateCurrencyAppropriatePrice( BundleForUser.m_nFinalPriceInCentsWithBundleDiscount );\n\n\t\t\tGDynamicStore.s_rgPersonalizedBundleData[ unBundleID ] = BundleForUser;\n\t\t}\n\n\t\treturn GDynamicStore.s_rgPersonalizedBundleData[ unBundleID ];\n\t},\n\n\tUpdateDynamicBundleElements: function( Bundle, $El )\n\t{\n\n\t\tvar $CartBtn = $El.find('.btn_addtocart:not(.btn_packageinfo)' ).children();\n\t\tvar $DiscountBlocks = $El.find('.discount_block');\n\n\t\tif ( !Bundle.m_bIsCommercial && ( !Bundle.m_rgBundleItems.length || ( Bundle.m_bMustPurchaseAsSet && Bundle.m_cUserItemsInBundle < Bundle.m_cTotalItemsInBundle ) ) )\n\t\t{\n\t\t\tvar strTooltip = 'Этот набор невозможно купить: у вас уже имеются все товары из него.';\n\n\t\t\tif ( Bundle.m_bMustPurchaseAsSet && !Bundle.m_bRestrictGifting )\n\t\t\t{\n\t\t\t\tstrTooltip = 'Данное предложение действительно при единовременной покупке всех %s товаров. Вы можете приобрести этот набор в подарок своему другу.'.replace(/%s/, Bundle.m_cTotalItemsInBundle);\n\t\t\t\t$CartBtn.find('span').text( 'Купить в подарок' );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// completely owned \"complete the set\" bundle\n\t\t\t\t$DiscountBlocks.hide();\n\t\t\t\t$CartBtn.addClass('btn_disabled' ).attr( 'href', 'javascript:void(0)' );\n\t\t\t\t$CartBtn.parent().css( 'background', '#000000' );\n\t\t\t}\n\n\t\t\t$CartBtn.data('tooltip-text', strTooltip );\n\n\t\t}\n\t\telse if ( !Bundle.m_bMustPurchaseAsSet )\n\t\t{\n\t\t\tvar strFormattedFinalPrice = GStoreItemData.fnFormatCurrency( Bundle.m_nFinalPriceInCentsWithBundleDiscount );\n\t\t\t$DiscountBlocks.show();\n\n\t\t\t$DiscountBlocks.find('.discount_original_price' ).text( GStoreItemData.fnFormatCurrency( Bundle.m_nPackageBasePriceInCents ) );\n\t\t\tif ( !Bundle.m_bContainsDiscountedPackage )\n\t\t\t{\n\t\t\t\t$DiscountBlocks.addClass('no_discount');\n\t\t\t\t$DiscountBlocks.find('.discount_final_price' ).addClass('your_price' ).empty().append($J('<div/>', {'class': 'your_price_label'} ).text('Цена для вас:'), $J('<div/>' ).text( strFormattedFinalPrice ) );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$DiscountBlocks.removeClass('no_discount');\n\t\t\t\tvar nDiscountPct = Math.round( ( Bundle.m_nPackageBasePriceInCents - Bundle.m_nFinalPriceInCentsWithBundleDiscount ) / Bundle.m_nPackageBasePriceInCents * 100 );\n\t\t\t\tnDiscountPct = Math.min( nDiscountPct, 99 );\n\t\t\t\t$DiscountBlocks.find('.discount_pct' ).text( '-' + nDiscountPct + '%' );\n\t\t\t\t$DiscountBlocks.find('.discount_final_price' ).removeClass('your_price').text( strFormattedFinalPrice );\n\t\t\t}\n\n\t\t\tif ( Bundle.m_nFinalPriceInCentsWithBundleDiscount == 0 && Bundle.m_cUserItemsInBundle )\n\t\t\t{\n\t\t\t\t// Complete the set bundle with only free items remaining\n\t\t\t\tvar $AddToAcctBtn = $El.find('.btn_addtoaccount' );\n\t\t\t\tif ( $AddToAcctBtn.length )\n\t\t\t\t{\n\t\t\t\t\t$CartBtn.hide();\n\t\t\t\t\t$AddToAcctBtn.show();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar $Description = $El.find('.package_contents');\n\t\tif ( $Description.length && $El.hasClass('dynamic_bundle_description') && !Bundle.m_bMustPurchaseAsSet )\n\t\t\tGDynamicStore.BuildBundleDescription( Bundle, $Description );\n\n\t\tif ( $El.is( '.package_totals_area' ) && !Bundle.m_bMustPurchaseAsSet )\n\t\t{\n\t\t\tif ( !Bundle.m_rgBundleItems.length )\n\t\t\t{\n\t\t\t\t$El.hide();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$El.show();\n\t\t\t\tif ( Bundle.m_cUserItemsInBundle < Bundle.m_cTotalItemsInBundle )\n\t\t\t\t{\n\t\t\t\t\t$El.find('.bundle_final_package_price_desc' ).text( 'Отдельная цена товаров, которых у вас нет (%s):'.replace( '%s', Bundle.m_cUserItemsInBundle ) );\n\t\t\t\t}\n\t\t\t\t$El.find('.bundle_final_package_price' ).text( GStoreItemData.fnFormatCurrency( Bundle.m_nFinalPriceInCents ) );\n\t\t\t\t$El.find('.bundle_final_price_with_discount' ).text( GStoreItemData.fnFormatCurrency( Bundle.m_nFinalPriceInCentsWithBundleDiscount ) );\n\t\t\t\t$El.find('.bundle_savings' ).text( GStoreItemData.fnFormatCurrency( Bundle.m_nFinalPriceInCents - Bundle.m_nFinalPriceInCentsWithBundleDiscount ) );\n\t\t\t}\n\t\t}\n\t},\n\n\tBuildBundleDescription: function( Bundle, $Description )\n\t{\n\t\tif ( Bundle.m_cUserItemsInBundle == 0 )\n\t\t{\n\t\t\t// already own everything\n\t\t\t$Description.html( '<span class=\"collectionComplete\">Вы собрали полную коллекцию!</span> Все перечисленные товары уже в вашей библиотеке.'.replace( '%1$s', Bundle.m_cTotalItemsInBundle ).replace( '%2$s', Bundle.m_cTotalItemsInBundle ) );\n\t\t}\n\t\telse if ( Bundle.m_cUserItemsInBundle < Bundle.m_cTotalItemsInBundle )\n\t\t{\n\t\t\t// own some but not all.\n\t\t\t$Description.html( '<div>Часть товаров (%1$s из %2$s) из этого набора уже есть в вашей библиотеке.</div>'.replace( '%1$s', Bundle.m_cTotalItemsInBundle - Bundle.m_cUserItemsInBundle ).replace( '%2$s', Bundle.m_cTotalItemsInBundle ) );\n\t\t\t$Description.append( '<div>Купите этот набор, чтобы сэкономить %1$s%% на покупке товаров (%2$s), которых у вас пока нет!</div>'.replace( '%1$s', Bundle.m_nDiscountPct ).replace( '%2$s', Bundle.m_cUserItemsInBundle ).replace( '%%', '%' ) );\n\n\t\t\t// add \"complete the set\" flag\n\t\t\t$Description.parents('.dynamic_bundle_description' ).append( $J('<div/>', {'class': 'ds_flag ds_completetheset'} ).text('СОБЕРИТЕ ПОЛНУЮ КОЛЛЕКЦИЮ!') );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$Description.html( '<div>Купите этот набор, чтобы сэкономить %1$s%% на покупке %2$s товаров!</div>'.replace( '%1$s', Bundle.m_nDiscountPct ).replace( '%2$s', Bundle.m_cTotalItemsInBundle ).replace( '%%', '%' ) );\n\t\t}\n\n\t\tvar rgItemsWithCaps = [];\n\t\tfor ( var iBundleItem = 0; iBundleItem < Bundle.m_rgBundleItems.length; iBundleItem++ )\n\t\t{\n\t\t\tvar unPackageID = Bundle.m_rgBundleItems[iBundleItem].m_nPackageID;\n\t\t\tvar PackageData = GStoreItemData.rgPackageData[ unPackageID];\n\t\t\tif ( PackageData && PackageData.tiny_capsule )\n\t\t\t{\n\t\t\t\trgItemsWithCaps.push( unPackageID );\n\t\t\t}\n\t\t}\n\n\t\tif ( rgItemsWithCaps.length )\n\t\t{\n\t\t\t// show no more than 9 items\n\t\t\trgItemsWithCaps = rgItemsWithCaps.slice( 0, 9 );\n\n\t\t\t// if there's more than 5 items, we overlap them a little bit on the display\n\t\t\tvar bNeedToCollapse = rgItemsWithCaps.length > 5;\n\t\t\tvar $BundleContentsCtn = $J('<div/>', {'class': 'bundle_contents_preview'} );\n\t\t\tif ( bNeedToCollapse )\n\t\t\t\t$BundleContentsCtn.addClass( 'collapsed' );\n\n\t\t\tvar $BundleContentsPosition = $J('<div/>', {'class': 'bundle_contents_preview_position'} );\n\t\t\tfor ( var i = 0; i < rgItemsWithCaps.length; i++ )\n\t\t\t{\n\t\t\t\tvar rgLinkParams = { 'class': 'bundle_contents_preview_item ds_collapse_flag', 'data-panel': '{\"focusable\":false}' }\n\t\t\t\tvar Item = GStoreItemData.GetCapParams( 'bundle_component_preview', null, rgItemsWithCaps[i], null, rgLinkParams );\n\t\t\t\tvar $Link = $J('<a/>', rgLinkParams );\n\n\t\t\t\tvar $Img = $J('<img/>', {'src': Item.tiny_capsule, 'class': 'bundle_contents_preview_img' } );\n\t\t\t\tif ( i > 0 && bNeedToCollapse )\n\t\t\t\t{\n\t\t\t\t\tvar flPositionRight = 100 * i / rgItemsWithCaps.length;\n\t\t\t\t\t$Link.addClass( 'floated' ).css( 'left', flPositionRight + '%' ).css('z-index', (rgItemsWithCaps.length - i));\n\t\t\t\t}\n\t\t\t\t$BundleContentsPosition.append( $Link.append( $Img ) );\n\n\n\t\t\t\tGStoreItemData.BindHoverEvents( $Img.parent(), Item.appids.length == 1 ? Item.appids[0] : null, rgItemsWithCaps[i] );\n\t\t\t}\n\n\t\t\t$Description.append( $BundleContentsCtn.append($BundleContentsPosition) );\n\t\t\tGDynamicStore.DecorateDynamicItems( $BundleContentsCtn );\n\t\t}\n\t},\n\n\tPopulateRecommendedTagList: function()\n\t{\n\t\tvar $Element = $J('#foryou_yourtags');\n\t\tif ( !$Element.length )\n\t\t\treturn;\t// no menu\n\n\t\t$Element.empty();\n\t\t$Element.css( 'min-height', '' );\n\t\tfor( var i = 0; i < GDynamicStore.s_rgRecommendedTags.length && i < 4; i++ )\n\t\t{\n\t\t\tvar tag = GDynamicStore.s_rgRecommendedTags[i];\n\t\t\tvar url = 'https://store.steampowered.com/tags/ru/' + encodeURIComponent( tag.name );\n\t\t\tvar $Link = $J('<a/>', {'class': 'popup_menu_item', 'href': GStoreItemData.AddNavEventParamsToURL( url, 'storemenu_recommendedtags' ) });\n\t\t\t$Link.text( tag.name );\n\t\t\t$Element.append( $Link );\n\t\t}\n\t},\n\n\tInvalidateCache: function()\n\t{\n\t\tWebStorage.SetLocal( 'unUserdataVersion', parseInt( WebStorage.GetLocal( 'unUserdataVersion' ) || 0 ) + 1 );\n\t},\n\n\tBIsAppOwned: function( appid, optsIn )\n\t{\n\t\tvar opts = { bExcludeIfAutoGrant: true, bExcludeMasterSub: false };\n\n\t\t\t\tif ( optsIn === false )\n\t\t\t$J.extend( opts, { bExcludeIfAutoGrant: false } );\n\t\telse if ( optsIn )\n\t\t\t$J.extend( opts, optsIn );\n\n\t\tif ( GDynamicStore.s_rgOwnedApps[appid] )\n\t\t{\n\t\t\tif ( opts.bExcludeIfAutoGrant && this.BIsAutoGrantedApp( appid ) )\n\t\t\t\treturn false;\n\n\t\t\tif ( opts.bExcludeMasterSub && this.BIsMasterSubApp( appid ) )\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tBIsAutoGrantedApp: function( appid )\n\t{\n\t\treturn GDynamicStore.s_rgAutoGrantApps[appid] ? true : false;\n\t},\n\n\tBIsMasterSubApp: function( appid )\n\t{\n\t\t// presence in s_rgMasterSubApps indicates the user owns the app via a subscription like EA Play\n\t\t// in some places we allow user to repurchase\n\t\treturn GDynamicStore.s_rgMasterSubApps[appid] ? true : false;\n\t},\n\n\tBIsSalePageAppID: function( appid )\n\t{\n\t\t\t\treturn GStoreItemData.rgAppData[ appid ] && GStoreItemData.rgAppData[ appid ].url;\n\t},\n\n\tBIsPackageOwned: function( packageid )\n\t{\n\t\treturn GDynamicStore.s_rgOwnedPackages[packageid] ? true : false;\n\t},\n\n\tBIsAppIgnored: function( appid )\n\t{\n\t\treturn ( appid in GDynamicStore.s_rgIgnoredApps );\n\t},\n\n\tGetIgnoredAppCount: function( )\n\t{\n\t\treturn Object.keys(GDynamicStore.s_rgIgnoredApps).length;\n\t},\n\n\tGetExcludedTagsOverlap: function( $e )\n\t{\n\t\tvar rgOverlappingTagNames = [];\n\t\tvar rgTagIDs = $e.data( 'dsTagids' );\n\t\tif ( rgTagIDs && rgTagIDs.length > 0 )\n\t\t{\n\t\t\tfor ( var i = 0; i < rgTagIDs.length; ++i )\n\t\t\t{\n\t\t\t\tvar tagid = rgTagIDs[i];\n\t\t\t\tif ( GDynamicStore.s_rgExcludedTags[tagid] )\n\t\t\t\t{\n\t\t\t\t\trgOverlappingTagNames.push( GDynamicStore.s_rgExcludedTags[tagid] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn rgOverlappingTagNames;\n\t},\n\n\tGetExcludedContentDescriptorOverlap: function( $e )\n\t{\n\t\tvar rgOverlappingDescIDs = [];\n\t\tvar rgIDs = $e.data( 'dsDescids' );\n\t\tif ( rgIDs && rgIDs.length > 0 )\n\t\t{\n\t\t\tfor ( var i = 0; i < rgIDs.length; ++i )\n\t\t\t{\n\t\t\t\tvar id = rgIDs[i];\n\t\t\t\tif ( GDynamicStore.s_rgExcludedDescIDs[id] )\n\t\t\t\t{\n\t\t\t\t\trgOverlappingDescIDs.push( id );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn rgOverlappingDescIDs;\n\t},\n\n\tGetExcludedCreatorOverlap: function( $e )\n\t{\n\t\tvar rgOverlappingDescIDs = [];\n\t\tvar rgIDs = $e.data( 'dsCrtrids' );\n\t\tif ( rgIDs && rgIDs.length > 0 )\n\t\t{\n\t\t\tfor ( var i = 0; i < rgIDs.length; ++i )\n\t\t\t{\n\t\t\t\tvar id = rgIDs[i];\n\t\t\t\tif ( GDynamicStore.s_rgCreatorsIgnored[id] )\n\t\t\t\t{\n\t\t\t\t\trgOverlappingDescIDs.push( id );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn rgOverlappingDescIDs;\n\t},\n\n\tBIsAppOnWishlist: function( appid )\n\t{\n\t\treturn GDynamicStore.s_rgWishlist[appid] ? true: false;\n\t},\n\n\tBIsPackageIgnored: function( packageid )\n\t{\n\t\treturn ( packageid in GDynamicStore.s_rgIgnoredPackages );\n\t},\n\n\tGetCuratorForApp: function( unAppID, bOnlyPositive )\n\t{\n\t\tvar curator = null;\n\t\tif( GDynamicStore.s_rgCurations[unAppID] )\n\t\t{\n\t\t\tvar rgFilteredCuratorIDs = [];\n\t\t\t$J.each(GDynamicStore.s_rgCurations[unAppID], function( unCuratorID, unRecommendationState ){\n\t\t\t\tif( !bOnlyPositive || unRecommendationState == 0  )\n\t\t\t\t\trgFilteredCuratorIDs.push( unCuratorID );\n\t\t\t});\n\n\t\t\tif( rgFilteredCuratorIDs.length )\n\t\t\t{\n\t\t\t\tvar unCuratorID = rgFilteredCuratorIDs[ Math.floor( Math.random() * rgFilteredCuratorIDs.length ) ];\n\t\t\t\treturn {\n\t\t\t\t\t'recommendation_state': GDynamicStore.s_rgCurations[unAppID][unCuratorID],\n\t\t\t\t\t'curator': GDynamicStore.s_rgCurators[unCuratorID]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t},\n\n\tGetCurator: function( clanid )\n\t{\n\t\treturn GDynamicStore.s_rgCurators[ clanid ];\n\t},\n\n\tGetMatchingCreatorFollowed: function( rgAppCreatorRelationship )\n\t{\n\t\tif( GDynamicStore.s_rgCreatorsFollowed )\n\t\t{\n\t\t\tfor( var clanid in rgAppCreatorRelationship )\n\t\t\t{\n\t\t\t\tif( rgAppCreatorRelationship.hasOwnProperty( clanid ) && clanid in GDynamicStore.s_rgCreatorsFollowed )\n\t\t\t\t{\n\t\t\t\t\treturn { 'clanid': clanid, 'relationship': rgAppCreatorRelationship[clanid] }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t},\n\n\tBAreAllAppsOwned: function( rgAppIds, opts )\n\t{\n\t\tfor ( var i = 0; i < rgAppIds.length; i++ )\n\t\t{\n\t\t\tif ( !GDynamicStore.BIsAppOwned( rgAppIds[i], opts ) )\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\tDisplayBundleSimulator: function( unBundleID )\n\t{\n\t\tif ( !GDynamicStore.m_bLoadComplete )\n\t\t{\n\t\t\tGDynamicStore.OnReady( function() { GDynamicStore.DisplayBundleSimulator( unBundleID ) } );\n\t\t\treturn;\n\t\t}\n\n\t\tvar Bundle = GStoreItemData.rgPersonalizedBundleData[ unBundleID ];\n\t\tif ( !Bundle )\n\t\t{\n\t\t\tShowAlertDialog( '', 'Unknown bundle ID ' + unBundleID );\n\t\t\treturn;\n\t\t}\n\n\t\tvar $Form = $J('<form/>', {'class': 'bundle_simulator_form'});\n\t\t$Form.append( $J('<h2/>').text('Выберите товары, которыми «владеете»') );\n\t\t$Form.append( $J('<div/>', {'class': 'bundle_simulator_secondary' } ).append(\n\t\t\t$J('<a/>', {'href': 'javascript:void(0);'} ).click( function() { $Form.find('input').prop('checked', true ); } ).text( \"Выбрать всё\" ),\n\t\t\t' - ',\n\t\t\t$J('<a/>', {'href': 'javascript:void(0);'} ).click( function() { $Form.find('input').prop('checked', false ); } ).text( \"Снять выбор\" )\n\t\t) );\n\n\t\tfor ( var i =0; i < Bundle.m_rgItems.length; i++ )\n\t\t{\n\t\t\tvar BundleItem = Bundle.m_rgItems[i];\n\t\t\tvar id = 'bundle_check_' + i;\n\t\t\tvar nPackageID = BundleItem.m_nPackageID;\n\t\t\tvar rgAppIDs = BundleItem.m_rgIncludedAppIDs;\n\n\t\t\tvar $Row = $J('<div/>', {'class': 'bundle_simulator_row'} );\n\t\t\tvar $Checkbox = $J('<input/>', {type: 'checkbox', id: id } );\n\t\t\tif ( GDynamicStore.s_rgOwnedPackages[nPackageID] || ( rgAppIDs.length && GDynamicStore.BAreAllAppsOwned( rgAppIDs ) ) )\n\t\t\t\t$Checkbox.prop('checked', true);\n\n\t\t\t$Checkbox.data( 'BundleItem', BundleItem );\n\t\t\t$Row.append( $Checkbox );\n\n\t\t\tvar strLabel = GStoreItemData.rgPackageData[nPackageID].name;\n\t\t\tif ( rgAppIDs.length == 1 )\n\t\t\t\tstrLabel = GStoreItemData.rgAppData[rgAppIDs[0]].name;\n\t\t\t$Row.append( $J('<label/>', {'for': id } ).text( strLabel ) );\n\n\t\t\t$Form.append( $Row );\n\t\t}\n\n\t\tvar Modal;\n\n\t\tModal = ShowConfirmDialog( '', $Form, 'Обновить' ).done( function() {\n\t\t\t$Form.find('input').each( function() {\n\t\t\t\tvar $Checkbox = $J(this);\n\t\t\t\tvar BundleItem = $Checkbox.data('BundleItem');\n\t\t\t\tvar nPackageID = BundleItem.m_nPackageID;\n\t\t\t\tvar rgAppIDs = BundleItem.m_rgIncludedAppIDs;\n\t\t\t\tif ( $Checkbox.prop('checked') )\n\t\t\t\t{\n\t\t\t\t\tGDynamicStore.s_rgOwnedPackages[nPackageID] = true;\n\t\t\t\t\tfor ( var i = 0; i < rgAppIDs.length; i++ )\n\t\t\t\t\t\tGDynamicStore.s_rgOwnedApps[rgAppIDs[i]] = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdelete GDynamicStore.s_rgOwnedPackages[nPackageID];\n\t\t\t\t\tfor ( var i = 0; i < rgAppIDs.length; i++ )\n\t\t\t\t\t\tdelete GDynamicStore.s_rgOwnedApps[rgAppIDs[i]];\n\t\t\t\t}\n\n\t\t\t\tGDynamicStore.s_rgPersonalizedBundleData = {};\n\t\t\t\tGDynamicStore.DecorateDynamicItems( null, true );\n\t\t\t});\n\t\t\tModal.GetContent().remove();\n\t\t});\n\t\tModal.SetRemoveContentOnDismissal( false );\n\t}\n};\n\nGStoreItemData = {\n\n\trgAppData: {},\n\trgPackageData: {},\n\trgBundleData: {},\n\trgPersonalizedBundleData: {},\n\trgAccountData: [],\n\trgNavParams: {},\n\t\tfnFormatCurrency: function( nValueInCents, bWholeNumbersOnly ) { return v_numberformat( nValueInCents / 100, bWholeNumbersOnly !== undefined ? bWholeNumbersOnly : false ); },\n\tnCurrencyMinPriceIncrement : 1,\n\n\tAddStoreItemDataSet: function( rgStoreItemData )\n\t{\n\t\tGStoreItemData.AddStoreItemData( rgStoreItemData.rgApps, rgStoreItemData.rgPackages, rgStoreItemData.rgBundles );\n\t},\n\n\t/**\n\t * @deprecated - use AddStoreItemDataSet instead\n\t */\n\tAddStoreItemData: function ( rgApps, rgPackages, rgBundles )\n\t{\n\t\tif ( rgApps && typeof rgApps.length == 'undefined' )\n\t\t{\n\t\t\tfor( var appid in rgApps )\n\t\t\t{\n\t\t\t\tif ( !GStoreItemData.rgAppData[appid] )\n\t\t\t\t\tGStoreItemData.rgAppData[appid] = rgApps[appid];\n\t\t\t\telse\n\t\t\t\t\tGStoreItemData.MergeStoreItemData( GStoreItemData.rgAppData[appid], rgApps[appid] );\n\t\t\t}\n\t\t}\n\n\t\tif ( rgPackages && typeof rgPackages.length == 'undefined' )\n\t\t{\n\t\t\tfor( var packageid in rgPackages )\n\t\t\t{\n\t\t\t\tif ( !GStoreItemData.rgPackageData[packageid] )\n\t\t\t\t\tGStoreItemData.rgPackageData[packageid] = rgPackages[packageid];\n\t\t\t\telse\n\t\t\t\t\tGStoreItemData.MergeStoreItemData( GStoreItemData.rgPackageData[packageid], rgPackages[packageid] );\n\t\t\t}\n\t\t}\n\n\t\tif ( rgBundles && typeof rgBundles.length == 'undefined' )\n\t\t{\n\t\t\tfor( var bundleid in rgBundles )\n\t\t\t{\n\t\t\t\tif ( !GStoreItemData.rgBundleData[bundleid] )\n\t\t\t\t\tGStoreItemData.rgBundleData[bundleid] = rgBundles[bundleid];\n\t\t\t\telse\n\t\t\t\t\tGStoreItemData.MergeStoreItemData( GStoreItemData.rgBundleData[bundleid], rgBundles[bundleid] );\n\t\t\t}\n\t\t}\n\t},\n\n\tGetStoreItemDataForElement: function( $el )\n\t{\n\t\tvar unAppId = $el.data('ds-appid');\n\t\tvar unPackageID = $el.data('ds-packageid');\n\t\tvar unBundleID = $el.data('ds-bundleid' );\n\n\t\tif ( unBundleID && GStoreItemData.rgBundleData[unBundleID] )\n\t\t\treturn { bundleid: unBundleID, item: GStoreItemData.rgBundleData[unBundleID] };\n\n\t\tif( unPackageID && unPackageID.toString().indexOf(',') !== -1 )\n\t\t\tunPackageID = unPackageID.split(',')[0];\n\n\t\tif ( unPackageID && GStoreItemData.rgPackageData[unPackageID] )\n\t\t\treturn { packageid: unPackageID, item: GStoreItemData.rgPackageData[unPackageID] };\n\n\t\tif( unAppId && unAppId.toString().indexOf(',') !== -1 )\n\t\t\tunAppId = unAppId.split(',')[0];\n\n\t\tif ( unAppId && GStoreItemData.rgAppData[unAppId] )\n\t\t\treturn { appid: unAppId, item: GStoreItemData.rgAppData[unAppId] };\n\n\t\treturn { item: undefined };\n\t},\n\n\tAddStoreAccountData: function( rgAccounts )\n\t{\n\t\tif ( rgAccounts && rgAccounts.length > 0 )\n\t\t{\n\t\t\tfor ( var i = 0; i < rgAccounts.length; i++ )\n\t\t\t{\n\t\t\t\tGStoreItemData.rgAccountData.push( rgAccounts[i] );\n\t\t\t}\n\t\t}\n\t},\n\n\tGetAccountData: function( steamid, accountid, type )\n\t{\n\n\t\t// Assume individual account unless otherwise specified.\n\t\tif( !type )\n\t\t\ttype = 1;\n\n\t\t// Search for an accountid instead\n\t\tfor( var i = 0; i < GStoreItemData.rgAccountData.length; i++ )\n\t\t{\n\t\t\tvar account = GStoreItemData.rgAccountData[i];\n\n\t\t\tif( account.accountid == accountid && account.type == type )\n\t\t\t\treturn account;\n\t\t}\n\n\t},\n\n\tSetCurrencyFormatter: function( fn )\n\t{\n\t\tGStoreItemData.fnFormatCurrency = fn;\n\t},\n\n\tSetCurrencyMinPriceIncrement: function( nMinPriceIncrement )\n\t{\n\t\tGStoreItemData.nCurrencyMinPriceIncrement = nMinPriceIncrement;\n\t},\n\n\tCalculateCurrencyAppropriatePrice: function( nPrice )\n\t{\n\t\tif ( GStoreItemData.nCurrencyMinPriceIncrement > 1 )\n\t\t{\n\t\t\tvar nRoundingAmount = GStoreItemData.nCurrencyMinPriceIncrement;\n\t\t\tvar dAmount = nPrice / nRoundingAmount;\n\t\t\t// round \"half away from zero\" - javascript Math.round rounds -1.5 to -1, which is not desired\n\t\t\tvar dSign = dAmount < 0 ? -1 : 1;\n\t\t\tdAmount = ( dSign * Math.floor( Math.abs( dAmount ) + 0.5 ) ) * nRoundingAmount;\n\t\t\tnPrice = dAmount;\n\t\t}\n\n\t\treturn nPrice;\n\t},\n\n\tMergeStoreItemData: function( rgExistingItemData, rgItemData )\n\t{\n\t\tfor( var key in rgItemData )\n\t\t{\n\t\t\tif ( !rgExistingItemData[key] )\n\t\t\t\trgExistingItemData[key] = rgItemData[key];\n\t\t}\n\t},\n\n\tAddNavParams: function( rgNavParams )\n\t{\n\t\tif ( rgNavParams )\n\t\t\t$J.extend( GStoreItemData.rgNavParams, rgNavParams );\n\t},\n\n\tAddNavEventParamsToURL: function( strURL, strFeatureContext, nDepth, nCuratorClanID )\n\t{\n\t\tvar strClanParam = nCuratorClanID ? 'curator_clanid=' + nCuratorClanID : '';\n\t\tif ( strFeatureContext )\n\t\t{\n\t\t\tif ( !GStoreItemData.rgNavParams[strFeatureContext] )\n\t\t\t{\n\t\t\t\t\n\t\t\t\t\t\t\t\tstrFeatureContext = '__page_default';\n\t\t\t}\n\n\t\t\tif ( GStoreItemData.rgNavParams[strFeatureContext] )\n\t\t\t{\n\t\t\t\tvar strNavParam = GStoreItemData.rgNavParams[strFeatureContext];\n\t\t\t\tif ( nDepth )\n\t\t\t\t\tstrNavParam += '_' + parseInt( nDepth );\n\n\t\t\t\tstrURL += ( strURL.indexOf( '?' ) != -1 ? '&' : '?' ) + 'snr=' + strNavParam;\n\t\t\t\tif( strClanParam )\n\t\t\t\t\tstrURL += '&' + strClanParam;\n\t\t\t}\n\t\t}\n\t\telse if( strClanParam )\n\t\t{\n\t\t\tstrURL += ( strURL.indexOf( '?' ) != -1 ? '&' : '?' ) + strClanParam;\n\t\t}\n\t\treturn strURL;\n\t},\n\n\tGetCurrentPageNavParams: function()\n\t{\n\t\t\t\treturn GStoreItemData.rgNavParams['__page_default'];\n\t},\n\n\tGetCurrentPageNavParamObj: function()\n\t{\n\t\t\t\treturn GStoreItemData.rgNavParams['__page_default_obj'];\n\t},\n\n\tGetPreviousPageNavParamObj: function()\n\t{\n\t\t\t\treturn GStoreItemData.rgNavParams['__originating_obj'];\n\t},\n\n\tGetAppURL: function( unAppID, strFeatureContext, nDepth, nCuratorClanID)\n\t{\n\t\tif ( typeof GStoreItemData.rgAppData[ unAppID ] == 'object' && 'url_name' in GStoreItemData.rgAppData[ unAppID ] ) {\n\t\t\treturn GStoreItemData.AddNavEventParamsToURL( 'https://store.steampowered.com/app/' + unAppID + '/' + GStoreItemData.rgAppData[ unAppID ].url_name + '/', strFeatureContext, nDepth, nCuratorClanID )\n\t\t}\n\n\t\treturn GStoreItemData.AddNavEventParamsToURL( 'https://store.steampowered.com/app/' + unAppID + '/', strFeatureContext, nDepth, nCuratorClanID )\n\t},\n\n\tGetPackageURL: function( unPackageID, strFeatureContext, nDepth )\n\t{\n\t\treturn GStoreItemData.AddNavEventParamsToURL( 'https://store.steampowered.com/sub/' + unPackageID + '/', strFeatureContext, nDepth )\n\t},\n\n\tGetBundleURL: function( unBundleID, strFeatureContext, nDepth )\n\t{\n\t\treturn GStoreItemData.AddNavEventParamsToURL( 'https://store.steampowered.com/bundle/' + unBundleID + '/', strFeatureContext, nDepth )\n\t},\n\n\tGetHoverParams: function ( unAppID, unPackageID, unBundleID )\n\t{\n\t\tvar hoverparams;\n\n\t\tif ( unBundleID )\n\t\t\thoverparams = { type: 'bundle', id: unBundleID };\n\t\telse if ( unPackageID )\n\t\t\thoverparams = { type: 'sub', id: unPackageID };\n\t\telse if ( unAppID )\n\t\t\thoverparams = { type: 'app', id: unAppID };\n\t\telse\n\t\t\treturn null;\n\n\t\thoverparams.v6 = 1;\n\t\treturn hoverparams;\n\t},\n\n\tBindHoverEvents: function( $Element, unAppID, unPackageID, unBundleID, rgAdditionalParams )\n\t{\n\t\t$Element.mouseenter( function( event ) {\n\t\t\t\t\tGameHover( this, event, $J('#global_hover'), $J.extend( GStoreItemData.GetHoverParams( unAppID, unPackageID, unBundleID ), rgAdditionalParams || {}) );\n\t\t\t\t}).mouseleave( function( event ) {\n\t\t\t\t\tHideGameHover( this, event, $J('#global_hover') );\n\t\t\t\t});\n\t},\n\n\tBindHoverEventsForItem: function( $Element, oItem, rgAdditionalParams )\n\t{\n\t\treturn GStoreItemData.BindHoverEvents( $Element, oItem.appid, oItem.packageid, oItem.bundleid, rgAdditionalParams );\n\t},\n\n\tGetCapParamsForItem: function( strFeatureContext, rgItem, params, nDepth )\n\t{\n\t\treturn GStoreItemData.GetCapParams( strFeatureContext, rgItem.appid, rgItem.packageid, rgItem.bundleid, params, nDepth );\n\t},\n\n\tGetCapParams: function( strFeatureContext, unAppID, unPackageID, unBundleID, params, nDepth )\n\t{\n\t\tvar rgItemData = null;\n\t\tif( unAppID )\n\t\t\trgItemData = GStoreItemData.rgAppData[ unAppID ];\n\t\telse if( unPackageID )\n\t\t\trgItemData = GStoreItemData.rgPackageData[ unPackageID ];\n\t\telse if( unBundleID )\n\t\t\trgItemData = GStoreItemData.rgBundleData[ unBundleID ];\n\n\t\tif ( !rgItemData )\n\t\t\treturn null;\n\n\t\tif ( !unAppID && rgItemData['appids'] && rgItemData['appids'].length == 1 )\n\t\t{\n\t\t\tunAppID = rgItemData['appids'][0];\n\t\t}\n\n\t\tif ( rgItemData['steam_deck_compat_category'] !== undefined )\n\t\t{\n\t\t\tparams['data-ds-steam-deck-compat-category'] = rgItemData['steam_deck_compat_category'];\n\t\t}\n\n\t\tif ( unAppID )\n\t\t{\n\t\t\tparams['data-ds-appid'] = unAppID;\n\t\t\tparams[ 'href' ] = GStoreItemData.GetAppURL( unAppID, strFeatureContext, nDepth, params['curator_clanid'] );\n\t\t}\n\t\telse if ( unPackageID )\n\t\t{\n\t\t\tparams['data-ds-packageid'] = unPackageID;\n\t\t\tparams['href'] = GStoreItemData.GetPackageURL( unPackageID, strFeatureContext, nDepth );\n\t\t\tif ( rgItemData['appids'] )\n\t\t\t{\n\t\t\t\tparams['data-ds-appid'] = rgItemData['appids'].join( ',' );\n\t\t\t}\n\t\t}\n\t\telse if ( unBundleID )\n\t\t{\n\t\t\tparams['data-ds-bundleid'] = unBundleID;\n\t\t\tparams['href'] = GStoreItemData.GetBundleURL( unBundleID, strFeatureContext, nDepth );\n\t\t\tif ( rgItemData['appids'] )\n\t\t\t{\n\t\t\t\tparams['data-ds-appid'] = rgItemData['appids'].join( ',' );\n\t\t\t}\n\t\t}\n\n\t\tif ( rgItemData.tagids && rgItemData.tagids.length != 0 )\n\t\t{\n\t\t\tparams['data-ds-tagids'] = '[' + rgItemData['tagids'].join( ',' ) + ']';\n\t\t}\n\t\tif ( rgItemData.descids && rgItemData.descids.length != 0 )\n\t\t{\n\t\t\tparams['data-ds-descids'] = '[' + rgItemData['descids'].join( ',' ) + ']';\n\t\t}\n\n\t\t// override with item-specific URL\n\t\tif ( rgItemData.url )\n\t\t\tparams['href'] = GStoreItemData.AddNavEventParamsToURL( rgItemData.url, strFeatureContext, nDepth, params['curator_clanid'] );\n\n\t\treturn rgItemData;\n\t},\n\n\tBuildSupportedPlatformIcon: function( rgItemData )\n\t{\n\t\tvar strHTML = '';\n\t\tvar nPlatforms = 0;\n\n\t\tif ( rgItemData.video )\n\t\t{\n\t\t\tstrHTML += '<span class=\"platform_img streamingvideo\"></span>';\n\t\t}\n\t\telse if ( rgItemData.video360 )\n\t\t{\n\t\t\tstrHTML += '<span class=\"platform_img streaming360video\"></span>';\n\t\t}\n\t\telse if ( rgItemData.videoseries )\n\t\t{\n\t\t\tstrHTML += '<span class=\"platform_img streamingvideoseries\"></span>';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ( rgItemData.os_windows )\n\t\t\t{\n\t\t\t\tstrHTML += '<span class=\"platform_img win\"></span>';\n\t\t\t\tnPlatforms++;\n\t\t\t}\n\t\t\tif ( rgItemData.os_macos )\n\t\t\t{\n\t\t\t\tstrHTML += '<span class=\"platform_img mac\"></span>';\n\t\t\t\tnPlatforms++;\n\t\t\t}\n\t\t\tif ( rgItemData.os_linux )\n\t\t\t{\n\t\t\t\tstrHTML += '<span class=\"platform_img linux\"></span>';\n\t\t\t\tnPlatforms++;\n\t\t\t}\n\t\t}\n\n\t\tif ( rgItemData.vr_htcvive || rgItemData.vr_oculusrift || rgItemData.vr_windowsmr )\n\t\t{\n\t\t\tstrHTML += '<span class=\"platform_img hmd_separator\"></span>';\n\n\t\t\tif ( rgItemData.vr_htcvive )\n\t\t\t{\n\t\t\t\tstrHTML += '<span class=\"platform_img htcvive\"></span>';\n\t\t\t}\n\t\t\tif ( rgItemData.vr_oculusrift )\n\t\t\t{\n\t\t\t\tstrHTML += '<span class=\"platform_img oculusrift\"></span>';\n\t\t\t}\n\t\t\tif ( rgItemData.vr_windowsmr )\n\t\t\t{\n\t\t\t\tstrHTML += '<span class=\"platform_img windowsmr\"></span>';\n\t\t\t}\n\t\t}\n\n\t\treturn strHTML;\n\n\t},\n\n\t// filtering\n\tFilterItemsForDisplay: function( rgItems, Settings, ApplicableSettings, cMaxItemsToDisplay, cMinItemsToDisplay )\n\t{\n\t\tvar rgStrictItems = [], rgGoodItems = [], rgOtherItems = [], rgBadItems = [];\n\n\t\tvar fnAnnotatePriority = function ( item, priority ) { return item; };\n\t\tif ( Settings.include_priority )\n\t\t\tfnAnnotatePriority = function ( item, priority ) { item.priority = priority; return item; };\n\n\t\tif ( !cMaxItemsToDisplay )\n\t\t\tcMaxItemsToDisplay = rgItems.length;\n\n\t\tfor ( var i = 0; i < rgItems.length; i++ )\n\t\t{\n\t\t\tvar oItem = rgItems[i];\n\t\t\tvar unAppID = null, unPackageID = null, unBundleID = null;\n\t\t\tif ( oItem instanceof Object )\n\t\t\t{\n\t\t\t\tif ( oItem.appid )\n\t\t\t\t\tunAppID = oItem.appid;\n\t\t\t\telse if ( oItem.packageid )\n\t\t\t\t\tunPackageID = oItem.packageid;\n\t\t\t\telse if ( oItem.bundleid )\n\t\t\t\t\tunBundleID = oItem.bundleid;\n\t\t\t}\n\n\t\t\tif ( unAppID )\n\t\t\t{\n\t\t\t\tif ( GStoreItemData.BAppPassesFilters( unAppID, Settings, ApplicableSettings, true ) )\n\t\t\t\t\trgStrictItems.push(oItem);\n\t\t\t\telse if ( GStoreItemData.BAppPassesFilters( unAppID, Settings, ApplicableSettings ) )\n\t\t\t\t\trgGoodItems.push(oItem);\n\t\t\t\telse if ( !GDynamicStore.BIsAppIgnored( unAppID ) )\n\t\t\t\t\trgOtherItems.push( oItem );\n\t\t\t\telse\n\t\t\t\t\trgBadItems.push( oItem );\n\t\t\t}\n\t\t\telse if ( unPackageID )\n\t\t\t{\n\t\t\t\tif ( GStoreItemData.BPackagePassesFilters( unPackageID, Settings, ApplicableSettings, true ) )\n\t\t\t\t\trgStrictItems.push( oItem );\n\t\t\t\telse if ( GStoreItemData.BPackagePassesFilters( unPackageID, Settings, ApplicableSettings ) )\n\t\t\t\t\trgGoodItems.push( oItem );\n\t\t\t\telse if ( !GDynamicStore.BIsPackageIgnored( unPackageID ) )\n\t\t\t\t\trgOtherItems.push( oItem );\n\t\t\t\telse\n\t\t\t\t\trgBadItems.push( oItem );\n\t\t\t}\n\t\t\telse if ( unBundleID )\n\t\t\t{\n\t\t\t\tif ( GStoreItemData.BBundlePassesFilters( unBundleID, Settings, ApplicableSettings, true ) )\n\t\t\t\t\trgStrictItems.push( oItem );\n\t\t\t\telse if ( GStoreItemData.BBundlePassesFilters( unBundleID, Settings, ApplicableSettings ) )\n\t\t\t\t\trgGoodItems.push( oItem );\n\t\t\t\telse\n\t\t\t\t\trgOtherItems.push( oItem );\n\t\t\t}\n\n\t\t\tif ( rgStrictItems.length >= cMaxItemsToDisplay)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ( Settings.include_priority )\n\t\t\trgStrictItems.forEach( function( item ) { fnAnnotatePriority( item , 1 ); } );\n\n\t\tif ( cMinItemsToDisplay )\n\t\t{\n\t\t\tfor ( i = 0; rgStrictItems.length < cMinItemsToDisplay && i < rgGoodItems.length; i++ )\n\t\t\t{\n\t\t\t\trgStrictItems.push( fnAnnotatePriority( rgGoodItems[i], 2 ) );\n\t\t\t}\n\n\t\t\tif ( Settings.enforce_minimum )\n\t\t\t{\n\t\t\t\tfor ( i = 0; rgStrictItems.length < cMinItemsToDisplay && i < rgOtherItems.length; i++ )\n\t\t\t\t\trgStrictItems.push( fnAnnotatePriority( rgOtherItems[i], 3 ) );\n\n\t\t\t\tfor ( i = 0; rgStrictItems.length < cMinItemsToDisplay && i < rgBadItems.length; i++ )\n\t\t\t\t\trgStrictItems.push( fnAnnotatePriority( rgBadItems[i], 4 ) );\n\t\t\t}\n\t\t}\n\n\t\treturn rgStrictItems;\n\t},\n\n\n\tBItemPassesFilters: function( rgItemData, Settings, ApplicableSettings )\n\t{\n\t\tif ( ApplicableSettings.only_current_platform && Settings.only_current_platform )\n\t\t{\n\n\t\t\tif (\t( !GDynamicStore.s_bUserOnMacOS || ( GDynamicStore.s_bUserOnMacOS && !rgItemData.os_macos ) ) &&\n\t\t\t\t\t( !GDynamicStore.s_bUserOnLinux || ( GDynamicStore.s_bUserOnLinux && !rgItemData.os_linux ) ) &&\n\t\t\t\t\t( !GDynamicStore.s_bUserOnWindows || ( GDynamicStore.s_bUserOnWindows && !rgItemData.os_windows ) &&\n\t\t\t\t\t( GDynamicStore.s_bUserOnWindows || GDynamicStore.s_bUserOnMacOS || GDynamicStore.s_bUserOnLinux ) )\n\t\t\t\t)\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( rgItemData.coming_soon && ApplicableSettings.prepurchase && !Settings.prepurchase )\n\t\t\treturn false;\n\n\t\treturn true;\n\t},\n\n\tBAppPassesFilters: function( appid, Settings, ApplicableSettings, bStrict )\n\t{\n\t\tvar rgAppData = GStoreItemData.rgAppData[appid];\n\n\t\tif ( !rgAppData )\n\t\t\treturn false;\n\t\t// TODO: score based on filter misses and sort by score?\n\n\t\tif ( !GStoreItemData.BItemPassesFilters( rgAppData, Settings, ApplicableSettings ) )\n\t\t\treturn false;\n\n\t\tif ( GDynamicStore.BIsAppIgnored( appid ) )\n\t\t\treturn false;\n\n\t\tif ( rgAppData.early_access && ApplicableSettings.early_access && !Settings.early_access )\n\t\t\treturn false;\n\n\t\tif ( rgAppData.software && ApplicableSettings.software && !Settings.software )\n\t\t\treturn false;\n\n\t\tif ( rgAppData.dlc && ( ( ApplicableSettings.dlc && !Settings.dlc ) ||\n\t\t\t( ApplicableSettings.dlc_for_you && ( !Settings.dlc_for_you || !rgAppData.dlc_for_app || !GDynamicStore.BIsAppOwned( rgAppData.dlc_for_app, false ) ) ) ) )\n\t\t\treturn false;\n\n\t\tif ( ApplicableSettings.games_already_in_library && !Settings.games_already_in_library && GDynamicStore.BIsAppOwned( appid ) )\n\t\t\treturn false;\n\n\t\tif ( ApplicableSettings.games_not_in_library && !Settings.games_not_in_library && !GDynamicStore.BIsAppOwned( appid ) )\n\t\t\treturn false;\n\n\t\tif ( rgAppData.video && ApplicableSettings.video && !Settings.video )\n\t\t\treturn false;\n\n\t\t// for the strict mode, we check if the app supports any of the preferred languages\n\t\tif ( bStrict && !rgAppData.localized && ApplicableSettings.localized && Settings.localized )\n\t\t\treturn false;\n\n\t\t// for the non-strict pass, we only check English, even if not part of user preferences.\n\t\t// we no longer show random language games if the view calls for localized items\n\t\tif ( !bStrict && !rgAppData.localized_english && ApplicableSettings.localized && Settings.localized )\n\t\t\treturn false;\n\n\t\tif ( bStrict && ApplicableSettings.displayed_elsewhere && !Settings.displayed_elsewhere && GDynamicStore.s_rgDisplayedApps.indexOf( appid ) !== -1 )\n\t\t\treturn false;\n\n\t\tif ( rgAppData.virtual_reality && ApplicableSettings.virtual_reality && !Settings.virtual_reality )\n\t\t\treturn false;\n\n\t\tif ( ApplicableSettings.not_wishlisted && !Settings.not_wishlished && GDynamicStore.BIsAppOnWishlist( appid ) )\n\t\t    return false;\n\n\t\tif ( ApplicableSettings.has_discount && Settings.has_discount )\n\t\t{\n\t\t    if ( !rgAppData.discount_block || rgAppData.discount_block.includes('no_discount') )\n\t\t    {\n\t\t        return false;\n\t\t    }\n        }\n\n        if ( rgAppData.demo_for_app )\n\t\t{\n\t\t\t// skip demos for games that are already owned\n\t\t\tif ( ApplicableSettings.games_already_in_library && !Settings.games_already_in_library && GDynamicStore.BIsAppOwned( rgAppData.demo_for_app ) )\n\t\t\t\treturn false;\n\n\t\t\tif ( bStrict && ApplicableSettings.displayed_elsewhere && !Settings.displayed_elsewhere && GDynamicStore.s_rgDisplayedApps.indexOf( rgAppData.demo_for_app ) !== -1 )\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif ( rgAppData.tagids && rgAppData.tagids.length != 0 )\n\t\t{\n\t\t\tfor ( var i = 0; i < rgAppData.tagids.length; ++i )\n\t\t\t{\n\t\t\t\tvar tagid = rgAppData.tagids[i];\n\t\t\t\tif ( GDynamicStore.s_rgExcludedTags[tagid] )\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( rgAppData.descids && rgAppData.descids.length != 0 )\n\t\t{\n\t\t\tfor ( var i = 0; i < rgAppData.descids.length; ++i )\n\t\t\t{\n\t\t\t\tvar id = rgAppData.descids[i];\n\t\t\t\tif ( GDynamicStore.s_rgExcludedDescIDs[id] )\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If a non-empty list of explicit tag exclusions is specified, reject apps with one of those tags\n\t\tif ( ApplicableSettings.explicitly_excluded_tags && Settings.explicitly_excluded_tags.length > 0 && rgAppData.tagids )\n\t\t{\n\t\t\tfor ( var i = 0; i < rgAppData.tagids.length; ++i )\n\t\t\t{\n\t\t\t\tvar tagid = rgAppData.tagids[i];\n\t\t\t\tif ( Settings.explicitly_excluded_tags.includes( tagid ) )\n\t\t\t\t{\n\t\t\t\t    return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If a non-empty list of explicit tag inclusions is specified, reject apps which don't have one of those tags\n\t\tif ( ApplicableSettings.explicitly_included_tags && Settings.explicitly_included_tags.length > 0 )\n\t\t{\n\t\t    if ( !rgAppData.tagids )\n\t\t    {\n\t\t        return false;\n\t\t    }\n\n\t\t    for ( var i = 0; i < Settings.explicitly_included_tags.length; ++i )\n\t\t    {\n\t\t        var tagid = Settings.explicitly_included_tags[i];\n\t\t        if ( !rgAppData.tagids.includes( tagid ) )\n\t\t        {\n\t\t            return false;\n\t\t        }\n\t\t    }\n\t\t}\n\n\t\tif ( rgAppData.no_main_cap )\n\t\t\treturn false;\n\n\t\treturn true;\n\t},\n\n\tBPackagePassesFilters: function( packageid, Settings, ApplicableSettings, bStrict )\n\t{\n\t\tvar rgPackageData = GStoreItemData.rgPackageData[ packageid ];\n\t\tif ( !rgPackageData )\n\t\t\treturn false;\n\n\t\tif ( !GStoreItemData.BItemPassesFilters( rgPackageData, Settings, ApplicableSettings, bStrict ) )\n\t\t\treturn false;\n\n\t\tif ( !GStoreItemData.BAppIDSetPassesFilters( rgPackageData.appids, Settings, ApplicableSettings, bStrict ) )\n\t\t\treturn false;\n\n\t\tif ( ApplicableSettings.games_already_in_library && !Settings.games_already_in_library && GDynamicStore.BIsPackageOwned( packageid ) )\n\t\t\treturn false;\n\n\t\tif ( GDynamicStore.BIsPackageIgnored( packageid ) )\n\t\t\treturn false;\n\n\t\tif ( bStrict && ApplicableSettings.displayed_elsewhere && !Settings.displayed_elsewhere && GDynamicStore.s_rgDisplayedPackages.indexOf( packageid ) !== -1 )\n\t\t\treturn false;\n\n\t\treturn true;\n\t},\n\n\tBBundlePassesFilters: function( bundleid, Settings, ApplicableSettings, bStrict )\n\t{\n\t\tvar rgBundleData = GStoreItemData.rgBundleData[ bundleid ];\n\n\t\tif ( !rgBundleData )\n\t\t\treturn false;\n\n\t\tif( !GStoreItemData.BItemPassesFilters( rgBundleData, Settings, ApplicableSettings, bStrict ) )\n\t\t\treturn false;\n\n\t\tif ( !GStoreItemData.BAppIDSetPassesFilters( rgBundleData.appids, Settings, ApplicableSettings, bStrict ) )\n\t\t\treturn false;\n\n\t\tif ( bStrict && ApplicableSettings.displayed_elsewhere && !Settings.displayed_elsewhere && GDynamicStore.s_rgDisplayedBundles.indexOf( bundleid ) !== -1 )\n\t\t\treturn false;\n\n\t\treturn true;\n\t},\n\n\tBAppIDSetPassesFilters: function( appids, Settings, ApplicableSettings, bStrict )\n\t{\n\t\t// figure out state of apps\n\t\tvar bAnyAppsOwned = false;\n\t\tfor ( var i = 0; i < appids.length; i++ )\n\t\t{\n\t\t\tif ( GDynamicStore.BIsAppIgnored( appids[i] ) )\n\t\t\t\treturn false;\n\n\t\t\tif ( GDynamicStore.BIsAppOwned( appids[i] ) )\n\t\t\t{\n\t\t\t\tbAnyAppsOwned = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( ApplicableSettings.games_already_in_library && !Settings.games_already_in_library )\n\t\t{\n\t\t\t// any app being owned excludes the package; packages don't grant extra copies (usually)\n\t\t\tif ( bAnyAppsOwned )\n\t\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( ApplicableSettings.games_not_in_library && !Settings.games_not_in_library )\n\t\t{\n\t\t\tif ( !bAnyAppsOwned )\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n};\n\nvar GDynamicStoreHelpers = {\n\n\tBuildCapsuleHTML: function( strFeatureContext, unAppID, unPackageID, unBundleID, rgOptions )\n\t{\n\t\tvar rgOptions = $J.extend({\n\t\t\t'class': 'store_capsule',\n\t\t\t'include_title': false,\n\t\t\t'discount_class': 'discount_block_inline',\n\t\t\t'capsule_size': 'headerv5',\n\t\t\t'html_before_price': '',\n\t\t\t'lazy': false,\n\t\t\t'curator': false\n\t\t}, rgOptions ? rgOptions : {} );\n\n\t\tvar params = { 'class': rgOptions.class };\n\t\tif( rgOptions.curator )\n\t\t\tparams['curator_clanid'] =  rgOptions.curator\n\t\tvar rgItemData = GStoreItemData.GetCapParams( strFeatureContext, unAppID, unPackageID, unBundleID, params );\n\t\tif ( !rgItemData )\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tvar $CapCtn = $J('<a/>', params );\n\n\t\tif ( !rgOptions.no_hover )\n\t\t\tGStoreItemData.BindHoverEvents( $CapCtn, unAppID, unPackageID );\n\n\t\tvar $ImgCtn = $J('<div class=\"capsule\"/>').addClass( rgOptions.capsule_size );\n\n\t\tvar rgImageProperties = { src: rgItemData[rgOptions.capsule_size], alt: rgItemData.name };\n\t\tif( rgOptions.lazy )\n\t\t\trgImageProperties = { 'data-image-url': rgItemData[rgOptions.capsule_size] }\n\n\t\t$ImgCtn.append( $J('<img/>', rgImageProperties ) );\n\t\t$CapCtn.append( $ImgCtn );\n\t\tif( rgOptions.include_title )\n\t\t\t$CapCtn.append( $J('<div/>', {'class': 'title ellipsis' } ).html( rgItemData.name ) );\n\n\t\tif( rgOptions.html_before_price )\n\t\t\t$CapCtn.append( rgOptions.html_before_price );\n\n\t\tif( rgItemData.has_live_broadcast )\n\t\t\t$CapCtn.append( $J( '<div>').addClass( 'broadcast_live_stream_icon' ).append( 'Трансляция' ) );\n\n\t\t$CapCtn.append( $J('<div/>').html( rgItemData.discount_block ? $J(rgItemData.discount_block).addClass( rgOptions.discount_class ) : '&nbsp;' ) );\n\n\t\treturn $CapCtn;\n\t},\n\n\tFillPagedCapsuleCarousel: function( rgCapsules, $elTarget, fnCapsule, strNavContext, nCapsules, rgBaseOptions )\n\t{\n\t\tvar $elCapsuleTarget = $J('.carousel_items', $elTarget);\n\t\tvar $elThumbTarget = $J('.carousel_thumbs', $elTarget);\n\n\t\tvar bPaginated = !$elCapsuleTarget.hasClass('no_paging');\n\n\t\tif ( !bPaginated )\n\t\t\tnCapsules = rgCapsules.length;\n\n\t\t\t\tif( rgCapsules.length < nCapsules )\n\t\t\treturn;\n\n\t\tfor( var j=0; j<rgCapsules.length; j+=nCapsules )\n\t\t{\n\t\t\t// Try to avoid half-filling a page\n\t\t\tif( j > 0 && j+nCapsules > rgCapsules.length && bPaginated )\n\t\t\t\tbreak;\n\n\t\t\tvar $elPageContainer = $J('<div>');\n\t\t\tfor( var k=0; k < nCapsules && k + j < rgCapsules.length; k++ )\n\t\t\t{\n\t\t\t\tvar oItem = rgCapsules[ k + j ];\n\t\t\t\tvar rgOptions = $J.extend({}, rgBaseOptions);\n\t\t\t\tif( j > 0 )\n\t\t\t\t\trgOptions.lazy = true;\n\t\t\t\tvar $CapCtn = fnCapsule( oItem, strNavContext, rgOptions );\n\t\t\t\tif( !$CapCtn )\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Don't try to do automatic visibilty tracking on non-visible clusters.\n\t\t\t\tif( j > 0 )\n\t\t\t\t\t$CapCtn.attr('data-manual-tracking', 1);\n\n\t\t\t\t$elPageContainer.append( $CapCtn );\n\n\t\t\t}\n\n\t\t\t$elCapsuleTarget.append($elPageContainer);\n\n\t\t\tif ( bPaginated )\n\t\t\t{\n\t\t\t\t$elThumbTarget.append($J('<div/>'));\n\t\t\t}\n\t\t}\n\n\t\tif ( $elCapsuleTarget.children().length > 0 )\n\t\t{\n\t\t\t$elCapsuleTarget.InstrumentLinks();\n\t\t\tGDynamicStore.DecorateDynamicItems( $elCapsuleTarget );\n\t\t\t$elTarget.show();\n\t\t}\n\n\t\tif ( bPaginated )\n\t\t\tCreateFadingCarousel( $elTarget, 0 );\n\t},\n\n\tAddSNRDepthParamsToCapsuleList: function( $Capsules )\n\t{\n\t\tvar nDepth = 1;\n\t\t$Capsules.filter('a:visible').each( function() {\n\t\t\tModifyLinkSNR( $J(this), function( snr ) {\n\t\t\t\tvar rgParts = snr.split('_');\n\t\t\t\trgParts[5] = nDepth++;\n\t\t\t\treturn rgParts.join('_');\n\t\t\t});\n\t\t});\n\t}\n};\n\nfunction OnDynamicStorePageException(e)\n{\n\t}\n\nGDynamicStorePage = {\n\toSettings: {},\n\toApplicableSettings: {\"main_cluster\":{\"top_sellers\":true,\"early_access\":true,\"games_already_in_library\":true,\"recommended_for_you\":true,\"prepurchase\":true,\"games\":\"always\",\"software\":true,\"dlc_for_you\":true,\"dlc\":null,\"recently_viewed\":null,\"new_on_steam\":null,\"popular_new_releases\":\"always\",\"games_not_in_library\":null,\"only_current_platform\":true,\"video\":true,\"localized\":true,\"virtual_reality\":true,\"recommended_by_curators\":true,\"hidden\":null},\"new_on_steam\":{\"top_sellers\":null,\"early_access\":true,\"games_already_in_library\":true,\"recommended_for_you\":null,\"prepurchase\":null,\"games\":\"always\",\"software\":true,\"dlc_for_you\":null,\"dlc\":null,\"recently_viewed\":null,\"new_on_steam\":null,\"popular_new_releases\":null,\"games_not_in_library\":null,\"only_current_platform\":true,\"video\":true,\"localized\":true,\"virtual_reality\":true,\"recommended_by_curators\":null,\"hidden\":null},\"recently_updated\":{\"top_sellers\":null,\"early_access\":true,\"games_already_in_library\":null,\"recommended_for_you\":null,\"prepurchase\":null,\"games\":\"always\",\"software\":true,\"dlc_for_you\":null,\"dlc\":null,\"recently_viewed\":null,\"new_on_steam\":null,\"popular_new_releases\":null,\"games_not_in_library\":true,\"only_current_platform\":true,\"video\":true,\"localized\":true,\"virtual_reality\":true,\"recommended_by_curators\":null,\"hidden\":null},\"tabs\":null,\"specials\":null,\"more_recommendations\":null,\"friend_recommendations\":null,\"curators\":{\"top_sellers\":null,\"early_access\":true,\"games_already_in_library\":true,\"recommended_for_you\":null,\"prepurchase\":null,\"games\":\"always\",\"software\":true,\"dlc_for_you\":null,\"dlc\":null,\"recently_viewed\":null,\"new_on_steam\":null,\"popular_new_releases\":null,\"games_not_in_library\":null,\"only_current_platform\":true,\"video\":true,\"localized\":true,\"virtual_reality\":true,\"recommended_by_curators\":null,\"hidden\":null},\"home\":{\"top_sellers\":null,\"early_access\":true,\"games_already_in_library\":null,\"recommended_for_you\":null,\"prepurchase\":true,\"games\":null,\"software\":true,\"dlc_for_you\":null,\"dlc\":null,\"recently_viewed\":null,\"new_on_steam\":null,\"popular_new_releases\":null,\"games_not_in_library\":null,\"only_current_platform\":null,\"video\":true,\"localized\":true,\"virtual_reality\":true,\"recommended_by_curators\":null,\"hidden\":null}},\n\n\tInitUserData: function( rgParams )\n\t{\n\t\ttry {\n\t\t\tGDynamicStorePage.oSettings = rgParams.oSettings;\n\t\t} catch( e ) { OnDynamicStorePageException(e); }\n\t},\n\n\tItemIDFromCapsule: function( $capsule )\n\t{\n\t\tvar unPackageId = $capsule.data('ds-packageid');\n\t\tvar unBundleId = $capsule.data('ds-bundleid');\n\t\tvar unAppId = $capsule.data('ds-appid');\n\n\t\t// bundles set package and appids, packages set appids, so start from the outside and work down.\n\t\tif ( unBundleId )\n\t\t\treturn { bundleid: unBundleId };\n\t\telse if ( unPackageId)\n\t\t\treturn { packageid: unPackageId };\n\t\telse if ( unAppId )\n\t\t\treturn { appid: unAppId };\n\n\t\treturn null;\n\t},\n\n\tBItemValid: function( item, oShownItems, opts )\n\t{\n\t\tvar unAppId = item.appid;\n\n\t\tif( unAppId )\n\t\t{\n\t\t\tvar rgAppIds = [ unAppId ];\n\t\t\tif( unAppId.toString().indexOf(',') !== -1 )\n\t\t\t{\n\t\t\t\trgAppIds = unAppId.toString().split( ',' );\n\t\t\t\tunAppId = rgAppIds[0];\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < rgAppIds.length; i++ )\n\t\t\t{\n\t\t\t\tif ( oShownItems.rgAppIds.indexOf( rgAppIds[i] ) !== -1 )\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( opts && opts.filter_dlc )\n\t\t\t{\n\t\t\t\tvar rgAppData = GStoreItemData.rgAppData[unAppId];\n\n\t\t\t\t// Treat DLC as the base app; so we either show the DLC or the base game; but only one (and whichever is in top position).\n\t\t\t\t// If the user owns the base game already, only show the DLC\n\t\t\t\tif ( rgAppData && rgAppData.dlc_for_app )\n\t\t\t\t{\n\t\t\t\t\tif ( !GDynamicStore.BIsAppOwned( rgAppData.dlc_for_app, false ) )\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\toShownItems.rgAppIds.push( rgAppData.dlc_for_app );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < rgAppIds.length; i++ )\n\t\t\t\toShownItems.rgAppIds.push( rgAppIds[i] );\n\t\t}\n\n\t\tif ( item.packageid )\n\t\t{\n\t\t\tif ( oShownItems.rgPackageIds.indexOf( item.packageid ) !== -1 )\n\t\t\t\treturn false;\n\n\t\t\toShownItems.rgPackageIds.push( item.packageid );\n\t\t}\n\n\t\tif ( item.bundleid )\n\t\t{\n\t\t\tif ( oShownItems.rgBundleIds.indexOf( item.bundleid ) !== -1 )\n\t\t\t\treturn false;\n\n\t\t\toShownItems.rgBundleIds.push( item.bundleid );\n\t\t}\n\n\t\treturn true;\n\t},\n\n\tFilterCapsules: function( nMin, nMax, $elElements, $elContainer, rgFilterParams, bFilterDLC )\n\t{\n\t\t// by default we want to filter DLC\n\t\tif ( bFilterDLC === undefined )\n\t\t\tbFilterDLC = true;\n\n\t\t// Get a list of appids to filter\n\t\tvar rgItems = [];\n\t\tvar oShownItems = { rgAppIds: [], rgPackageIds: [], rgBundleIds: [] };\n\t\tvar rgValidElements = [];\n\n\t\t// Remove duplicates or DLC from the list\n\t\tfor( var i = 0; i < $elElements.length; i++ )\n\t\t{\n\t\t\tvar $capsule = $J( $elElements[i] );\n\t\t\tvar item = GDynamicStorePage.ItemIDFromCapsule( $capsule );\n\t\t\tif ( !item )\n\t\t\t\tcontinue;\n\n\t\t\tif ( GDynamicStorePage.BItemValid( item, oShownItems, { filter_dlc: bFilterDLC } ) )\n\t\t\t{\n\t\t\t\trgItems.push( item );\n\t\t\t\trgValidElements.push( $capsule );\n\t\t\t}\n\t\t\telse\n\t\t\t\t$capsule.remove();\n\t\t}\n\n\t\t// Filter\n\t\tvar rgFilteredItems = this.FilterItemsForDisplay(\n\t\t\trgItems, 'home', nMin, nMax, rgFilterParams\n\t\t);\n\n\t\t// Now follow filters as long we we can keep 4 items in the capsule\n\t\tfor( var i = 0; i < rgValidElements.length; i++ )\n\t\t{\n\t\t\tvar $capsule = rgValidElements[i];\n\t\t\tvar item = GDynamicStorePage.ItemIDFromCapsule( $capsule );\n\t\t\tif ( !item )\n\t\t\t\tcontinue;\n\n\t\t\t// Test our filtered list\n\t\t\tvar bVisible = false;\n\t\t\tif ( this.GetItemFromList( item, rgFilteredItems ) )\n\t\t\t\tbVisible = true;\n\n\t\t\tif( bVisible )\n\t\t\t{\n\t\t\t\t$capsule.removeClass('hidden');\n\n\t\t\t\tif ( $capsule.parent().length )\n\t\t\t\t{\n\t\t\t\t\t$capsule.parent().append( $capsule );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$J( $elContainer ).append( $capsule );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\t$capsule.remove();\n\t\t}\n\n\t\tGDynamicStoreHelpers.AddSNRDepthParamsToCapsuleList( $elElements );\n\n\t\t$elElements.parent().trigger('v_contentschanged');\n\n\t\t//if( nCapsules < nMin && $elContainer )\n\t\t//\t$elContainer.hide();\n\t},\n\n\tGetItemFromList: function( oItem, rgList )\n\t{\n\t\tif( rgList )\n\t\t{\n\t\t\tfor ( var i = 0; i < rgList.length; i++ )\n\t\t\t{\n\t\t\t\tif ( oItem.bundleid && rgList[i].bundleid == oItem.bundleid )\n\t\t\t\t{\n\t\t\t\t\treturn rgList[i];\n\t\t\t\t}\n\t\t\t\telse if ( oItem.packageid && rgList[i].packageid == oItem.packageid )\n\t\t\t\t{\n\t\t\t\t\treturn rgList[i];\n\t\t\t\t}\n\t\t\t\telse if ( oItem.appid && rgList[i].appid == oItem.appid )\n\t\t\t\t{\n\t\t\t\t\treturn rgList[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t},\n\n\tFilterItemsForDisplay: function( rgItems, strSettingsName, cMinItemsToDisplay, cMaxItemsToDisplay, rgAdditionalSettings )\n\t{\n\t\tvar Settings = this.oSettings[strSettingsName] || {};\n\t\tvar ApplicableSettings = this.oApplicableSettings[strSettingsName] || {};\n\n\t\t// Allow sections to have additional, section-specific settings. We'll use jQuery to shallow copy the settings\n\t\t// object so we don't pollute future calls.\n\t\tif( rgAdditionalSettings )\n\t\t{\n\t\t\tSettings = jQuery.extend({}, Settings, rgAdditionalSettings);\n\n\t\t\t// Ensure our feature is turned on as an applicable setting\n\t\t\tfor( var strKey in rgAdditionalSettings )\n\t\t\t\trgAdditionalSettings[strKey] = true;\n\n\t\t\tApplicableSettings = jQuery.extend({}, ApplicableSettings, rgAdditionalSettings);\n\t\t}\n\n\t\tif ( !cMaxItemsToDisplay )\n\t\t\tcMaxItemsToDisplay = cMinItemsToDisplay;\n\n\t\treturn GStoreItemData.FilterItemsForDisplay( rgItems, Settings, ApplicableSettings, cMaxItemsToDisplay, cMinItemsToDisplay )\n\t},\n\n\tFilterAndPrioritizeCapsules: function( rgCapsules, strPriorityListKey, strSettingsName, AdditionalSettings, oShownItems, cMinItemsToDisplay )\n\t{\n\t\t// initialize the shown item list\n\t\tif ( !oShownItems.rgAppIds )\n\t\t\t$J.extend( oShownItems, { rgAppIds: [], rgPackageIds: [], rgBundleIds: [] }, oShownItems );\n\n\t\tvar rgPriorityList = g_rgAppPriorityLists[strPriorityListKey] || [];\n\t\tvar rgItems = [];\n\t\tvar rgUnidentifiedCaps = [];\n\n\t\tfor ( var i = 0; i < rgCapsules.length; i++ )\n\t\t{\n\t\t\tvar $capsule = $J( rgCapsules[i] );\n\t\t\tvar itemid = GDynamicStorePage.ItemIDFromCapsule( $capsule );\n\n\t\t\tif ( !itemid || ( itemid.appid && GDynamicStore.BIsSalePageAppID( itemid.appid ) ) )\n\t\t\t{\n\t\t\t\t// if there's no item associated, preseve it; it's probably a sale page or event\n\t\t\t\trgUnidentifiedCaps.push( i );\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if ( !GDynamicStorePage.BItemValid( itemid, oShownItems ) )\n\t\t\t{\n\t\t\t\t// duplicate\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titemid.capsule = $capsule;\n\t\t\trgItems.push( itemid );\n\t\t}\n\n\t\trgItems =  SortItemListByPriorityList( rgItems, strPriorityListKey );\n\t\tvar rgItems = GDynamicStorePage.FilterItemsForDisplay( rgItems, strSettingsName, cMinItemsToDisplay, rgItems.length, AdditionalSettings );\n\n\t\t// splce anything we don't have info about back in the list in the same position it was before.\n\t\tfor ( var i = 0; i < rgUnidentifiedCaps.length; i++ )\n\t\t{\n\t\t\tvar $capsule = $J( rgCapsules[ rgUnidentifiedCaps[i] ] );\n\t\t\trgItems.splice( rgUnidentifiedCaps[i], 0, { capsule: $capsule, priority: 1 } );\n\t\t}\n\n\n\t\treturn rgItems;\n\t},\n\n\tFilterAndPrioritizeItems: function( rgItems, strPriorityListKey, strSettingsName, AdditionalSettings, oShownItems, cMinItemsToDisplay )\n\t{\n\t\t// initialize the shown item list\n\t\tif ( !oShownItems.rgAppIds )\n\t\t\t$J.extend( oShownItems, { rgAppIds: [], rgPackageIds: [], rgBundleIds: [] }, oShownItems );\n\n\t\t// first filter out items that are dupes of ones we've already been asked to list\n\t\tvar rgItemsNoDupes = [];\n\t\tfor( var i = 0; i < rgItems.length; i++ )\n\t\t{\n\t\t\tif ( GDynamicStorePage.BItemValid( rgItems[i], oShownItems ) )\n\t\t\t\trgItemsNoDupes.push( rgItems[i] );\n\t\t}\n\t\trgItemsNoDupes = SortItemListByPriorityList( rgItemsNoDupes, strPriorityListKey );\n\t\treturn GDynamicStorePage.FilterItemsForDisplay( rgItemsNoDupes, strSettingsName, cMinItemsToDisplay, rgItemsNoDupes.length, AdditionalSettings );\n\t},\n};\n\nvar g_rgAppPriorityLists = {};\nvar g_rgAppPriorityListMaps = {};\nfunction InitAppPriorityLists( rgAppPriorityLists )\n{\n\t$J.extend( g_rgAppPriorityLists, rgAppPriorityLists );\n}\n\nfunction GetAppPriorityListMap( strPriorityListName )\n{\n\tif ( !g_rgAppPriorityListMaps[strPriorityListName] )\n\t{\n\t\tvar rgAppPriorityList = g_rgAppPriorityLists[strPriorityListName] || [];\n\n\t\tvar rgPositionByApp = {};\n\t\tfor ( var i = 0; i < rgAppPriorityList.length; i++ )\n\t\t\trgPositionByApp[ ItemKey( rgAppPriorityList[i] ) ] = i;\n\n\t\tg_rgAppPriorityListMaps[strPriorityListName] = rgPositionByApp;\n\t}\n\n\treturn g_rgAppPriorityListMaps[strPriorityListName];\n}\n\nfunction ItemKey( rgItem )\n{\n\tif ( rgItem.appid )\n\t\treturn 'a' + rgItem.appid;\n\telse if ( rgItem.packageid )\n\t\treturn 'p' + rgItem.packageid;\n\telse if ( rgItem.bundleid )\n\t\treturn 'b' + rgItem.bundleid;\n\n\treturn 'unknown';\n}\n\nfunction SortItemListByPriorityList( rgItemList, strPriorityListName )\n{\n\tvar rgPositionByApp = GetAppPriorityListMap( strPriorityListName );\n\tif ( !rgPositionByApp )\n\t\treturn rgItemList.slice();\n\n\t/*\n\tjavascript sort is stable (except in IE), so this shouldn't be needed\n\tfor ( var i = 0; i < rgItemList.length; i++ )\n\t{\n\t\tvar key = ItemKey( rgItemList[i] );\n\t\tif ( key && rgPositionByApp[key] === undefined )\n\t\t\trgPositionByApp[key] = i + 1000;\n\t}\n\t */\n\n\tvar rgItemListSorted = rgItemList.slice();\n\trgItemListSorted.sort( function( a, b ) {\n\t\tvar posA = rgPositionByApp[ ItemKey( a ) ];\n\t\tvar posB = rgPositionByApp[ ItemKey( b ) ];\n\t\treturn ( posA !== undefined ? posA : 1000 ) - ( posB !== undefined ? posB : 1000 );\n\t});\n\n\tDEBUG_LogItemList( strPriorityListName, rgItemListSorted );\n\n\treturn rgItemListSorted;\n}\n\nfunction DEBUG_LogItemList( strListName, rgItems )\n{\n\t}\n\nfunction ShowHowDoDiscoveryQueuesWorkDialog()\n{\n\t$J.get(\n\t\t'https://store.steampowered.com/explore/howitworks/',\n\t\t{\n\t\t\tl : 'russian'\n\t\t},\n\t\tfunction( data )\n\t\t{\n\t\t\tShowAlertDialog( 'Как это работает?', data );\n\t\t}\n\t);\n}\n\nfunction GetAvatarURL( strHash, strSize )\n{\n\treturn \"https:\\/\\/avatars.cloudflare.steamstatic.com\\/\" + strHash + strSize + '.jpg';\n}\n\nfunction GetScreenshotURL( appid, filename, sizeStr )\n{\n\tif( sizeStr )\n\t\treturn 'https://shared.cloudflare.steamstatic.com/store_item_assets/steam/' + 'apps/' + appid + '/' + filename.replace('.jpg', sizeStr + '.jpg');\n\n\treturn 'https://shared.cloudflare.steamstatic.com/store_item_assets/steam/' + 'apps/' + appid + '/' + filename;\n}\n\n\nfunction UpdatePricesForAdditionalCartDiscount( $Selector, nCartDiscount )\n{\n\tif ( !nCartDiscount )\n\t\treturn;\n\n\tvar strSelector = '[data-price-final]';\n\tvar $DynamicElements = [];\n\tif ( $Selector )\n\t{\n\t\tif ( $Selector.is( strSelector ) )\n\t\t\t$DynamicElements = $Selector;\n\t\telse\n\t\t\t$DynamicElements = $Selector.find( strSelector );\n\t}\n\telse\n\t{\n\t\t$DynamicElements = $J( strSelector );\n\t}\n\n\tfor ( var i = 0; i < $DynamicElements.length; i++ )\n\t{\n\t\t$element = $J($DynamicElements[i]);\n\t\tvar nFinalPrice = parseInt($element.attr('data-price-final'));\n\t\t$element.addClass( 'additional_cart_discount_container' );\n\n\t\tif (!nFinalPrice)\n\t\t\tcontinue;\n\n\t\tvar nToSubtract = Math.min(nFinalPrice, nCartDiscount);\n\t\tvar bNowFree = (nFinalPrice - nToSubtract) <= 0;\n\n\t\tvar strAdditionalDiscountBlock = '<div class=\"additional_cart_discount_amount\">-' + GStoreItemData.fnFormatCurrency(nToSubtract) + '</div>';\n\t\tvar strFinalPriceBlock = '<div class=\"additional_cart_discount_final\">' + GStoreItemData.fnFormatCurrency(nFinalPrice - nToSubtract) + '</div>';\n  \t\tvar $additionalDiscount = $J('<div class=\"additional_cart_discount' + ( bNowFree ? ' NowFree\"' : '\"' ) + ' data-test=\"' + nFinalPrice + '\">' + strAdditionalDiscountBlock + strFinalPriceBlock + '</div>');\n\t\t//var $additionalDiscount = $J('<div class=\"additional_cart_discount\" data-test=\"' + nFinalPrice + '\">' + strAdditionalDiscountBlock + strFinalPriceBlock + '</div>');\n\t\tvar $basePriceStrikeout = $J('<div class=\"basePriceStrikeout\" />');\n\t\t$element.append($basePriceStrikeout);\n\t\t$element.append($additionalDiscount);\n\t}\n}\n\n\nfunction UpdateStoreBannerForAdditionalCartDiscount( nCartDiscount )\n{\n\tif ( !nCartDiscount )\n\t\treturn false;\n\n\tvar strTemplate = ' \\\n\t<div class=\"placeHolder_lunarSale2019_giftActiveBar\">\t\\\n\t\t<div class=\"lunarSale2019_contentContainer\"> \\\n\t\t<div class=\"lunar_sale_poinks01\"> \\\n\t\t<div class=\"lunar_sale_sparkle sparkle01\"> \\\n\t\t\t<div class=\"sparkleStar star1\"></div> \\\n\t\t\t<div class=\"sparkleStar star2\"></div> \\\n\t\t\t<div class=\"sparkleStar star3\"></div> \\\n\t\t</div> \\\n\t\t</div> \\\n\t\t<div class=\"lunar_sale_title\"><img src=\"https://store.cloudflare.steamstatic.com/public/images/promo/lunar2019/lny2019_title_ru.png\"/></div> \\\n\t\t<div class=\"lunar_sale_spacer lunar_leftspacer\"></div> \\\n\t\t<div class=\"lunar_sale_supersavings_label\"><div class=\"highlight\">%header%</div><div class=\"subtitle\">%discount%</div></div> \\\n\t\t<div class=\"lunar_sale_spacer lunar_rightspacer\">\\\n\t\t<div class=\"lunar_sale_poinks02\"> \\\n\t\t\t<div class=\"lunar_sale_sparkle sparkle02\"> \\\n\t\t\t\t<div class=\"sparkleStar star1\"></div> \\\n\t\t\t\t<div class=\"sparkleStar star2\"></div> \\\n\t\t\t\t<div class=\"sparkleStar star3\"></div> \\\n\t\t\t</div> \\\n\t\t</div> \\\n\t\t</div> \\\n\t\t</div> \\\n\t</div> \\\n\t';\n\n\n\tvar strAmount = GStoreItemData.fnFormatCurrency( nCartDiscount );\n\tvar strHeader = 'Действует режим суперэкономии';\n\tvar strDiscount = 'Вы получите скидку %amount%!'.replace( '%amount%', strAmount );\n\tstrTemplate = strTemplate.replace( '%header%', strHeader );\n\tstrTemplate = strTemplate.replace( '%discount%', strDiscount );\n\n\t$Elements = $J( '[data-cart-banner-spot]' );\n\tfor ( var i = 0; i < $Elements.length; i++ )\n\t{\n\t\t$element = $J( $Elements[i] );\n\t\t$element.replaceWith( $J( strTemplate ) );\n\t}\n\n\treturn true;\n}\n\nfunction UpdateStoreBannerForPromotionalDiscount( nDiscount, nMinCartAmount, nAvailableUseCount )\n{\n\tif ( !nDiscount )\n\t\treturn false;\n\n\tif ( !nAvailableUseCount )\n\t\treturn false;\n\n\tif ( $J( 'body.events_hub' ).length )\n\t\treturn false;\n\n\tvar strTemplate = ' \\\n\t<div id=\"promo_header_banner\" class=\"placeHolder_summerSale2020_promotionDetailsBar\" style=\"display:none;\">\t\\\n\t\t<div class=\"summerSale2020_contentContainer\"> \\\n\t\t<div class=\"summersale2020_supersavings_title\">%title%</div> \\\n\t\t<div class=\"summersale2020_supersavings_label\"><div class=\"highlight\">%header%</div><div class=\"subtitle\">%discount%</div></div> \\\n\t\t</div> \\\n\t\t</div> \\\n\t</div> \\\n\t';\n\n\n\tvar strAmount = GStoreItemData.fnFormatCurrency( nDiscount, true );\n\tvar strMinAmount = GStoreItemData.fnFormatCurrency( nMinCartAmount, true );\n\n\tvar strTitle = 'Дорожный бонус';\n\tvar strHeader = 'Сэкономьте ещё %amount% при покупке от %min_amount%'.replace( '%amount%', strAmount ).replace( '%min_amount%', strMinAmount );\n\tvar strDiscount = 'Скидка применяется при оплате';\n\tstrTemplate = strTemplate.replace( '%title%', strTitle );\n\tstrTemplate = strTemplate.replace( '%header%', strHeader );\n\tstrTemplate = strTemplate.replace( '%discount%', strDiscount );\n\n\t$Elements = $J( '[data-cart-banner-spot]' );\n\tfor ( var i = 0; i < $Elements.length; i++ )\n\t{\n\t\t$element = $J( $Elements[i] );\n\t\t$element.replaceWith( $J( strTemplate ) );\n\t\t$J( '#promo_header_banner' ).slideDown( 500 );\n\t}\n\n\treturn true;\n}\n\nfunction BuildCreatorCapsuleToAppend( oItem )\n{\n\tvar $CreatorsCtn = $J('<div class=\"recommended_creators_container\" />');\n\n\tvar $AvatarsCtn = $J('<div class=\"avatars\" />');\n\t$CreatorsCtn.append($AvatarsCtn);\n\n\tvar $AvatarCap = $J('<a href=\"%1$s\" title=\"%3$s\"><img src=\"%2$s\" alt=\"%3$s\"></a>'.replace(/\\%1\\$s/g, oItem.link).replace(/\\%2\\$s/g, GetAvatarURL( oItem.avatar_sha, '_medium' ) ).replace(/\\%3\\$s/g, oItem.name) );\n\t$AvatarsCtn.append( $AvatarCap );\n\n\tvar $Actions = $J('<div class=\"actions\" />');\n\tvar $FollowLink = $J('<a href=\"#\" class=\"btnv6_white_transparent btn_small_thin\" />' );\n\t$FollowLink.data('ds-following', oItem.following );\n\t$FollowLink.bind('updateFollowState', function () {\n\t\tif ( $FollowLink.data('ds-following') )\n\t\t{\n\t\t\t$FollowLink.html( '<span><img src=\"https://store.cloudflare.steamstatic.com/public/images/v6/ico/ico_selected_green.png\">В подписках</span>' );\n\t\t\t$FollowLink.addClass( \"following_button\" );\n\t\t\t$FollowLink.removeClass( \"follow_button\" );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$FollowLink.html( '<span>Подписаться</span>' );\n\t\t\t$FollowLink.removeClass( \"following_button\" );\n\t\t\t$FollowLink.addClass( \"follow_button\" );\n\t\t}\n\t});\n\n\t$FollowLink.trigger('updateFollowState');\n\n\t$FollowLink.on( 'click', function() {\n\t\tFollowCuratorWithCallback( oItem.creatorid, !$FollowLink.data('ds-following'), function(){\n\t\t\t$FollowLink.data('ds-following', !$FollowLink.data('ds-following') );\n\t\t\t$FollowLink.trigger('updateFollowState');\n\t\t});\n\t\tevent.preventDefault();\n\t});\n\n\t$Actions.append( $FollowLink );\n\n\t$AvatarsCtn.append( $Actions );\n\n\treturn $CreatorsCtn;\n}\n\n\n"
          },
          "redirectURL": "",
          "headersSize": 587,
          "bodySize": 24250
        },
        "cache": {},
        "timings": {
          "blocked": -1,
          "dns": 0,
          "connect": 0,
          "ssl": 0,
          "send": 0,
          "wait": 527,
          "receive": 4
        },
        "time": 531,
        "_securityState": "secure",
        "serverIPAddress": "104.18.42.105",
        "connection": "443",
        "pageref": "page_2"
      },
      {
        "startedDateTime": "2025-01-07T15:17:36.985+07:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "https://store.cloudflare.steamstatic.com/public/javascript/prototype-1.7.js?v=.a38iP7Khdmyy&_cdn=cloudflare",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "Host",
              "value": "store.cloudflare.steamstatic.com"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (X11; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "DNT",
              "value": "1"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "no-cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "cross-site"
            }
          ],
          "cookies": [],
          "queryString": [
            {
              "name": "v",
              "value": ".a38iP7Khdmyy"
            },
            {
              "name": "_cdn",
              "value": "cloudflare"
            }
          ],
          "headersSize": 0
        },
        "response": {
          "status": 200,
          "statusText": "",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "date",
              "value": "Tue, 07 Jan 2025 07:21:47 GMT"
            },
            {
              "name": "content-type",
              "value": "text/javascript;charset=UTF-8"
            },
            {
              "name": "content-length",
              "value": "37365"
            },
            {
              "name": "cache-control",
              "value": "public,max-age=15552000"
            },
            {
              "name": "expires",
              "value": "Sat, 03 May 2025 21:36:51 GMT"
            },
            {
              "name": "etag",
              "value": "\".a38iP7Khdmyy\""
            },
            {
              "name": "last-modified",
              "value": "Wed, 28 Jun 2023 04:07:21 GMT"
            },
            {
              "name": "content-encoding",
              "value": "gzip"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=10368000"
            },
            {
              "name": "x-cache",
              "value": "MISS"
            },
            {
              "name": "cf-cache-status",
              "value": "HIT"
            },
            {
              "name": "age",
              "value": "2823378"
            },
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "vary",
              "value": "Accept-Encoding"
            },
            {
              "name": "server",
              "value": "cloudflare"
            },
            {
              "name": "cf-ray",
              "value": "8fe231694c82dd48-HKG"
            },
            {
              "name": "X-Firefox-Spdy",
              "value": "h2"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "text/javascript; charset=UTF-8",
            "size": 0,
            "text": ""
          },
          "redirectURL": "",
          "headersSize": 0,
          "bodySize": 455477
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "ssl": 0,
          "connect": 0,
          "send": 0,
          "wait": 0,
          "receive": 0
        },
        "time": 0,
        "_securityState": "secure",
        "pageref": "page_2"
      },
      {
        "startedDateTime": "2025-01-07T15:17:36.986+07:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "https://store.cloudflare.steamstatic.com/public/javascript/scriptaculous/_combined.js?v=Me1IBxzktiwk&l=russian&_cdn=cloudflare&load=effects,controls,slider",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "Host",
              "value": "store.cloudflare.steamstatic.com"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (X11; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "DNT",
              "value": "1"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "no-cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "cross-site"
            }
          ],
          "cookies": [],
          "queryString": [
            {
              "name": "v",
              "value": "Me1IBxzktiwk"
            },
            {
              "name": "l",
              "value": "russian"
            },
            {
              "name": "_cdn",
              "value": "cloudflare"
            },
            {
              "name": "load",
              "value": "effects,controls,slider"
            }
          ],
          "headersSize": 0
        },
        "response": {
          "status": 200,
          "statusText": "",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "date",
              "value": "Tue, 07 Jan 2025 07:21:47 GMT"
            },
            {
              "name": "content-type",
              "value": "text/javascript;charset=UTF-8"
            },
            {
              "name": "content-length",
              "value": "21242"
            },
            {
              "name": "cache-control",
              "value": "public,max-age=15552000"
            },
            {
              "name": "expires",
              "value": "Mon, 21 Apr 2025 20:48:20 GMT"
            },
            {
              "name": "etag",
              "value": "\"Me1IBxzktiwk\""
            },
            {
              "name": "last-modified",
              "value": "Sun, 09 Sep 2001 01:46:40 GMT"
            },
            {
              "name": "content-encoding",
              "value": "gzip"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=10368000"
            },
            {
              "name": "x-cache",
              "value": "MISS"
            },
            {
              "name": "cf-cache-status",
              "value": "HIT"
            },
            {
              "name": "age",
              "value": "5463092"
            },
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "vary",
              "value": "Accept-Encoding"
            },
            {
              "name": "server",
              "value": "cloudflare"
            },
            {
              "name": "cf-ray",
              "value": "8fe231694c83dd48-HKG"
            },
            {
              "name": "X-Firefox-Spdy",
              "value": "h2"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "text/javascript; charset=UTF-8",
            "size": 0,
            "text": ""
          },
          "redirectURL": "",
          "headersSize": 0,
          "bodySize": 232090
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "ssl": 0,
          "connect": 0,
          "send": 0,
          "wait": 0,
          "receive": 0
        },
        "time": 0,
        "_securityState": "secure",
        "pageref": "page_2"
      },
      {
        "startedDateTime": "2025-01-07T15:17:36.986+07:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "https://store.cloudflare.steamstatic.com/public/javascript/about.js?v=T9HhtJ81mJgN&l=russian&_cdn=cloudflare",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "Host",
              "value": "store.cloudflare.steamstatic.com"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (X11; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "DNT",
              "value": "1"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "no-cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "cross-site"
            }
          ],
          "cookies": [],
          "queryString": [
            {
              "name": "v",
              "value": "T9HhtJ81mJgN"
            },
            {
              "name": "l",
              "value": "russian"
            },
            {
              "name": "_cdn",
              "value": "cloudflare"
            }
          ],
          "headersSize": 0
        },
        "response": {
          "status": 200,
          "statusText": "",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "date",
              "value": "Tue, 07 Jan 2025 07:21:47 GMT"
            },
            {
              "name": "content-type",
              "value": "text/javascript;charset=UTF-8"
            },
            {
              "name": "content-length",
              "value": "790"
            },
            {
              "name": "cache-control",
              "value": "public,max-age=15552000"
            },
            {
              "name": "expires",
              "value": "Sun, 23 Feb 2025 08:45:18 GMT"
            },
            {
              "name": "etag",
              "value": "\"T9HhtJ81mJgN\""
            },
            {
              "name": "last-modified",
              "value": "Sun, 09 Sep 2001 01:46:40 GMT"
            },
            {
              "name": "content-encoding",
              "value": "gzip"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=10368000"
            },
            {
              "name": "x-cache",
              "value": "MISS"
            },
            {
              "name": "cf-cache-status",
              "value": "HIT"
            },
            {
              "name": "age",
              "value": "11113816"
            },
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "vary",
              "value": "Accept-Encoding"
            },
            {
              "name": "server",
              "value": "cloudflare"
            },
            {
              "name": "cf-ray",
              "value": "8fe231694c84dd48-HKG"
            },
            {
              "name": "X-Firefox-Spdy",
              "value": "h2"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "text/javascript; charset=UTF-8",
            "size": 0,
            "text": ""
          },
          "redirectURL": "",
          "headersSize": 0,
          "bodySize": 7619
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "ssl": 0,
          "connect": 0,
          "send": 0,
          "wait": 0,
          "receive": 0
        },
        "time": 0,
        "_securityState": "secure",
        "pageref": "page_2"
      },
      {
        "startedDateTime": "2025-01-07T15:17:36.989+07:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "https://store.cloudflare.steamstatic.com/public/shared/javascript/shared_responsive_adapter.js?v=cxQV9f417bc5&l=russian&_cdn=cloudflare",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "Host",
              "value": "store.cloudflare.steamstatic.com"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (X11; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "DNT",
              "value": "1"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "no-cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "cross-site"
            },
            {
              "name": "If-Modified-Since",
              "value": "Mon, 20 Apr 1970 06:43:19 GMT"
            },
            {
              "name": "If-None-Match",
              "value": "\"OHdNdTEQflFo\""
            },
            {
              "name": "Priority",
              "value": "u=2"
            },
            {
              "name": "TE",
              "value": "trailers"
            }
          ],
          "cookies": [],
          "queryString": [
            {
              "name": "v",
              "value": "cxQV9f417bc5"
            },
            {
              "name": "l",
              "value": "russian"
            },
            {
              "name": "_cdn",
              "value": "cloudflare"
            }
          ],
          "headersSize": 541
        },
        "response": {
          "status": 200,
          "statusText": "",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "date",
              "value": "Tue, 07 Jan 2025 08:17:37 GMT"
            },
            {
              "name": "content-type",
              "value": "text/javascript;charset=UTF-8"
            },
            {
              "name": "content-length",
              "value": "7037"
            },
            {
              "name": "cache-control",
              "value": "public,max-age=0,must-revalidate"
            },
            {
              "name": "expires",
              "value": "Sun, 09 Sep 2001 01:46:40 GMT"
            },
            {
              "name": "etag",
              "value": "\"OHdNdTEQflFo\""
            },
            {
              "name": "x-integrity",
              "value": "\"sha384-5wJmM8faNzg6SLOISTO6iahH3Puy0RhF09qz9eu2aCDDH6zF6RiMyR1joGlLFB9+\""
            },
            {
              "name": "last-modified",
              "value": "Mon, 20 Apr 1970 06:43:19 GMT"
            },
            {
              "name": "content-encoding",
              "value": "gzip"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=10368000"
            },
            {
              "name": "x-cache",
              "value": "MISS"
            },
            {
              "name": "cf-cache-status",
              "value": "MISS"
            },
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "vary",
              "value": "Accept-Encoding"
            },
            {
              "name": "server",
              "value": "cloudflare"
            },
            {
              "name": "cf-ray",
              "value": "8fe2832e5e0d095d-HKG"
            },
            {
              "name": "X-Firefox-Spdy",
              "value": "h2"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "text/javascript; charset=UTF-8",
            "size": 24239,
            "text": "\"use strict\";\n\n// build our menu on init\njQuery( function($) {\n\tvar mqQueryMenuMode = window.matchMedia ? window.matchMedia(\"(max-width: 910px)\") : {matches: false};\n\tvar mqMobileMode = window.matchMedia ? window.matchMedia(\"(max-width: 500px)\") : {matches: false};\n\n\tvar $HTML = $J('html');\n\twindow.UseTouchFriendlyMode = function() {\n\t\treturn $HTML.hasClass( 'responsive' ) && ( mqQueryMenuMode.matches || $HTML.hasClass('touch') );\n\t};\n\twindow.UseSmallScreenMode = function() {\n\t\treturn $HTML.hasClass( 'responsive' ) && mqQueryMenuMode.matches;\n\t};\n\twindow.UseMobileScreenMode = function() {\n\t\treturn $HTML.hasClass( 'responsive' ) && mqMobileMode.matches;\n\t};\n\twindow.UseTabletScreenMode = function() {\n\t\treturn $HTML.hasClass( 'responsive' ) && $HTML.hasClass( 'tablet' );\n\t};\n\twindow.UseNewMobileAppMode = function() {\n\t\t// the new mobile app can run on screen widths wider than responsive_css_maxwidth\n\t\treturn $HTML.hasClass( 'responsive' ) && $HTML.hasClass( 'rn_mobile_app' );\n\t};\n\n\t// main menu\n\n\tvar $Menu = $('#responsive_page_menu');\n\tvar $Frame = $('.responsive_page_frame');\n\tvar $ContentCtn = $('.responsive_page_content' );\n\tvar $ContentOverlay = $('.responsive_page_content_overlay');\n\n\tvar fnResetMenuState = function() {\n\t\t$Frame.removeClass( 'mainmenu_active');\n\t\t$Frame.removeClass('localmenu_active');\n\t\t$J(document.body).removeClass( 'overflow_hidden' );\n\n\t\t$ContentOverlay.off( 'click.ReponsiveMenuDismiss');\n\t};\n\n\t$J(document).on('click.OnClickDismissMenu', '.responsive_OnClickDismissMenu', fnResetMenuState );\n\n\tvar strLastExpandedSubmenu = WebStorage.GetLocalSession( 'responsiveMenuLastSubmenu' );\n\n\tvar fnMakeExpandableMenuItem = function( $MenuItem, $Submenu )\n\t{\n\t\t$MenuItem.append( $J('<div/>', {'class': 'chevron' } ) );\n\n\n\t\tvar $SubmenuWrapper = $J('<div/>', {'class': 'menuitem_submenu_wrapper' });\n\t\t$MenuItem.after( $SubmenuWrapper.append( $Submenu ) );\n\t\t$Submenu.wrap( $('<div/>', {'class': 'inner_borders' } ) );\n\n\t\t// if this was the last used submenu, start with it expanded\n\t\tif ( strLastExpandedSubmenu && strLastExpandedSubmenu == $Submenu.data('submenuid') )\n\t\t{\n\t\t\t$SubmenuWrapper.css( 'height', $Submenu.height() + 'px' );\n\t\t\t$MenuItem.addClass( 'submenu_active' );\n\t\t\t$SubmenuWrapper.addClass('active');\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$SubmenuWrapper.css( 'height', 0 );\n\t\t}\n\n\t\t$Submenu.show();\n\n\t\t$MenuItem.click( function(e) {\n\t\t\te.preventDefault();\n\t\t\tif ( $SubmenuWrapper.hasClass('active' ) )\n\t\t\t{\n\t\t\t\t$SubmenuWrapper.removeClass('active' ).css('height',0);\n\t\t\t\t$MenuItem.removeClass('submenu_active');\n\t\t\t\tWebStorage.SetLocalSession( 'responsiveMenuLastSubmenu', null );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$SubmenuWrapper.siblings( '.menuitem_submenu_wrapper.active' ).css('height',0 ).removeClass('active');\n\t\t\t\t$MenuItem.siblings('.menuitem').removeClass('submenu_active');\n\t\t\t\t$SubmenuWrapper.css( 'height', $Submenu.height() + 'px' );\n\t\t\t\t$MenuItem.addClass( 'submenu_active' );\n\t\t\t\t$SubmenuWrapper.addClass('active');\n\t\t\t\tWebStorage.SetLocalSession( 'responsiveMenuLastSubmenu', $Submenu.data('submenuid') );\n\t\t\t}\n\t\t});\n\t};\n\n\tvar fnBuildMenuEvents = function( $Menu, strMenuName, fnFirstTimeInitialization )\n\t{\n\t\tvar strActiveClass = strMenuName + '_active';\n\t\tvar fnGPOnClosingModalWindow = null;\n\n\t\tvar fnDismissMenu = function() {\n\t\t\t$ContentCtn.off( 'click.ReponsiveMenuDismiss');\n\t\t\t$Frame.removeClass(strActiveClass);\n\t\t\t$J(document.body).removeClass('overflow_hidden' );\n\n\t\t\t// tell gamepad navigation we're closing the menu\n\t\t\tif ( fnGPOnClosingModalWindow )\n\t\t\t{\n\t\t\t\tfnGPOnClosingModalWindow();\n\t\t\t\tfnGPOnClosingModalWindow = null;\n\t\t\t}\n\n\t\t\twindow.setTimeout( function() {\n\t\t\t\tif ( !$Frame.hasClass('mainmenu_active') && !$Frame.hasClass('localmenu_active') )\n\t\t\t\t{\n\t\t\t\t\tfnResetMenuState();\n\t\t\t\t}\n\t\t\t}, 500 );\n\t\t};\n\n\t\tvar bInitialized = false;\n\t\tvar fnActivateMenu = function() {\n\t\t\tif ( !bInitialized )\n\t\t\t{\n\t\t\t\tfnFirstTimeInitialization && fnFirstTimeInitialization();\n\t\t\t\tbInitialized = true;\n\t\t\t}\n\n\t\t\tif ( $Frame.hasClass( strActiveClass ) )\n\t\t\t{\n\t\t\t\tfnDismissMenu();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$J(document.body).addClass('overflow_hidden' );\n\t\t\t\t$Menu.removeClass('secondary_active');\n\t\t\t\t$Frame.addClass( strActiveClass );\n\t\t\t\t$ContentOverlay.one( 'click.ResponsiveMenuDismiss', function() {\n\t\t\t\t\tfnDismissMenu();\n\t\t\t\t});\n\n\t\t\t\t// tell gamepad navigation to treat this menu as a modal dialog\n\t\t\t\tif ( typeof GPOnShowingModalWindow === \"function\" )\n\t\t\t\t\tfnGPOnClosingModalWindow = GPOnShowingModalWindow( $Menu.get( 0 ) );\n\t\t\t}\n\t\t};\n\n\t\treturn { fnActivateMenu: fnActivateMenu, fnDismissMenu: fnDismissMenu };\n\t};\n\n\tvar fnInitMainMenu = function() {\n\t\t$('.responsive_page_menu' ).find( '.supernav').each( function() {\n\t\t\tvar $Element = $(this);\n\t\t\t$Element.attr('href','');\n\t\t\tvar strSubmenuSelector = $Element.data('tooltip-content');\n\t\t\tvar $Submenu = $Element.parent().find(strSubmenuSelector);\n\t\t\tif ( $Submenu.length )\n\t\t\t{\n\t\t\t\tfnMakeExpandableMenuItem( $Element, $Submenu );\n\t\t\t}\n\t\t});\n\n\t\tvar $NotificationItem = $Menu.find( '.notifications_item' );\n\t\tvar $NotificationSubmenu = $Menu.find('.notification_submenu');\n\t\tif ( $NotificationItem.length && $NotificationSubmenu.length )\n\t\t{\n\t\t\tfnMakeExpandableMenuItem( $NotificationItem, $NotificationSubmenu );\n\t\t}\n\t\tResponsive_BuildChangeLanguageOption( $Menu.find( '.change_language_action' ) );\n\t};\n\n\tvar MainMenuEvents = null;\n\tif ( $Menu.length )\n\t{\n\t\tMainMenuEvents = fnBuildMenuEvents( $Menu, 'mainmenu', fnInitMainMenu );\n\n\n\t\t$('#responsive_menu_logo' ).click( function( e ) {\n\t\t\tMainMenuEvents.fnActivateMenu();\n\t\t} );\n\t}\n\n\n\t// local (page-specific) menu\n\n\tvar $LocalMenuContent = $('.responsive_local_menu');\n\tvar $LocalMenu = null;\n\tvar LocalMenuEvents = null;\n\tif ( $LocalMenuContent.length )\n\t{\n\t\tvar bLocalMenuEnabed = false;\n\t\tvar rgMenuContents = [];\n\n\t\tvar fnInitLocalMenu = function() {\n\t\t\tif ( rgMenuContents.length )\n\t\t\t\treturn;\n\n\t\t\tfor ( var i = 0; i < $LocalMenuContent.length; i++ )\n\t\t\t{\n\t\t\t\tvar $LocalMenuElement = $($LocalMenuContent[i] ).wrap( $J('<div/>', {'class': 'responsive_local_menu_placeholder' } ) );\n\t\t\t\tvar $LocalMenuWrapper = $($LocalMenuContent[i]).parent();\n\t\t\t\trgMenuContents.push( {\n\t\t\t\t\twrapper: $LocalMenuWrapper,\n\t\t\t\t\tcontent: $LocalMenuElement\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t$LocalMenu = $J('#responsive_page_local_menu');\n\t\tvar $Affordance = $J('.responsive_local_menu_tab');\n\n\t\tLocalMenuEvents = fnBuildMenuEvents( $LocalMenu, 'localmenu' );\n\n\t\t$Affordance.click( function( e ) {\n\t\t\tLocalMenuEvents.fnActivateMenu();\n\t\t});\n\n\t\tg_fnActivateLocalMenu = LocalMenuEvents.fnActivateMenu;\n\n\t\t$(window ).on( 'Responsive_SmallScreenModeToggled.ReponsiveLocalMenu', function() {\n\t\t\tvar bShouldUseResponsiveMenu = UseSmallScreenMode();\n\t\t\tif ( bLocalMenuEnabed != bShouldUseResponsiveMenu )\n\t\t\t{\n\t\t\t\tif ( bShouldUseResponsiveMenu )\n\t\t\t\t{\n\t\t\t\t\t$Affordance.addClass( 'active' );\n\t\t\t\t\tfnInitLocalMenu();\n\t\t\t\t\t$LocalMenu.find('.localmenu_content' ).append( $LocalMenuContent );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfnResetMenuState();\n\t\t\t\t\t$Affordance.removeClass('active');\n\t\t\t\t\tfor ( var i = 0; i < rgMenuContents.length; i++ )\n\t\t\t\t\t{\n\t\t\t\t\t\trgMenuContents[i].wrapper.append( rgMenuContents[i].content );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbLocalMenuEnabed = bShouldUseResponsiveMenu;\n\t\t\t}\n\t\t} ).trigger( 'Responsive_SmallScreenModeToggled.ReponsiveLocalMenu');\n\n\t\t// menu is available, so set the action description for the page content.\n\t\tGPNavUpdateActionDescriptions( $('#responsive_page_template_content'), { onOptionsActionDescription:'Меню' } );\n\t\t$('#responsive_page_template_content').on( 'vgp_onoptions', function() { LocalMenuEvents.fnActivateMenu(); } );\n\t}\n\n\tResponsive_InitMenuSwipes( $, $Menu, $LocalMenu, MainMenuEvents, LocalMenuEvents );\n\n\tResponsive_InitFixOnScroll( $ );\n\n\tResponsive_InitTouchDetection( $ );\n\n\tResponsive_InitTabSelect( $ );\n\n\tResponsive_InitResponsiveToggleEvents( $ );\n\n\tResponsive_InitJQPlotHooks( $ );\n\n\tif ( window.UseTabletScreenMode && window.UseTabletScreenMode() )\n\t\tResponsive_InitForTablet( $ );\n});\n\nfunction Responsive_InitForTablet( $ )\n{\n\t// support using gamepad to change slider position\n\t$( 'input[type=range]' ).on( 'vgp_ondirection', function( event ) {\n\n\t\tif ( event.originalEvent.detail.button == 11 || event.originalEvent.detail.button == 12 )\n\t\t{\n\t\t\tif ( event.originalEvent.detail.button == 11 ) // EGamepadButton.DIR_LEFT\n\t\t\t\tthis.stepDown();\n\t\t\telse if ( event.originalEvent.detail.button == 12 ) // EGamepadButton.DIR_RIGHT\n\t\t\t\tthis.stepUp();\n\n\t\t\t$( this ).trigger( 'input' ).trigger( 'change' );\n\n\t\t\treturn false; // prevent the message from propagating\n\t\t}\n\t} );\n}\n\nfunction Responsive_InitMenuSwipes( $, $Menu, $LocalMenu, MainMenuEvents, LocalMenuEvents )\n{\n\tif ( !MainMenuEvents && !LocalMenuEvents )\n\t\treturn;\n\n\tvar $Frame = $('.responsive_page_frame');\n\t// set up touch drag events\n\tvar bInMainMenuDrag = false;\n\tvar bInLocalMenuDrag = false;\n\tvar bInDismissMenuDrag = false;\n\tvar bLooksLikeSwipe = false;\n\tvar nDragMenuWidth = 0;\n\n\tvar nCurDragOffset = 0;\n\tvar nTouchStartPageX = 0;\t// page/CSS coordinates because that's how we measure the menu width\n\tvar nTouchStartPageY = 0;\n\n\tvar fnGetSingleTouch = function(e) {\n\t\tvar TouchEvent = e.originalEvent;\n\t\tvar rgTouches = TouchEvent ? TouchEvent.touches : null;\n\t\tif ( !rgTouches || rgTouches.length != 1 )\n\t\t\treturn null;\n\t\treturn rgTouches[0];\n\t};\n\tvar fnCancelDrag = function()\n\t{\n\t\t$Frame.removeClass('in_menu_drag');\n\t\tif ( bLooksLikeSwipe )\n\t\t{\n\t\t\tvar DragMenuEvents = bInMainMenuDrag ? MainMenuEvents : LocalMenuEvents;\n\t\t\tvar $DragMenu = bInMainMenuDrag ? $Menu : $LocalMenu;\n\t\t\t$DragMenu.parents('.responsive_page_menu_ctn' ).css( 'left', '' ).css( 'right', '' );\n\t\t\tif ( ( !bInDismissMenuDrag && nCurDragOffset < nDragMenuWidth / 2 ) ||\n\t\t\t\t( bInDismissMenuDrag && nCurDragOffset > nDragMenuWidth / 2 ) )\n\t\t\t{\n\t\t\t\tDragMenuEvents.fnDismissMenu();\n\t\t\t}\n\t\t}\n\n\t\tbInLocalMenuDrag = bInMainMenuDrag = bLooksLikeSwipe = bInDismissMenuDrag = false;\n\t};\n\t$(window ).on('touchstart.ResponsiveMenuActivate', function(e) {\n\t\tif ( !UseSmallScreenMode() )\n\t\t\treturn;\n\n\t\tvar Touch = fnGetSingleTouch(e);\n\t\tif ( !Touch )\n\t\t\treturn;\n\n\t\tif ( $Frame.hasClass('mainmenu_active') )\n\t\t{\n\t\t\tif ( Touch.clientX > $Menu.width() * 0.9 )\n\t\t\t{\n\t\t\t\tbInMainMenuDrag = true;\n\t\t\t\tbInDismissMenuDrag = true;\n\t\t\t}\n\t\t}\n\t\telse if ( $Frame.hasClass('localmenu_active') )\n\t\t{\n\t\t\tif ( Touch.clientX < ( window.innerWidth - $LocalMenu.width() * 0.9 ) )\n\t\t\t{\n\t\t\t\tbInLocalMenuDrag = true;\n\t\t\t\tbInDismissMenuDrag = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar nClientXAsPct = 100 * Touch.clientX / window.innerWidth;\n\t\t\tbInDismissMenuDrag = false;\n\t\t\tif ( nClientXAsPct > 93 && LocalMenuEvents )\n\t\t\t\tbInLocalMenuDrag = true;\n\t\t\telse if ( nClientXAsPct < 7 && MainMenuEvents )\n\t\t\t\tbInMainMenuDrag = true;\n\t\t}\n\n\t\tif ( bInLocalMenuDrag || bInMainMenuDrag )\n\t\t{\n\t\t\tbLooksLikeSwipe = false;\n\t\t\tnTouchStartPageX = Touch.pageX;\n\t\t\tnTouchStartPageY = Touch.pageY;\n\t\t}\n\t});\n\t$(window ).on('touchmove.ResponsiveMenuActive', function(e) {\n\t\tif ( !bInLocalMenuDrag && !bInMainMenuDrag )\n\t\t\treturn;\n\n\t\tvar Touch = fnGetSingleTouch(e);\n\t\tif ( !Touch )\n\t\t\treturn;\n\t\tvar nDeltaPageX = Touch.pageX - nTouchStartPageX;\n\t\tvar nDeltaPageY = Touch.pageY - nTouchStartPageY;\n\n\t\tif ( ( bInLocalMenuDrag && !bInDismissMenuDrag ) || ( bInMainMenuDrag && bInDismissMenuDrag ) )\n\t\t\tnDeltaPageX = -nDeltaPageX;\n\n\t\tvar DragMenuEvents = bInMainMenuDrag ? MainMenuEvents : LocalMenuEvents;\n\t\tvar $DragMenu = bInMainMenuDrag ? $Menu : $LocalMenu;\n\n\t\tif ( !bLooksLikeSwipe && nDeltaPageX > 25 && nDeltaPageX > nDeltaPageY * 2 )\n\t\t{\n\t\t\t// horizontal drag\n\t\t\t$Frame.addClass('in_menu_drag');\n\t\t\tif ( !bInDismissMenuDrag )\n\t\t\t\tDragMenuEvents.fnActivateMenu();\n\t\t\t//$Frame.addClass( bInLocalMenuDrag ? 'localmenu_active' : 'mainmenu_active' );\n\t\t\tnDragMenuWidth = $DragMenu.width();\n\t\t\tbLooksLikeSwipe = true;\n\t\t}\n\t\telse if ( nDeltaPageY > 2 * nDeltaPageX )\n\t\t{\n\t\t\t// looks like scrolling?\n\t\t\tfnCancelDrag();\n\t\t\treturn;\n\t\t}\n\n\n\t\tif ( bLooksLikeSwipe )\n\t\t{\n\t\t\tnCurDragOffset = Math.max( Math.min( nDeltaPageX, nDragMenuWidth ), 0 );\n\n\t\t\tvar nOffset = bInDismissMenuDrag ? -nCurDragOffset : -(nDragMenuWidth - nCurDragOffset);\n\n\t\t\t$DragMenu.parents('.responsive_page_menu_ctn' ).css( bInLocalMenuDrag ? 'right' : 'left', nOffset + 'px' );\n\t\t}\n\t});\n\t$(window ).on('touchend.ResponsiveMenuActivate touchcancel.ResponsiveMenuActivate', function(e) {\n\t\tfnCancelDrag();\n\t});\n}\n\nfunction Responsive_InitTouchDetection( $ )\n{\n\tvar $HTML= $J('html');\n\tif ( !$HTML.hasClass('touch') && $HTML.hasClass('responsive') )\n\t{\n\t\t$J(window ).one('touchstart', function() {\n\t\t\t// user is on a touch device - enable touch-friendly accessors and\n\t\t\t// remember for the rest of this session\n\n\t\t\t$HTML.addClass('touch');\n\t\t\tV_SetCookie( \"strResponsiveViewPrefs\", 'touch', 0 );\n\t\t} );\n\t}\n}\n\nfunction Responsive_InitTabSelect( $ )\n{\n\t// handle any tab dropdowns\n\t$J(document).on('change.ResponsiveTabSelect', 'select.responsive_tab_select', function() {\n\t\tvar url = $J(this ).val();\n\t\tif ( url != window.location )\n\t\t\twindow.location = url;\n\t});\n}\n\nfunction Responsive_InitFixOnScroll($)\n{\n\tvar $Ctn = $J('.responsive_fixonscroll_ctn');\n\tvar $Elements = $J('.responsive_fixonscroll');\n\tif ( $Elements.length )\n\t{\n\t\tvar nCtnTop = -1;\n\t\tvar nCtnHeight = 0;\n\n\t\t$J(window).on('scroll.ResponsiveFixOnScroll resize.ResponsiveFixOnScroll', function() {\n\t\t\tvar nHeaderOffset = GetResponsiveHeaderFixedOffsetAdjustment();\n\t\t\tvar nScrollTop = $J(window ).scrollTop() + nHeaderOffset + nCtnHeight;\n\n\t\t\tif ( nHeaderOffset != nCtnTop )\n\t\t\t{\n\t\t\t\tnCtnTop = nHeaderOffset;\n\t\t\t\t$Ctn.css( 'top', nCtnTop + 'px' );\n\t\t\t}\n\t\t\t$Elements.each( function() {\n\t\t\t\tvar $Element = $J(this);\n\t\t\t\tif ( !$Element.is(':visible') )\n\t\t\t\t{\n\t\t\t\t\tif ( $Element.hasClass('in_fixed_ctn') && $Element.data('originalContents') )\n\t\t\t\t\t{\n\t\t\t\t\t\t$Element.append( $Element.data('originalContents') );\n\t\t\t\t\t\t$Element.removeClass('in_fixed_ctn');\n\t\t\t\t\t\t$Element.css('height', '');\n\t\t\t\t\t\tnCtnHeight = $Ctn.height();\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar nElementTop = $Element.offset().top;\n\t\t\t\tif ( nElementTop > nScrollTop )\n\t\t\t\t{\n\t\t\t\t\tif ( $Element.hasClass('in_fixed_ctn') )\n\t\t\t\t\t{\n\t\t\t\t\t\t$Element.append( $Element.data('originalContents') );\n\t\t\t\t\t\t$Element.removeClass('in_fixed_ctn');\n\t\t\t\t\t\t$Element.css('height', '');\n\t\t\t\t\t\tnCtnHeight = $Ctn.height();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ( !$Element.hasClass('in_fixed_ctn') )\n\t\t\t\t\t{\n\t\t\t\t\t\t$Element.css('height', $Element.height() + 'px' );\n\t\t\t\t\t\t$Element.data( 'originalContents', $Element.children() );\n\t\t\t\t\t\t$Ctn.append( $Element.children() );\n\t\t\t\t\t\t$Element.addClass( 'in_fixed_ctn' );\n\t\t\t\t\t\tnCtnHeight = $Ctn.height();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} );\n\t}\n}\n\nfunction Responsive_BuildChangeLanguageOption( $MenuItem )\n{\n\t$MenuItem.click( function() {\n\t\tvar $LanguageForm = $J('<form/>', {'class': 'responsive_change_language_form' } );\n\t\tvar $SelectBox = $J('<select/>', {'class': 'responsive_change_language_select' } );\n\t\t$SelectBox.append(\n\t\t\t$J('<option/>', {value: \"russian\"} ).text( 'Русский (Russian)' )\n\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"schinese\"} ).text( '简体中文 (упрощенный китайский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"tchinese\"} ).text( '繁體中文 (традиционный китайский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"japanese\"} ).text( '日本語 (японский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"koreana\"} ).text( '한국어 (корейский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"thai\"} ).text( 'ไทย (тайский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"bulgarian\"} ).text( 'Български (болгарский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"czech\"} ).text( 'Čeština (чешский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"danish\"} ).text( 'Dansk (датский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"german\"} ).text( 'Deutsch (немецкий)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"english\"} ).text( 'English (английский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"spanish\"} ).text( 'Español - España (испанский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"latam\"} ).text( 'Español - Latinoamérica (латиноам. испанский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"greek\"} ).text( 'Ελληνικά (греческий)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"french\"} ).text( 'Français (французский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"italian\"} ).text( 'Italiano (итальянский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"hungarian\"} ).text( 'Magyar (венгерский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"dutch\"} ).text( 'Nederlands (нидерландский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"norwegian\"} ).text( 'Norsk (норвежский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"polish\"} ).text( 'Polski (польский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"portuguese\"} ).text( 'Português (португальский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"brazilian\"} ).text( 'Português-Brasil (бразильский португальский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"romanian\"} ).text( 'Română (румынский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"finnish\"} ).text( 'Suomi (финский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"swedish\"} ).text( 'Svenska (шведский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"turkish\"} ).text( 'Türkçe (турецкий)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"vietnamese\"} ).text( 'Tiếng Việt (вьетнамский)' )\n\t\t\t);\n\t\t\t\t\t$SelectBox.append(\n\t\t\t\t$J('<option/>', {value: \"ukrainian\"} ).text( 'Українська (украинский)' )\n\t\t\t);\n\t\t\n\t\tvar Modal = null;\n\n\t\tvar fnChangeLanguage = function() {\n\t\t\tif ( $SelectBox.val() != \"russian\" )\n\t\t\t\tChangeLanguage( $SelectBox.val() );\n\t\t\tModal && Modal.Dismiss();\n\t\t};\n\n\t\t$LanguageForm.submit( function(e) {\n\t\t\te.preventDefault();\n\t\t\tfnChangeLanguage();\n\t\t});\n\t\t$SelectBox.change( fnChangeLanguage );\n\n\t\t$LanguageForm.append( $SelectBox );\n\t\t$LanguageForm.append( $J('<input/>', {type: 'submit'} ).hide() );\n\t\tModal = ShowConfirmDialog( 'Изменить язык', $LanguageForm, 'Изменить язык' ).done( fnChangeLanguage );\n\t\t$SelectBox.focus();\n\t});\n}\n\nfunction Responsive_RequestDesktopView()\n{\n\t// we can dynamically switch, but this doesn't trigger the phone to zoom out and some elements don't resize right\n\t/*\n\t$J('html' ).removeClass('responsive touch' ).addClass('force_desktop');\n\t$J('meta[name=viewport]' ).attr('value', '' );\n\t$J(window ).trigger('resize');\n\t*/\n\tResponsive_UpdateResponsivePrefs( 'desktop', true );\n\twindow.location.reload();\n}\n\nfunction Responsive_RequestMobileView()\n{\n\t/*\n\t$J('html' ).removeClass('force_desktop' ).addClass('responsive');\n\t$J('meta[name=viewport]' ).attr('value', 'width=device-width,initial-scale=1' );\n\t$J(window ).trigger('resize');\n\t*/\n\tResponsive_UpdateResponsivePrefs( 'desktop', false );\n\twindow.location.reload();\n}\n\n\nfunction Responsive_UpdateResponsivePrefs( strFlag, bEnabled )\n{\n\tif ( bEnabled )\n\t{\n\t\tV_SetCookie( \"strResponsiveViewPrefs\", strFlag, 365 );\n\t}\n\telse\n\t{\n\t\tV_SetCookie( \"strResponsiveViewPrefs\", null, -1 );\n\t}\n}\n\nfunction Responsive_InitResponsiveToggleEvents( $ )\n{\n\t// initially undefined, so we will fire the events at at start\n\tvar bTouchFriendly, bSmallScreen, bMobileScreen, bTabletScreen;\n\n\t$(window).on('resize.ResponsiveToggle', function() {\n\t\tif ( window.UseTouchFriendlyMode() !== bTouchFriendly )\n\t\t{\n\t\t\tbTouchFriendly = window.UseTouchFriendlyMode();\n\t\t\t$(window).trigger('Responsive_TouchFriendlyModeToggled');\n\t\t}\n\n\t\tif ( window.UseSmallScreenMode() !== bSmallScreen )\n\t\t{\n\t\t\tbSmallScreen = window.UseSmallScreenMode();\n\t\t\t$(window).trigger('Responsive_SmallScreenModeToggled');\n\t\t}\n\n\t\tif ( window.UseMobileScreenMode() !== bMobileScreen )\n\t\t{\n\t\t\tbMobileScreen = window.UseMobileScreenMode();\n\t\t\t$(window).trigger('Responsive_MobileScreenModeToggled');\n\t\t}\n\n\t\tif ( window.UseTabletScreenMode() !== bTabletScreen )\n\t\t{\n\t\t\tbTabletScreen = window.UseTabletScreenMode();\n\t\t\t$(window).trigger('Responsive_TabletScreenModeToggled');\n\t\t}\n\n\n\t} ).trigger( 'resize.ResponsiveToggle' );\n}\n\n/* reparent element when screen width is up to MOBILE_RESPONSIVE_CSS_MAXWIDTH */\nfunction Responsive_ReparentItemsInMobileMode( strItemSelector, $CtnOrFn )\n{\n\treturn _Responsive_ReparentItems( strItemSelector, $CtnOrFn, function() { return window.UseMobileScreenMode && window.UseMobileScreenMode(); }, 'Responsive_MobileScreenModeToggled' );\n}\n\n/* reparent element when we're rendering in the tablet layout (which could be any screen size given docked tablet scenarios) */\nfunction Responsive_ReparentItemsInTabletMode( strItemSelector, $CtnOrFn )\n{\n\treturn _Responsive_ReparentItems( strItemSelector, $CtnOrFn, function() { return window.UseTabletScreenMode && window.UseTabletScreenMode(); }, 'Responsive_TabletScreenModeToggled' );\n}\n\n/* reparent element when screen width is up to RESPONSIVE_CSS_MAXWIDTH, or we're in TabletScreenMode */\nfunction Responsive_ReparentItemsInResponsiveMode( strItemSelector, $CtnOrFn )\n{\n\treturn _Responsive_ReparentItems( strItemSelector, $CtnOrFn, function() { return ( ( window.UseSmallScreenMode && window.UseSmallScreenMode() ) || ( window.UseTabletScreenMode && window.UseTabletScreenMode() ) ); }, 'Responsive_SmallScreenModeToggled' );\n}\n\nfunction _Responsive_ReparentItems( strItemSelector, $CtnOrFn, fnShouldReparent, bEvent )\n{\n\tvar fnReparentItems = function() {\n\n\t\tvar $MoveElements = $J(strItemSelector);\n\t\t$MoveElements.each( function() {\n\t\t\tvar $Element = $J(this);\n\t\t\tvar $OriginalSpot = $Element.data('originalSpot' + bEvent);\n\n\t\t\tif ( fnShouldReparent() )\n\t\t\t{\n                if ( !$OriginalSpot )\n                {\n                \t$OriginalSpot = $J( '<div/>' );\n                    $Element.after( $OriginalSpot );\n                    $Element.data('originalSpot' + bEvent, $OriginalSpot );\n                }\n\n\t\t\t\tvar $Ctn;\n\t\t\t\tif ( typeof $CtnOrFn === 'function' ) {\n\t\t\t\t\t$Ctn = $CtnOrFn( $Element );\n\t\t\t\t} else {\n\t\t\t\t\t$Ctn = $CtnOrFn;\n\t\t\t\t}\n\n\t\t\t\t$Ctn.append( $Element );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ( $OriginalSpot )\n\t\t\t\t{\n\t\t\t\t\t// If we've tracked an original parent, put us back\n\t\t\t\t\t$OriginalSpot.after( $Element );\n\t\t\t\t\t$OriginalSpot.remove();\n\t\t\t\t\t$Element.removeData( 'originalSpot' + bEvent );\n\t\t\t\t}\n\t\t\t\t// Otherwise, we should already be where we want\n\t\t\t}\n\t\t});\n\n\t};\n\n\tfnReparentItems();\n\t$J( window ).on( bEvent, fnReparentItems );\n}\n\nfunction Responsive_InitJQPlotHooks( $ )\n{\n\tif ( $.jqplot )\n\t{\n\t\t$.jqplot.postInitHooks.push( function( name, data, options ) {\n\t\t\tvar jqplot = this;\n\t\t\tvar bWasInResponsiveMode;\n\n\t\t\t//replotting is very expensive, so we try to delay if the user is actively resizing\n\t\t\tvar iReplotInterval;\n\t\t\t$J(window).resize( function() {\n\t\t\t\tif ( ( UseSmallScreenMode() || bWasInResponsiveMode ) )\n\t\t\t\t{\n\t\t\t\t\tif ( iReplotInterval )\n\t\t\t\t\t{\n\t\t\t\t\t\t// we will reschedule for 100ms from now\n\t\t\t\t\t\twindow.clearInterval( iReplotInterval );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//interval hasn't been scheduled yet, must be the first resize.\n\t\t\t\t\t\t// set overflow to hidden so the plot doesn't stretch the page while resizing\n\t\t\t\t\t\tjqplot.target.css( 'overflow', 'hidden' );\n\t\t\t\t\t}\n\n\t\t\t\t\tiReplotInterval = window.setTimeout( function() {\n\t\t\t\t\t\tiReplotInterval = null;\n\n\t\t\t\t\t\tjqplot.replot();\n\n\t\t\t\t\t\tjqplot.target.css( 'overflow', '' );\n\t\t\t\t\t}, 100 );\n\n\t\t\t\t\tbWasInResponsiveMode = UseSmallScreenMode();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\n// Enable toggling the local menu via JS\n// Added so search can support use of a gamepad button to open the filter window\nvar g_fnActivateLocalMenu = false;\nfunction Responsive_ToggleLocalMenu()\n{\n\tif ( g_fnActivateLocalMenu )\n\t\tg_fnActivateLocalMenu();\n\telse\n\t\tconsole.error(\"attempted to open a local menu which does not exist\");\n}"
          },
          "redirectURL": "",
          "headersSize": 586,
          "bodySize": 7623
        },
        "cache": {},
        "timings": {
          "blocked": -1,
          "dns": 0,
          "connect": 0,
          "ssl": 0,
          "send": 0,
          "wait": 389,
          "receive": 1
        },
        "time": 390,
        "_securityState": "secure",
        "serverIPAddress": "104.18.42.105",
        "connection": "443",
        "pageref": "page_2"
      },
      {
        "startedDateTime": "2025-01-07T15:17:36.989+07:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js",
          "httpVersion": "HTTP/3",
          "headers": [
            {
              "name": "Host",
              "value": "cdnjs.cloudflare.com"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (X11; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "DNT",
              "value": "1"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "no-cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "cross-site"
            }
          ],
          "cookies": [],
          "queryString": [],
          "headersSize": 0
        },
        "response": {
          "status": 200,
          "statusText": "",
          "httpVersion": "HTTP/3",
          "headers": [
            {
              "name": "date",
              "value": "Tue, 07 Jan 2025 07:21:47 GMT"
            },
            {
              "name": "content-type",
              "value": "application/javascript; charset=utf-8"
            },
            {
              "name": "content-length",
              "value": "27748"
            },
            {
              "name": "access-control-allow-origin",
              "value": "*"
            },
            {
              "name": "cache-control",
              "value": "public, max-age=30672000"
            },
            {
              "name": "content-encoding",
              "value": "br"
            },
            {
              "name": "etag",
              "value": "\"5eb03ec4-15851\""
            },
            {
              "name": "last-modified",
              "value": "Mon, 04 May 2020 16:11:48 GMT"
            },
            {
              "name": "cf-cdnjs-via",
              "value": "cfworker/kv"
            },
            {
              "name": "cross-origin-resource-policy",
              "value": "cross-origin"
            },
            {
              "name": "timing-allow-origin",
              "value": "*"
            },
            {
              "name": "x-content-type-options",
              "value": "nosniff"
            },
            {
              "name": "vary",
              "value": "Accept-Encoding"
            },
            {
              "name": "cf-cache-status",
              "value": "HIT"
            },
            {
              "name": "age",
              "value": "1073541"
            },
            {
              "name": "expires",
              "value": "Sun, 28 Dec 2025 07:21:47 GMT"
            },
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "priority",
              "value": "u=2,i=?0"
            },
            {
              "name": "report-to",
              "value": "{\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report\\/v4?s=jij3pwLZ0xxj8P47%2BQ7EH4CmC4IuEQcB5HWvRShVbwP15zYsUygnudyCOzWuiwVaxEv7CnqpjqXVq9f6dfXKIDA%2Ba%2Ftv8vAAgjmCG5c6V56RWbzBfAUXBYnwSvQH%2F2WNtoWAci7h\"}],\"group\":\"cf-nel\",\"max_age\":604800}"
            },
            {
              "name": "nel",
              "value": "{\"success_fraction\":0.01,\"report_to\":\"cf-nel\",\"max_age\":604800}"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=15780000"
            },
            {
              "name": "server",
              "value": "cloudflare"
            },
            {
              "name": "cf-ray",
              "value": "8fe231693a5f5df6-HKG"
            },
            {
              "name": "alt-svc",
              "value": "h3=\":443\"; ma=86400"
            },
            {
              "name": "server-timing",
              "value": "cfExtPri"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "application/javascript; charset=utf-8",
            "size": 0,
            "text": ""
          },
          "redirectURL": "",
          "headersSize": 0,
          "bodySize": 387420
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "ssl": 0,
          "connect": 0,
          "send": 0,
          "wait": 0,
          "receive": 0
        },
        "time": 0,
        "_securityState": "secure",
        "pageref": "page_2"
      },
      {
        "startedDateTime": "2025-01-07T15:17:36.990+07:00",
        "request": {
          "bodySize": 0,
          "method": "GET",
          "url": "https://code.jquery.com/ui/1.11.3/jquery-ui.js",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "Host",
              "value": "code.jquery.com"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (X11; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0"
            },
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.5"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "DNT",
              "value": "1"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "no-cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "cross-site"
            }
          ],
          "cookies": [],
          "queryString": [],
          "headersSize": 0
        },
        "response": {
          "status": 200,
          "statusText": "",
          "httpVersion": "HTTP/2",
          "headers": [
            {
              "name": "server",
              "value": "nginx"
            },
            {
              "name": "content-type",
              "value": "application/javascript; charset=utf-8"
            },
            {
              "name": "last-modified",
              "value": "Fri, 18 Oct 1991 12:00:00 GMT"
            },
            {
              "name": "etag",
              "value": "W/\"28feccc0-72b1e\""
            },
            {
              "name": "cache-control",
              "value": "public, max-age=31536000, stale-while-revalidate=604800"
            },
            {
              "name": "access-control-allow-origin",
              "value": "*"
            },
            {
              "name": "cross-origin-resource-policy",
              "value": "cross-origin"
            },
            {
              "name": "content-encoding",
              "value": "gzip"
            },
            {
              "name": "via",
              "value": "1.1 varnish, 1.1 varnish"
            },
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "date",
              "value": "Tue, 07 Jan 2025 07:21:47 GMT"
            },
            {
              "name": "age",
              "value": "1465032"
            },
            {
              "name": "x-served-by",
              "value": "cache-lga21958-LGA, cache-qpg120090-QPG"
            },
            {
              "name": "x-cache",
              "value": "HIT, HIT"
            },
            {
              "name": "x-cache-hits",
              "value": "236, 1456"
            },
            {
              "name": "x-timer",
              "value": "S1736234508.791072,VS0,VE0"
            },
            {
              "name": "vary",
              "value": "Accept-Encoding"
            },
            {
              "name": "content-length",
              "value": "113814"
            },
            {
              "name": "X-Firefox-Spdy",
              "value": "h2"
            }
          ],
          "cookies": [],
          "content": {
            "mimeType": "application/javascript; charset=utf-8",
            "size": 0,
            "text": ""
          },
          "redirectURL": "",
          "headersSize": 0,
          "bodySize": 1094947
        },
        "cache": {},
        "timings": {
          "blocked": 0,
          "dns": 0,
          "ssl": 0,
          "connect": 0,
          "send": 0,
          "wait": 0,
          "receive": 0
        },
        "time": 0,
        "_securityState": "secure",
        "pageref": "page_2"
      }
    ]
  }
}